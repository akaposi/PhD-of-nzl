\AgdaHide{
\begin{code}

module GroupoidLaws where


open import Relation.Binary.PropositionalEquality 
open import Data.Product renaming (_,_ to _,,_)
open import Data.Nat


open import AIOOG renaming (_∾_ to htrans)
open import AIOOGS2
open import Suspension
open import BasicLaws


\end{code}
}

As long as the basic laws are defined, we can move to one level higher, to verfiy the five groupoid laws. Similarly the basic ones are inhabited trivially because of the contexts are contractible, the general ones can be generated by lifting functions.

\AgdaHide{
\begin{code}

reflX : Tm (vX =h vX)
reflX = refl-Tm * +tm _ +tm _

reflY : Tm (vY =h vY)
reflY = refl-Tm * +tm _

\end{code}
}

\begin{code}
Tm-right-identity* : Tm {x:*,y:*,α:x=y}
         (trans*-Tm [ IdCm _ , vY , reflY ]tm =h vα)
Tm-right-identity* = Coh-Contr (ext c* v0)

Tm-left-identity* : Tm {x:*,y:*,α:x=y}
         (trans*-Tm [ ((IdCm _ ⊚ pr1 ⊚ pr1) , vX) , reflX , vY , vα ]tm =h vα)
Tm-left-identity* = Coh-Contr (ext c* v0)


Tm-right-inverse* : Tm {x:*,y:*,α:x=y}
         (trans*-Tm [ ((IdCm _) , vX) , sym*-Tm ]tm =h reflX)
Tm-right-inverse* = Coh-Contr (ext c* v0)


Tm-left-inverse* : Tm {x:*,y:*,α:x=y}
         (trans*-Tm [ ((• , vY) , vX , sym*-Tm , vY) , vα ]tm =h reflY)
Tm-left-inverse* = Coh-Contr (ext c* v0)

\end{code}

\AgdaHide{
\begin{code}

m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q : Con
m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q = x:*,y:*,α:x=y,z:*,β:y=z , * , (var (vS (vS v0)) =h var v0)

vM : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} *
vM = var (vS (vS (vS (vS (vS (vS v0))))))

vN : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} *
vN = var (vS (vS (vS (vS (vS v0)))))

vMN : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} (vM =h vN)
vMN = var (vS (vS (vS (vS v0))))

vP : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} *
vP = var (vS (vS (vS v0)))

vNP : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} (vN =h vP)
vNP = var (vS (vS v0))

vQ : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} *
vQ = var (vS v0)

vPQ : Tm {m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q} (vP =h vQ)
vPQ = var v0

\end{code}
}

\begin{code}

Ty-G-assoc* : Ty m:*,n:*,α:m=n,p:*,β:n=p,q:*,γ:p=q
Ty-G-assoc* = (trans*-Tm [ ((((• , vM) , vP) , 
                       (trans*-Tm [ pr1 ⊚ pr1 ]tm)) , vQ) , vPQ ]tm =h 
             trans*-Tm [ (pr1 ⊚ pr1 ⊚ pr1 ⊚ pr1 , vQ) , 
                       (trans*-Tm [ ((((• , vN) , vP) , vNP) , vQ) , vPQ ]tm) ]tm)

Tm-G-assoc* : Tm Ty-G-assoc*
Tm-G-assoc* = Coh-Contr (ext (ext (ext c* v0) (vS v0)) (vS v0))

Tm-G-assoc : {Γ : Con}(A : Ty Γ) → Tm (rpl-T A Ty-G-assoc*)
Tm-G-assoc A =  rpl-tm A Tm-G-assoc* 

\end{code}


There are still more higher level coherence laws to prove but it is going to be very sophisticated. However the idea is similar, we could prove the basic one is inhabited due to the contractibility of contexts and then lift them.

 We also tried to construct the J-eliminator for equality in this syntactic approach but have not found a solution.