%&latex

\documentclass[envcountsame]{llncs}

\pagestyle{headings}

\title{First Year PhD Annual Report}

%make a proper TOC despite llncs
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter

\author{LI Nuo}

\institute{University of Nottingham}

\usepackage{dsfont}

%\usepackage{amsthm}


\usepackage{color}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{xypic}

% Editing and debugging
%\hfuzz 0.1pt
%\overfullrule=15pt
%\brokenpenalty=10000
\newcommand{\todo}[1]{\textcolor{red}{TO~DO:~#1}}


\newcommand{\ed}[1]{\textcolor{blue}{#1}}


\newtheorem{assumption}[theorem]{Assumption}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}


\newcommand{\dotph}{\,\cdot\,}
\newcommand{\dotop}{\mathrel{.}}
\providecommand{\abs}  [1]{\lvert#1\rvert}
\providecommand{\norm} [1]{\lVert#1\rVert}
\providecommand{\class}[1]{[#1]}
\providecommand{\set}  [1]{\left\{#1\right\}}
\providecommand{\dlift}[1]{\widehat{#1}}

\DeclareMathOperator{\Prop}{\mathbf{Prop}}
\DeclareMathOperator{\Set}{\mathbf{Set}}
\DeclareMathOperator{\Ext}{Ext}
\DeclareMathOperator{\Bool}{Bool}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\sound}{sound}
\DeclareMathOperator{\qelimbeta}{qelim-\beta}
\DeclareMathOperator{\qind}{qind}
\DeclareMathOperator{\exact}{exact}
\DeclareMathOperator{\subst}{subst}
\DeclareMathOperator{\emb}{emb}
\DeclareMathOperator{\complete}{complete}
\DeclareMathOperator{\stable}{stable}
\DeclareMathOperator{\List}{List}
\DeclareMathOperator{\Fin}{Fin}
\DeclareMathOperator{\now}{now}
\DeclareMathOperator{\later}{later}
\DeclareMathOperator{\nowequal}{now_\sqsubseteq}
\DeclareMathOperator{\laterequal}{later_\sqsubseteq}
\DeclareMathOperator{\laterleft}{later_{left}}
\DeclareMathOperator{\inl}{inl}
\DeclareMathOperator{\inr}{inr}
\DeclareMathOperator{\qelim}{qelim}
\DeclareMathOperator{\lift}{lift}
\DeclareMathOperator{\LC}{LC}
\DeclareMathOperator{\liftbeta}{lift-\beta}
\DeclareMathOperator{\Bijection}{Bijection}
\DeclareMathOperator{\true}{true}
\DeclareMathOperator{\false}{false}
\DeclareMathOperator{\sort}{sort}
\DeclareMathOperator{\length}{length}
\DeclareMathOperator{\nub}{nub}
\DeclareMathOperator{\suc}{suc\,}
\DeclareMathOperator{\defi}{\stackrel{\text{\tiny def}}{=}}
\DeclareMathOperator{\coprime}{Coprime}

\DeclareMathOperator{\A/sim}{A\,/ \sim}

\newcommand{\eqqm}{\overset{\text{\tiny ?}}{=}}
\newcommand{\sep}{\mathrel{\sharp}}


% For xy matrices
\newcommand{\pullbackcorner}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\pushoutcorner} [1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}

\newcommand{\itt}{intensional Type Theory}
\newcommand{\ett}{extensional Type Theory}
\newcommand{\mltt}{Martin-L\"{o}f type theory}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{lemma}[theorem]{Lemma}
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}[section]
%\newtheorem{proposition}[theorem]{Proposition}

\usepackage{varioref}

\begin{document}

\maketitle

%\newpage

\tableofcontents

\newpage 

\begin{abstract}
%\todo{enhance the connection within between ideas. Split the two
%ideas in the abstract: why in general quotient is useful and
%implementing in Agda.}


% use of quotients is a 
% types before objects rather than objects before in set theory
%  what is itt what is ett what is the diff and what implementation is
%  itt or ett? more detail and technical?
% always be more precise , give explanation, examples, list things,
% not use complicated
% what i want to do, plan, proposal, explain the context of that paper
% why it is good to use the quotient, examples. 
%suggestion: 
% 1. extend the txa:1999 to quotients, integrate quotients into these
% 2. to prove the conservativity of itt + quotients ove ett,
% formalisation and detail.
% 3. smaller goals on the way
% 4. what I have done formalise proofs in Agda. Develop the
% backgroud. how I have done related to others, motivation, why it is
% interesting what I have read, diff between ett and itt. in my
% undergraduate thesis.
% 5. Plan and steps to achieve these.

Given a set equipped with an equivalence relation, one can form its
quotient set, that is the set of equivalence classes. Reinterpreting
this notion in type theory, quotient type is formalised by a given type with
one of its equivalence relations. However in \itt{}  the quotient type is
still unavailable. The introduction of quotient type will enable us to define
real numbers, functionals, and some other sets which are not definable
in current implementations of \itt(),  such as Agda which is also a
theorem prover. Also we can still benefit from the interaction of
types within some quotients without using quotient types. Because some
base types are simpler to deal with or have better features while what
we want to use is the new type, for instance the integers represented
by a pair of natural numbers is easier to handled compared to the
normal form integers. We undertake this project to conduct a research
on the implementation of quotients in Agda. This report aims at
introducing quotient types and investigate some related work on this
topic. I will also give some explanations to some
results which has been done by Altenkirch, Thomas and me in \cite{aan}
and show some instances in this report as a complement to it.

%For some definable quotients like the integers and the rational numbers,
%it is unnecessary to formalise them based on setoid. But we found the quotient %interface could provide more convenience if we prove that they are definable %quotients. While some other types such as real numbers are undefinable, %but they are the quotient of dividing cauchy sequences of rational numbers %by the equivalence relation that two sequences converges. 

\end{abstract}


\section{Introduction}


In mathematics, a quotient represents the result of division. The
notion of quotient is extended to other abstracted branches of mathematics. For example, we
have quotient set, quotient group, quotient space, quotient category
etc. They all define similar operations.

In everyday life, we can find quotient in our daily life. When you take a
picture by a digital camera, the real scence is divided into each pixel
on the picture, or we can say the real scence within a certain area is
identified. The digital picture is just the quotient. Since things are equated
with respect to certain rules, quotient is usually mentioned with
information hiding or losing. In computer science, we also see
quotient everywhere. Users are only concerned the extensional use of
softwares rather than the intensional implementation of them, therefore
softwares doing the same tasks are the same to them even they are
programmed in two different languages. When doing programming, different
classes implemented the same \emph{interface} are extensionally equal.

In this report, I will mainly discuss quotient type in type
theory, which can be seen as the interpretation of quotient set in set
theory although they are fundamentally different. Since set theory is
more familiar to some of you we will start from introducing qotient sets.

\subsection{Quotient Set} 

The division of sets is different from division of numbers. We divide a
given set into small groups according to a given equivalence relation
and the quotient is the set of these groups.

Formally, given a set $A$ and an equivalence relation $\sim$ on $A$, the equivalence class for each $a \,\in A$ is,

\[\class a =\{b \in A \,|\, b \sim a \}\  \]

The quotient set denoted as $\A/sim$ is the set of equivalence classes of $\sim$,

\[\A/sim =\{[a] \in \wp(A) \,|\, a \in A\}\  \]

%why quotients is useful?

There are many mathematics notions can be constructed as quotient sets
of some other sets. Some are more natural to come up with,
such as integers modulo some number
$n$ is the quotient set constructed by quotienting the set of all
integers $\Z$ with the congruence relation which equates two integers
which sharing the same remainders after divided by
$n$.
The set of rational numbers $\Q$ can be defined as the set of numbers
which can be expressed as fractions, but different fractions can be
reduced to the same rational number. In other words,the set of rational numbers $\Q$ can
be constructed by quotienting the set of pairs of integers, while the
second is non-zero, with the equivalence
relation between pairs of integers which can be reduced to the same fraction
. The set of canonical forms of rational numbers are subset of the
pairs of integers. 
The set of integers $\Z$ can also been obtained from quotienting pairs of natural numbers
$\N \times \N$ which represent integers as the result of substraction
between two natural numbers within each pair. Futhermore real
numbers can be represented by cauchy sequences of
rational numbers, hence the set of real numbers $\R$ is the quotient
set of the set of cauchy sequences of rational numbers with the
equivalence relation that the distance between two sequences converges
to zero. There are more examples of quotient sets, but the main
topic of this report is quotients in Type Theory. 

\subsection{Type Theory}

The theory of types was first introduced by Russell \cite{rus:1903} as
an alternative to naive set theory. After that, mathematicians or
computer scientists have developed a number of variants of type
theory. The type theory in this discourse is the one developed by Per
Martin-L\"{o}f \cite{per:71,per:82} which is also called
intuitionistic type theory. It is based on the Curry-Howard
isomorphism between propositions and the types of its proofs such that
it can served as a formalisation of mathematics. For detailed
introduction, please refer to\cite{nor:00}. In this report, Type
Theory specially indicates \mltt{}.


Per Martin-L\"{o}f proposed both an intensional and an extensional
variants of his intuitionistic type theory. The distinction between
them is whether definitional equality is distinguished with propositional equality. In \itt{}, definitional equality exists
between two intensionally identical objects, but propositional
equality is a type which requires proof term. Any thing is
definitionally equal to itself and not to any others. Therefore
definitional equality and type checking which
depend on it \cite{alt:99} is decidable as well. However
in \ett{}, they are not distinguished so that definitional equality
and type checking become undecidable.
\todo{Why?}

Type Theory can also serve as a programming language in
which the evaluation of well-typed program always terminates
\cite{nor:90}. 
There are a few implementation based on different type theories, such as
NuPRL, Coq and Agda.
Agda is one of the most recent implementation of intensional version
of \mltt{}. As we have seen that type theory is based on the Curry-Howard
isomorphism, types are identified with propositions and programs or
terms are identified with proofs. Therefore it is not only a programming language but also a
theorem prover which allows user to verify Agda programs in
itself. Compared to other implementations, it has a bundle of good
features like pattern matching, unicode input, implicit aruguments etc
\cite{bov:09} . Since this project is based on \mltt{}, it is ideal to implement our definitions
and verify propositions in Agda.

Although Type Theory has some similarities to set theory, they are
fundamentally different. Types plays a similar role to sets, but
before we can construct elements, we must declare their
types which is different to the elements in set theory. The elements
of a set always equipped with an equivalence relation while it is not
the case for types in \itt{}. So can we have the types equipped with
equivalence relation? 

\subsection{Quotient Types}

In \itt{},  many notions from set theory and propositional logic can
be reinterpreted easily. For instances, the product of sets can be
formalised by $\Sigma-Type$ and the functions can be formalised by
$\Pi-Type$ \cite{nor:00}. However the reinterpretation of quotients in
Type Theory is still a problematic issue and quotient types are still unavailable.



Alternatively, in \itt{} we have the bases of quotients as follows,

\begin{definition}
A setoid $(A,\sim)$ is a set $A$ equipped with an equivalence relation ${\,\sim\,}\colon A \to A \to \Prop$.
\end{definition}

We can use setoids to represent quotients but they are not sets. If we
use the setoid $(\N \times \N, \sim)$ for integers, we have to
redefine set-based operations and it is unsafe \cite{aan}. Moreover to define quotients
based on this setoid, such as rational numbers, is
impossible. Therefore it is not a good solution.

Quotient types should enable users to implement quotients in
\itt{} which means the quotient types based on the setoid should have
type $\Set$. Moreover it should be universe polymorphic.


In this report, I will use the symbol $\A/sim$ for the quotient based
on a given setoid  $(A,\sim)$. To make the difference between setoids and quotient types clear, we use
an analogy, $8\div2=4$. The number 4 is the quotient because $4 \times
2 = 8$, and we cannot recover the dividend and the divisor from the
quotient $4$ or manipulate $8$ or $2$ separately. Similarly, setoids contain pairs of dividend and
divisor, but quotient sets do not include all the information from the
setoids. Futhermore one set can be the quotient sets of several different setoids. 


\itt{} has to be extended if we want to define quotient
types. Alternatively, some quotients are definable such that we can
construct it from scratch and prove it is the quotient based on a given setoid
\cite{aan}. For instances in \cite{nuo:10}, the normal form integers,
reducible rational numbers are definable and proved to construct
quotients with respect to the corresponding setoids,  such that we can
treat them as the quotient types. The quotient interfaces introduced in \cite{aan} do not
provide the access to the underlying setoids but include a set of
properties which serve as not only proofs but also tools. I will
explain the quotient interface and discuss some examples
later. The advantages of this idea are, it is feasible in current setting of
intensional Type Theory,  and we achieve some convenience
from constructing quotients. The disadvantages are, it only works for
the quotient types which are definable in \itt{} and the quotient
types and functions are constructed manually rather than derived
automatically. Hence the lifting of functions and predicates is a bit
complicated as it requires proofs that these functions or predicates respect the equivalence
relation\cite{hof:95:sm}.  Moreover, if the quotient sets are not
definable, for instance the set of real numbers $\R$, even though $\R$
can be seen as the quotient set of the Cauchy sequences of rational numbers $\Q$ and the equivalence
relation that two sequences converge to zero. 

Quotient types is not only a tool to implement quotients in
mathematics. It is based on \mltt{}, therefore some notions in Type
Theory or in programming languages are actually quotients. For example partiality monad divided by a weak
similarity ignoring finite delays \cite{aan}, propositions divided by
$\iff$  and the set of extensionally equal functions. Also
set-theoretical finite sets can be implemented as the quotient of
lists in Type Theory. 

Furthermore from any given function $f \,\colon\, A \to B$, we obtain an
equivalence relation $\sim \,\colon A \to A \to \Prop$ called $kernel$
of $f$ which is defined as $a \sim b \defi f \,a \equiv f \,b$. From
this setoid we can form a quotient.

Actually all types can be seen as quotient types. The types without
specified equivalence relation can be seen as the quotient of itself
by the trivial equivalence relation, namely the definitional equality.


\subsection{The relation between equality and quotient types}
As we have discussed before, we distinguish definitional equality with
propositional equality in \itt{}. The equivalence relation of
quotients is propositional equality which is
non-trivial despite the case that it is the same with definitional
equality. Hence the type-checking which depends on definitional
equality does not respect the equivalence relation.

There are also two different propositions expressing the equailty
between two elements in Type Theory \cite{nor:90}. Both of them
require the types of two elements are definitionally equal.
One is intensional equality written as $Id(A,a,b)$ and it is inhabited
only we have a proof showing $a$ and $b$ are definitionally equal. The
other is extensional equality written as $Eq(A,a,b)$, the elements
do not depend on an element of $A$ and the largest difference is if
$Eq(A,a,b)$ is inhabited, then $a$ converts to $b$ and vice versa. The
latter one will make type-checking undecidable so we usually use the
first one which is available in \itt{}. For example in Agda, it is
redefined as $a \equiv b$ with the type $A$ implicitly, and it has an
unique element $refl$.

Intensional equality is enough for many quotients. However if
we want quotient types corresponding to the sets of functions, the
intensional equalities of functions are not inhabited \cite{alt:99}. This
is because equated functions can have different definitions and they
are possibly to reduced to different normal forms. Hence in \itt{}
where we can form propositional equality from definitional equality,
the propositional equality of functions is not inhabited and it requires the
functional extensionality  i.e. the proposition that if two functions
are pointwise equal then they are propositional equal which is not inhabited in original
\itt{}. It can be expressed as follow,

given two types $A,\,B$, two functions $f,\,g\,\colon A \to B$,

\[Ext = \forall\, x\colon A, f x = g x \to f = g\]

However it is not an easy problem to extending \itt{}. If we just
postulate Ext, then the theory
is said to be not adequate which means it is possible to define
irreducible terms. It can be easily verified in Agda through formalising a non-canonical term
of natural number by a eliminator of intensional equality. Because of
that, the equality and type checking become undecidable. Fortunately Altenkirch investigates this
issue and gives a solution in \cite{alt:99}. He proposed an extension
of \itt{} by a universe of propositions $\Prop$. All proofs of a
the same proposition are definitionally equal, namely it is proof
irrelevant. A setoid model where types are interpreted by a type and
an equivalence relation acts as the metatheory and $\eta$-rules for
$\Pi$-types and $\Sigma$-types hold in the metatheory. The extended type
theory generated from the metatheory is decidable and adequate, Ext is
inhabited and it permits large elimination. Within this type theory,
introduction of quotient types is straightforward.
% extension

Most of the topics concerning quotient types are closely related to equality.
One of the main issues of quotient types is how to lift the functions for
base types to the ones for quotient types. Only functions respects the
equivalence relation can be lifted, even in the extensional Type
Theory as we will discussed later.

\subsection{Literature Review}

% Why I mention about this article
% More description about these articles
% in a more comprehensive way, tell a story
% compare and link between literatures
In \cite{cab}, Mendler et al. have considered building new types from a
given type by  a quotient operator $//$. Their work is based on an
implementation of extensional Type Theory, NuPRL. In NuPRL, every type
comes with its own equality relation, so the quotient operator can be
seen as a way of redefining equality in a type. But it is not all
about quotient types. They also discuss the problems arised when
defining functions on the new type.
We can illustrate this problem with a simple example. Assume the base
set is $A$ and the new equality relation is $E$, then the new
type can be represented by $A//E$. If we want to define a function $f
\,\colon\, A//E \to Bool$,  Assume we have two different elements in
A, $a, b \colon A$ such that $E\,a\,b$ but $f\,a \not= f\,b$, then it
becomes inconsistent since $E\,a\,b$ implies a converts to b, then
$f\,a = f\,b$ which contradicts with the assumption $f\,a \not=
f\,b$. Therefore even in \ett{}, the definition of functions on the
quotient types are not so simple. The functions have
to respect the equivalence relation, namely$$\forall \, a\,b\,\colon A, E\,a\,b \to f\,a = f\,b$$
then $f$ is well-defined on the new type. We call it \emph{sound} in
\cite{aan} and this project.

 After the introduction of quotient types, Mendler futher investigates
 this topics from a categorical perspective in ~\cite{men:90}. He use
 the correspondence between quotient types in \mltt{} and coequalizers
 in a category of types to define a notion called \emph{squash types}
 which is further discussed by Nogin.


Hofmann proposed  in his PhD thesis \cite{hof:phd} three models for
quotient types. The first one is a setoid model for
quotient types. In this model all types are attached with partial
equivalence relations, namely all types are setoids rather than
sets. Types without specific equivalence relation can be translated as setoids with trivial reflection equality. It is similar to NuPRL. While in \cite{hof:95:sm} he gives a simple model in which we have type dependency only at the propositional level, he also shows that extensional Type Theory is conservative over \itt {}  extended with quotient types and a universe \cite{hof:95:con}.

Nogin \cite{nog:02} considers a modular approach to axiomatizing the
same quotient types also in NuPRL. He also discusses a few complicated
problems about quotient types despite the ease of constructing new types
from base types. For example, since the the equality is
extensional, we can not recover the
witness of the equality. So he suggests to include more axioms to
conceptualise quotients. He decomposes the concept of quotient type
into several more primitive concepts such that the quotient types can
be formalised based on these concepts and can be handled much
simpler. 

Homeier \cite{hom} axiomatises quotient types in Higher Order Logic
(HOL), which is also a theorem prover. He creates a tool package to
construct quotient types as a conservative extension of HOL such that
users are able to define new types in HOL. Next he defines the
normalisation functions and proves several properties of
these. Finally he discussed the issues when quotienting on the
aggregate types such as lists and pairs.


Courtieu \cite{cou:01} shows an extension of Calculus of Inductive Constructions
with \emph{Normalised Types} which are similar to quotient types, but equivalence relations are replaced by normalisation functions. Normalised types are proper subsets of quotient types,
\[ (A, Q, \class\dotph \colon A \to Q) \Rightarrow(A, \lambda \,a \,b\to \class a = \class b)\]

However not all quotient types have normal forms. Therefore it only solves part of the problem.

Similarly, Barthe and Geunvers \cite{bar:96} also proposes \emph{congruence types}, which is also a special class of quotient types, in which the base type are inductively defined and with a set of reduction rules called the term-rewriting system. \ed{The idea behind it is the $\beta$-equivalence is replaced by a set of $\beta$-conversion rules.} The congruence types can be treated as an alternative to pattern matching introduced in \cite{coq:92}.
Hence it aims at solving problems in term rewriting systems rather than simply implementing quotient types.


\section{Aims and Objectives of the Project}

The objective of this project is to investigate and explore the ways to
implement quotient types in Type Theory, especially in intensional
one since type checking always terminates.
As we have seen quotients are quite useful in implementing
mathematical objects and programming datatypes, it will be very
helpful if we can define quotients in thoerem prover like Agda. Also
to implement some other undefinable quotients such as Real numbers, it
is an unvoidable issue to implement the idea of quotient.

The current aim is to implement some definable quotients, use the
quotient interfaces for them and study their benefits. We also need to do
research on the different definitions of quotients.

Next we need to investigate undefinable quotients such as the real
numbers and partiality monads and prove why they are undefinable. The
key different characters between definable and undefinable quotients
will be studied. 


\section{Theoretical Methods}
Part of our work is implemented in Agda, which is a dependent typed
programming language and mainly used as a theorem prover.

\todo{I have to write some other things here. Agda has been introduced
before}
It has dependent type so that we can use Curry-Howard correspondence between types and propositions. Since propositions can be represented as types, its type checker can verify the proof.

In this project the work will be proved in Agda and also verified in Agda since it is a good choice of intensional Type Theory.

\section{Results and Discussion}


\subsection{Definitions}

Currently, we have done some work on the framework of quotient.
We have submitted a paper \cite{aan} for APLAS 2011.
It is about the definable quotients and some undefinable quotients. Here we only talk about the quotient set, but it is universal polymorphic. 

To associate a setoid $(A,\sim)$ with a set Q, we have several definitions as in~\cite{aan},
I will not present it again but explain some ideas behind them.


Given a setoid $(A,\sim)$   , we denote the set of equivalence classes as $\A/sim$ and the normalisation function is $\class\dotph_{\sim} \colon A \to \A/sim $, assigning each elements to the set it is belonging to.
Hence we have

\begin{proposition}\label{prop:nf}
$\forall \, a \,, b \, \colon A, a \sim b \iff [ a ]_{\sim} = [b]_{\sim}$
\end{proposition}

And the normalisation function is surjective, hence we assume classically,



\begin{proposition}
$\forall \, e \,\colon \A/sim , \exists \, a \, \colon A , [a]_{\sim} = e$

\end{proposition}

Namely, the normalisation function is split,


\begin{proposition}
$\exists \, s \, \colon \A/sim \to A,\, \class\dotph_{\sim}  \circ s = 1_{\A/sim}$
\end{proposition}

\


Since then 

$$\class\dotph_{\sim}  \circ (s \circ \class\dotph_{\sim}) = \class\dotph_{\sim} \circ 1_{\A/sim} $$

And with Proposition~\ref{prop:nf}, we can prove that

\begin{proposition}\label{prop:stable}
$\forall \, a \,  \colon A,  (s \circ \, \class\dotph_{\sim}) \, a   \sim a$ 
\end{proposition}


Some of them are only classically true. However, we worked in intensional Type Theory which is constructive. What we do is to  associate a given set Q to the setoid or the quotient set. Given a function $\class\dotph\colon A \to Q$,

 \[\sound\colon  (a,b : A) \to a\sim b \to [a] = [b]\]

is a property which means that from the images of the elements from the same equivalence class are identical, namely $\class\dotph$ respects the equivalence relation. It is also equivalent to say that there is a naming function, $na \, \colon \A/sim  \to Q $ , such that the following diagram commutes,
\[\xymatrix{
A\ar[r]^{\class\dotph_{\sim}}\ar[dr]_{\class\dotph} & \A/sim \ar[d]^{na}\\
&Q
}\]

And $na$ can be constructed as $\class\dotph \, \circ s$. We can prove this diagram is commute as,

\[ na \circ  \class\dotph_{\sim} = \class\dotph \circ s  \circ \class\dotph_{\sim}
\]

Apply  Proposition~\ref{prop:stable} and  Proposition~\ref{prop:nf}, we know,
\[ \forall \,a \, \colon A, (na \circ  \class\dotph_{\sim}) \, a = (\class\dotph \circ s  \circ \class\dotph_{\sim}) \, a = \class\dotph \circ ((s  \circ \class\dotph_{\sim}) \, a) = \class\dotph \, a     
\]

Extensionally, we proved that the diagram commute.


However, with this property, we cannot confirm $Q$ is the required quotient set, we only construct a prequotient.
To complete a quotient, we require one eliminator
for every
$B\colon Q\to\Set$,
\begin{align*}
 \qelim_B\colon &(f\colon (a:A) \to B\,\class a) \\
        {\to}\, &((p:a\sim b) \to f\,a \simeq_{\sound\,p}f\,b)\\
        {\to}\, &((q:Q) \to B\,q)
 \end{align*}
such that $\qelimbeta\colon \qelim_B f \,p\,\class a\equiv f a$.

With this eliminator we can lift a function which takes in $a \,\colon A$ but the result is dependent on the $[a] \, \colon Q$  and identifies more than $\class\dotph$, namely for the elements in the same equivalence class by $\class\dotph$ , the result produced by $f$ is the same. Combining with this function, 

However this is not a exact quotient, since it is unnecessary for $na$ function to assign one \emph{name} ($q \,\colon Q$) to each equivalence class ($e \,\colon \A/sim$). It is very inefficient to define a too general quotient. Therefore we need a property to make a quotient exact,

\[\exact :\forall \,a \, b : A\,,\,  \class a = \class b \to a \sim b \]

equivalently, we have the property that $na$ is injective,

\begin{align*}
\forall \,e \, f : \A/sim \,,\, &na \,e = na \, f \Rightarrow
(\class\dotph \, \circ s) \, e = (\class\dotph \, \circ s) \,f \\
\Rightarrow &\class{s \, e} =  \class{s \, f} \Rightarrow s \, e \sim s \, f \Rightarrow [s \, e]_{\sim} = [s \, f]_{\sim} \Rightarrow e = f
\end{align*}

The alternative definition of quotient with non-dependent eliminator introduced in \cite{hof:phd}, and consists of,



\begin{align*}
\lift_B &\colon (f\colon A \to B) \to (\forall a,b\cdot a\sim b \to f\,a
\equiv f\,b) \to (Q \to B) \\
\liftbeta &\colon \lift_B f \,p\,\class a\equiv f a
\end{align*}



 for any $B\colon\Set,$ which can lift a function $f$ which respects the equivalence relation and the following diagram commute with respect to lift-$\beta$,

\[\xymatrix{
A\ar[r]^{\class\dotph}\ar[dr]_{f} & Q \ar[d]^{lift_{B} \, f \, p}\\
&B
}\]




In this definition we also need an introduction principle if $B$ in the dependent eliminator is a predicate on $Q$,

\[\qind_{P} \colon((a: A)\to P \,\class a)\to ((q : Q)\to P\,q)\]

The quotient with dependent eliminator and the one with non-dependent eliminator are actually equivalent. We prove this by formalise one by another in Agda. It is quite trivial to generate the non-dependent version from dependent version since $\lift_B$ and $\qind_{P}$ are both special cases of the dependent eliminator. However to recover dependent eliminator, it is a little complicated. We need a function $indep$ to transform the dependent $a \, \colon A \to B \,\class a $ into the non-dependent $A \to \Sigma \,Q \,B$ which is defined as $indep \, f \,a \mapsto \class a \,, f \,a$. Then we can use non-dependent eliminator to lift $indep \,f$ and the projection of the second component is the same as dependent function. You can check the detailed Agda proof in the Appendix.

When the quotient type is definable and we want the target type $Q$ is just the quotient type, which means

\[  Q \cong \A/sim \]

Therefore, to constructively define isomorphism in intensional Type Theory, we not only need $na$, but also the inverse function of it.
So the definable quotients in \cite{aan} is the prequotient with

\begin{align*}
\emb &: Q \to A\\
\complete &: (a : A) \to \emb {\class a} \sim a\\
\stable &: (q:Q) \to \class{\emb\,q} \equiv q\\
\end{align*}

$\emb$ is the embedding function which choose one representative element for each equivalence class. Hence the following diagram needs to commute,

\[ \xymatrix{
&A\ar@<-0.5ex>[dl]^{\class\dotph}\ar@<0.5ex>[dr]_{\class\dotph_{\sim}} \\
Q \ar@<1.5ex>[ur]^{\emb} \ar@<-0.5ex>[rr]_{na^{-1}}&&\ar@<-0.5ex>[ll]_{na}  \A/sim \ar@<-1.5ex>[ul]_{s}
}\]


Such that $ na^{-1} = \class\dotph_{\sim} \circ \emb$ is the inverse function of $na$. 



\begin{align*}
&na^{-1} \circ na = 1_{\A/sim} \Rightarrow \class\dotph_{\sim} \circ \emb \circ \class\dotph \circ s = 1_{\A/sim} \\
&\Rightarrow \forall a \colon A ,  a \sim (s \circ \,
\class\dotph_{\sim}) \, a \sim (s \circ 1_{\A/sim} \circ
\class\dotph_{\sim})  \, a \\
&\sim (s \circ (\class\dotph_{\sim} \circ \emb \circ \class\dotph \circ s) \circ \class\dotph_{\sim}) \, a \sim \emb \,\class{a} 
\end{align*}

So we need this property called completeness which ensures the correctness of emb.
Also,

\[ na \circ na^{-1} =1 _{Q} \Rightarrow\class\dotph \circ s \circ \class\dotph_{\sim} \circ \emb = \class\dotph  _{} \circ \emb = 1 _{Q}  \Rightarrow \forall \,q\, \colon Q, \class{\emb \,q} = q  \]

is needed called the stable property which ensures
$\class\dotph$ is surjective, Hence it is \emph{normalisation} function and the $Q$ is the quotient type without redundance.

With these two properties, we can conclude that $ \class\dotph_{\sim} \circ \emb $ is the inverse function of $na$ , hence $Q$ is isomorphic to $\A/sim$.
We can use it as the quotient type.

In category theory, coequalizers are the generalization of quotients.
We assume

$R = \Sigma a , b : A , a \sim b$  are the pairs of equivalent elements in $A$

$\pi_{0}\,,\pi_{1} \colon R \to A $ are the projection functions for $R$

$\class\dotph \colon A \to Q$ satisfies that $\sound \colon \forall\,a,b \colon A, a \sim b \to \class a = \class b$


\[\xymatrix{
R\ar@<0.5ex>[r]^{\pi_0}\ar@<-0.5ex>[r]_{\pi_1}& A\ar[r]^{\class\dotph}\ar[dr]_{f} & Q\ar@{-->}[d]^{\dlift f}\\
&&X
}\]


Since 
\begin{enumerate}
\item$(Q \,, \class\dotph)$ fulfils that $\class\dotph\ \circ \pi_0 = \class\dotph \circ \pi_1$, we can acquire this from applying the $\pi_{0}\, r ,\pi_{1}\,r$ for all $r $ to sound.
\item Given any $(X, f \colon A \to X)$, there exists a unique $\hat{f}$, such that the diagram above commutes. From the definition of quotients, we can use the eliminator to lift $f$ , namely $\hat{f} = \lift f,  $ and the $\beta$-law simply implies the diagram commutes. The uniqueness can be proved as follows

\[\forall \,g \, \colon Q \to X, g \circ \class\dotph = f \Rightarrow \forall \,a \,\colon A, g \,\class a = f a = \lift f \,q \,\class a  \Rightarrow g = \lift f \,q\]

\end{enumerate}

These two parts proved from quotients
exactly define a coequalizer. Also we can prove $\class\dotph$ is an epimorphism

\begin{align*}
&\forall\, g_1,g_2 : Q \to Z, g_1 \circ \class\dotph = g_2 \circ
\class\dotph\\
&\Rightarrow  \forall \,q \,\colon Q,  g_{1} \,q = \lift \, (g_1 \circ \class\dotph) \, q = \lift \, (g_2 \circ \class\dotph) \, q = g_2\, q \Rightarrow g_1 = g_2
\end{align*}

Also the exact quotient is equivalent to the exact coequalizer,

\[\xymatrix{
R\pullbackcorner\ar[r]^{\pi_2}\ar[d]_{\pi_1} & A\ar[d]^{\class\dotph} \\
A\ar[r]_{\class\dotph} & Q
}\]

\begin{enumerate}

\item This diagram commutes

$(\forall \,r\, \colon R, \pi_1 \, r \sim \pi_2 \, r \Rightarrow\class{\pi_1 \,r} = \class{\pi_2 \, r}) \Rightarrow \class\dotph \circ \pi_1 = \class\dotph\circ \pi_2$


\item 
\begin{align*}
&\forall (Z , z_1 \colon Z \to A, z_2 \colon Z \to A), \,
\class{\dotph} \circ z_1 = \class\dotph \circ z_2 \\
&\Rightarrow ( \exists \,u : Z \to R, \pi_1 \circ u = z_1 \wedge  \pi_2
\circ u = z \\
&\wedge \,\forall \,u' \colon Z \to R, \pi_1 \circ u' = z_1 \wedge
\pi_2 \circ u' = z_2 \\
&\Rightarrow u = u') 
\end{align*}

We  can construct the unique function as $u \,x \mapsto z_1 \,x \,, z_2\, x$, but we need to prove $z_1 \,x\sim z_2 \,x$ from exact property of quotient, 

$\class{\dotph} \circ z_1 = \class\dotph \circ z_2 \Rightarrow \forall \,x\, \colon Z, (\class{z_1\,x}=\class{z_2 \,x} \Rightarrow z_{1} \,x \sim z_2 \, x) $

$u$ is the function which makes the diagram commutes,

$$\forall \,x\,\colon Z, (\pi_1 \circ u) \, x = z_1 \,x$$

$$\forall \,x\,\colon Z, (\pi_2 \circ u) \, x = z_2 \,x$$

$u$ is unique,


\begin{align*}
&\forall \,u' \colon Z \to R, \pi_1 \circ u' = z_1 \wedge  \pi_2 \circ u'  = z_2\\ 
&\Rightarrow \forall \,x\,\colon Z, u' \,x = z_1 \,x\,,z_2\,x=u\,x \Rightarrow u' = u
\end{align*}

\end{enumerate}


\section{Examples}
We have already define the basic requirements to create quotients in intensional Type Theory, I will then present some concrete examples in \cite{nuo:10} to illustrate these ideas. They are implemented in Agda. 

\subsection{Integers}


All the result of subtraction between natural numbers are integers. Therefore it is naturally to define a pair of
natural numbers to represent integers. Hence the base type of the quotient is

$$\Z_0=\N \times \N$$

Mathematically, for any two pairs of natural numbers $(n_1, n_2)$ and $(n_3, n_4)$, 

$$ n_1 - n_2 = n_3 - n_4\iff n_1 + n_4 = n_3 + n_2$$
since the pair of integers represent the same result of subtraction, they define the same integer. Hence we can define an equivalence relation for $\N \times \N$ as

\[ (n_1, n_2) \sim (n_3, n_4) = n_1 + n_4 \equiv n_3 + n_2 
 \]


Here $\equiv$ is the propositional equality. so that the $\Z_0/\sim$ is the quotient integer.
Integer is also definable in intensional Type Theory as $\N+\N$ where we define two constructors

$ (n \colon \N) \Rightarrow + \,n \colon\Z$

$ (n \colon \N) \Rightarrow -\suc n \colon\Z$


Firstly to construct the prequotient based on the setoid $(\Z_0,\sim)$, we need to define the $\class\dotph \colon \Z_0 \to \Z$ as

\begin{align*}
\class{(a,0)} &= +\,a\\
\class{(0,\suc b)} &= -\suc b\\
\class{(\suc a,\suc b)} &= \class{(a,b)}\\
\end{align*}

and prove \emph{sound}. Then we define emb function and prove all the required properties for definable quotients


\begin{align*}
\emb \,(+ a) &= (a,0)\\
\emb (-\suc b) &= (0,b+1)\\
\end{align*}

We have done these in Agda \cite{nuo:10}. The quotients here are not just something relate the setoid with the quotient type, we use lift functions to define functions trivially and use properties to transform the proof term for the setoid to the quotient type. For instance, the addition of the setoid is defined as

$$(a,b){+_0}(a', b')= (a+a',b+b')$$

We can then define use the eliminator to lift the operator, or just define a lift function for binary operators,

$$ \lift \,* \,z_1 \,z_2 = \class{\emb \,z\textcolor[rgb]{0,0,0}{text}_1 \,*\,\emb \,z_2}$$

or a more general lift function for n-ary operators,



\begin{align*}
\lift' \,0 \,op &= \class{op}\\
\lift' \,(\suc n) \,op &= \lambda \,x \to \lift' n \,(op \,(\emb x))\\
\end{align*}
Then we don't need to define the addition of integers by several cases.

$$+ = \lift +_0$$

If we lift the operators in this way, we have to prove it respects the equivalence relation later. The main benefits from the quotients arise in proving properties. Because for normal form integers, we have two cases for each argument. The number of cases will expand exponentially if we can not combine cases. The proof of distributivity of multiplication over addition is so cumbersome
that it is hard to write and read. However, we could lift the proof for the setoid integers so that we could prove it in one case. This convenience is due to the simplicity of the proof for the setoid $(\Z_0,\sim)$. 

\subsection{Rational numbers}

The quotients of rational numbers is more natural to understand and the normalisation function is also commonly used in regular mathematics. Generally we can use a pair of integers to represent rational numbers. However, it is complicated to exclude 0 in the denominator. For simplicity, we just use one integer for \emph{numerator} and one natural number for \emph{denominator-1} to represent a rational number to avoid the invalid cases from construction. 

$$\Q_0 = \Z \times \N$$



The equivalence relation is

$$(n_1, d_1) \sim (n_2, d_2) = n_1 \times (d_2 + 1) \equiv n_2 \times (d_1 + 1) $$

The normal form of rational numbers can just be defined by adding a condition that the numerator and denominator are coprime.

$$\Q = \Sigma (n \colon \Z)(d \colon \N), \coprime \,n \,(d +1)$$

Since there are a set of \emph{gcd} (great common divisor) functions in Agda, it is possible to define the normalisation functions (See Appendix).
emb function can be trivially defined by forgetting coprime proof.

\subsection{Real numbers as cauchy sequences}

We can represent real numbers as cauchy sequences of rational numbers \cite{bis:85}.

$$\R_{0} = \set{s : \N\to\Q \mid \forall\varepsilon :\Q,\varepsilon>0\to\exists m:\N, \forall i:\N, i>m\to |s\,i - s\, m|<\varepsilon}$$

And we define the equivalence relation of two sequences by the proposition that their pointwise difference converges to 0.

$$r \sim s = \forall\varepsilon :\Q,\varepsilon>0\to\exists m:\N, \forall i:\N, i>m\to |r\,i - s\,i|<\varepsilon$$

Then $\R_0 /\sim$ is the quotient set of real numbers. However it is undefinable because real numbers have no normal forms.
Therefore we cannot use the definable quotient interface for it. The undefinability is proved in \cite{aan}.
Nevertheless, we could easily embedding rational numbers as the cauchy
sequences of all the same rational numbers. But for irrational
numbers, there is no such an uniform way to generate a sequences.


\section{Conclusion}

Currently we investigate the possible quotient definitions in \itt{} and present some examples and benefits from the definable quotients. For definable quotients, it provides an alternative choice to define functions or prove propositions which reuses things and could be simpler in most cases. However, to solve the problems arose from undefinable quotients, a new type former may be unavoidable.

\todo{future extension.}

One of the future work is to investigate the conservativity of \itt{}
and quotient types over \ett{}. Another one is to extend the work in
\cite{alt:99} and find an approach to extend \itt{} without losing
nice features, termination and decidable type checking. 

%future : something on equality, complete preliminary work in Agda
%Extend without losing nice features of itt, termination, deciable type checking
%axiomatising quotients types, adding rules, na 
% possible quotions, talk to Thorsten
% 
% pay attention to the connection,the flow of ideas throughout the article.
% one thing in one paragraph.

If we axiomize quotient types in \itt, then every type can be seen as quotient type, when the default equivalence relation is just \ed{reflection equality}.
\newpage
\bibliography{quotients}
\bibliographystyle{plain}

\end{document}
