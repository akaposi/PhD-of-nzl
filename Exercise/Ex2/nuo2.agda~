module nuo2 wheredata Id (A : Set) : A → A → Set where  refl : (a : A) → Id A a a-- what is the difference to the library?-- data _≡_ {a} {A : Set a} (x : A) : A → Set a where--   refl : x ≡ x-- 1. explicit type-- what happens if we add ext as a constructor for Id?J : (A : Set)(P : (a b : A) → Id A a b → Set)    → ((a : A) → P a a (refl a))    → (a b : A)(p : Id A a b) → P a b pJ A P m .b b (refl .b) = m b-- now we only use J, not pattern matching!id : {A : Set} → A → Aid = λ x → xsubst : (A : Set)(a b : A)(p : Id A a b)        (B : A → Set) → B a → B bsubst A a b p B = J A (λ a' b' _ → B a' → B b') (λ _ → id) a b p-- only using J--subst A .b b (refl .b) B x = xsubst' : (A : Set)(B : A → Set)(a b : A)(p : Id A a b)         → B a → B bsubst' A B = J A (λ a' b' _ → B a' → B b') (λ _ → id)sym : (A : Set) → (a b : A) → Id A a b → Id A b asym A a b p = subst A a b p (λ b' → Id A b' a) (refl a)trans : (A : Set) → (a b c : A) → Id A a b → Id A b c → Id A a ctrans A a b c p q = subst A b a (sym A a b p) (λ x → Id A x c) qresp : (A B : Set) → (f : A → B) → (a b : A) → Id A a b → Id B (f a) (f b)resp A B f a b p = J A (λ a' b' _ → Id B (f a') (f b')) (λ a' → refl (f a')) a b ppostulate  ext : (A : Set)(B : A → Set)(f g : (x : A) → B x)        → ((x : A) → Id (B x) (f x) (g x))         → Id ((x : A) → B x) f gidUni : (A : Set)(a : A)(p : Id A a a) → Id (Id A a a) p (refl a)idUni A a p = (J A (λ a' b' → {!!}) (λ a' → lem2 A a') a a p) p--  J A (λ a' b' p' → Id (Id A a' b') p' (subst A a' b' p' (λ x → Id A a' {!x!}) (refl a'))) (λ a' → refl (refl a')) a a p-- unprovable using Just J (identity elimination rule)-- try to prove from J idUni A a (refl .a) = refl (refl a)-- Implement subst, assume idUni and prove J.-- TTI = implement subst, postulate ext and idUni.-- encode the example in the beginning section 2 in Agda-- try to read the rest and come up with some questions.-- read section 3, what is the open problem?subst Bool true (eq l₀ l₀) (sym Bool (eq l₀ l₀) true (eq-correct-1 l₀ l₀ (refl l₀))) (λ e → Id (Data l₀) (if' (λ x → Data l₀) e ((λ x → subst Loc l₀ l₀ (eq-correct-2 l₀ l₀ x) Data d) (λ x → s l₀)) d) {!!}(eq-correct-2 l₀ l₀ x) Data d