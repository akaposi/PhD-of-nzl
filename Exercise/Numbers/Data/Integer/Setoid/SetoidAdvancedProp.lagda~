\begin{code}

module Integer.SetoidInteger.SetoidAdvancedProp where


open import Data.Function using (_$_ ; _∘_)
open import Data.Nat hiding (_≤_ ; decTotalOrder) renaming (_≟_ to _ℕ≟_ ;  _+_ to _ℕ+_ ; _*_ to _ℕ*_ ; _≤?_ to _ℕ≤?_)
open import Data.Product

open import Integer.SetoidInteger.SetoidDef renaming (suc to zsuc)
open import Integer.SetoidInteger.SetoidBasicProp
open import Integer.SetoidInteger.SetoidCommutativeRing

open import Relation.Binary.Core
open import NatPropertiesExtra as ℕ hiding (+l-cancel; +r-cancel; integrity′; integrity)
open import Symbols

\end{code}

b) the proof of integrity of ℤ₀
if a ≠ 0 and a * m = a * n then m = n

\begin{code}

i-lem : ∀ {p q m} → p ∼ q → p * m ∼ q * m
i-lem p∼q = *-cong p∼q zrefl

integrity : ∀ {m n} a → (p : isNotZero a) → a * m ∼ a * n → m ∼ n
integrity {_} {_} (zero , zero) prf a*≡ with prf refl
... | ()

integrity {m+ , m- } {n+ , n- } (zero , suc a-) _ a*≡ =
  ℕ.integrity a- $
  ℤ₀i-lem₂ m+ n- a- >≡<
  ⟨ a*≡ ⟩ >≡<
  ⟨ ℤ₀i-lem₂ n+ m- a- ⟩

integrity {m+ , m- } {n+ , n- } (suc a+ , zero) _ a*≡ = 
  ℕ.integrity a+ $
  ⟨ ℤ₀i-lem₁ m+ n- a+ ⟩ >≡<
  a*≡ >≡<
  ℤ₀i-lem₁ n+ m- a+

integrity (suc a+ , suc a-) prf a*≡ = 
  integrity (a+ , a-) (λ x → prf (suc ⋆ x))
  (i-lem ⟨ suc-move a+ a- ⟩ >∼< 
  a*≡ >∼< 
  i-lem (suc-move a+ a-))


+l-cancel : ∀ {m n} x → x + m ∼ x + n → m ∼ n
+l-cancel {m+ , m- } {n+ , n- } (x+ , x-) eqt = ℕ.+l-cancel (x+ ℕ+ x-) $
  exchange₃ x+ x- m+ n- >≡< eqt >≡<
  exchange₃ x+ n+ x- m-

solve0 : ∀ m {n} → (p : isNotZero m) → m * n ∼ (0 , 0) → n ∼ (0 , 0)
solve0 m p eqt = integrity m p (eqt >∼< zsym (z*0=0 m))