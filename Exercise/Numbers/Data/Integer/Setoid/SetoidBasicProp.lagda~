\begin{code}
module Integer.SetoidInteger.SetoidBasicProp where

open import Integer.SetoidInteger.SetoidDef renaming (suc to zsuc)
open import Data.Function using (_$_ ; _∘_)
open import Data.Nat hiding (_≤_ ; decTotalOrder) renaming (_≟_ to _ℕ≟_ ;  _+_ to _ℕ+_ ; _*_ to _ℕ*_ ; _≤?_ to _ℕ≤?_)
open import Data.Nat.Properties
open import Data.Product
open import Relation.Binary
open import Relation.Binary.Core
open import Relation.Binary.PropositionalEquality using (sym ; trans ; cong₂)
open import Relation.Binary.PropositionalEquality.Core using (resp₂) renaming (isEquivalence to isEquivalence₂)
open import NatPropertiesExtra renaming (refl′ to  ℕrefl′ ; +l-cancel′ to ℕ+l-cancel′ ; integrity′ to ℕintegrity′ ; integrity to ℕintegrity)

infixl 1 _>∼<_

\end{code}

7. Some trivial and useful properties

\end{code}

b) - is inverse to itself

\begin{code}

-inv : ∀ {x} → x ∼ - - x
-inv {x+ , x-} = refl

\end{code}

c) add '-' to both sides  of a equation is still valid
2 = 1 + 1 → - 2 = - ( 1 + 1 )

\begin{code}

-cong : ∀ {x y} → x ∼ y → - x ∼ - y
-cong {a , b} {c , d} eqt = ℕ.+-comm b c >≡< ⟨ eqt ⟩ >≡< ℕ.+-comm a d

\end{code}

d) move the '-' out of multiplication
(- 1) * 3 = - (1 * 3)
helpful lemma for proving the properties of ℚ₀

\begin{code}

-out : ∀ x y → - x * y ∼ - (x * y)
-out (a , b) (c , d) = (ℕ.+-comm (b ℕ* c) (a ℕ* d)) +=
                         (ℕ.+-comm (a ℕ* c) (b ℕ* d))


\end{code}

1. The '∼' is equivalence

a) reflexivity: ∀ a → a ∼ a

\begin{code}

zrefl : Reflexive _∼_
zrefl {x+ , x- } = refl

\end{code}

b) symmetry: ∀ a b → a ∼ b → b ∼ a

\begin{code}

zsym : Symmetric _∼_
zsym {x+ , x- } {y+ , y- } = sym

\end{code}

c) transitivity:  ∀ a b c → a ∼ b /\ b ∼ c → a ∼ c

\begin{code}

_>∼<_ : Transitive _∼_
_>∼<_ { x+ , x- } { y+ , y- } { z+ , z- } x=y y=z = cancel-+-left (y+ ℕ+ y-) $
  exchange y+ y- x+ z- >≡< (y=z += x=y) >≡< exchange₂ z+ y- y+ x-

\end{code}

d) Combine these 3 propertiese we can prove that '∼' is equivalence

\begin{code}

isEquivalence : IsEquivalence _∼_
isEquivalence = record
  { refl  = zrefl
  ; sym   = zsym
  ; trans = _>∼<_
  }

\end{code}

2. The equivalence relation is decidable

\begin{code}

infix 2 _≟_

_≟_   : Decidable _∼_
(x+ , x-) ≟ (y+ , y-) = (x+ ℕ+ y-) ℕ≟ (y+ ℕ+ x-)

\end{code}

Then we should prove that the equivalence relation is decidable which means if we know what two setoid integers, we could decide whether they are equal or not.
As the equivalence relation is defined based on the operations on the natural numbers, we can prove the decidability using the decidability of the equivalence relation of the natural numbers.


3. (ℤ₀, ∼) is a setoid

\begin{code}

ℤ-Setoid : Setoid _ _
ℤ-Setoid = record
  { Carrier       = ℤ₀
  ; _≈_           = _∼_
  ; isEquivalence = isEquivalence
  }

\end{code}

4. (ℤ₀, ≡, ∼) is preorder

a) identity : if a ≡ b then a ∼ b
 
\begin{code}

id₂      :  _≡_ ⇒ _∼_
id₂ refl = zrefl

\end{code}

c) constitution

the isEquivalence₂ is the proof of equivalence for ≡

\begin{code}

isPreorder : IsPreorder _≡_ _∼_
isPreorder =  record
  { isEquivalence = isEquivalence₂
  ; reflexive     = id₂
  ; trans         = _>∼<_
  ; ∼-resp-≈      = resp₂ _∼_
  }

preorder : Preorder _ _ _
preorder = record
  { Carrier    = ℤ₀
  ; _≈_        = _≡_
  ; _∼_        = _∼_
  ; isPreorder = isPreorder
  }
\end{code}

5. The properties for the sign functions

\begin{code}

sign◃ : ∀ n → sign n ◃ p n ∼ n
sign◃  (zero , zero)   = refl
sign◃ (zero , suc n)  = refl
sign◃ (suc m , zero)  = refl
sign◃ (suc m , suc n) = (sign◃ (m , n)) >∼< ⟨ suc-move m n ⟩

◃-cong-lem : ∀ {m n} → sign m ≡ sign n → p m ≡ p n → sign m ◃ p m ≡ sign n ◃ p n
◃-cong-lem sign-≡ abs-≡ = cong₂ _◃_ sign-≡ abs-≡

◃-cong : ∀ {m n} → sign m ≡ sign n → p m ≡ p n → m ∼ n
◃-cong {m} {n} sign-≡ abs-≡ =
  (zsym (sign◃ m)) >∼< (id₂ (◃-cong-lem sign-≡ abs-≡)) >∼< sign◃ n

\end{code}

8. The proof : ℕ*ℤ = i n * (x+ , x-) = n ℕ* x+ , n ℕ* x- 

\begin{code}

eqℕ*ℤ : ∀ n x → n ℕ*ℤ₀ x ∼ n ℕ*ℤ₀' x
eqℕ*ℤ n (x+ , x-) = (n ℕ* x+) +⋆ n+0≡n  >≡< ⟨ n+0≡n {n ℕ* x+} ⟩ ⋆+ (n ℕ* x-)

\end{code}

9. (ℤ₀ ,  ∼ , ≤ ) is decidable total order

a) ≤ to is decidable

\begin{code}

_≤?_ : Decidable _≤_
(x+ , x-) ≤? (y+ , y-) = (x+ ℕ+ y-) ℕ≤? (y+ ℕ+ x-)

\end{code}

b) (ℤ₀, ∼, ≤) is preorder
 
\begin{code}

≤isPreorder : IsPreorder _∼_ _≤_
≤isPreorder =  record
  { isEquivalence = isEquivalence
  ; reflexive     = refl′
  ; trans         = trans′
  ; ∼-resp-≈      = ≤resp
  }
  where
\end{code}

reflexivity if a = b then a ≤ b

\begin{code}

  refl′ : _∼_ ⇒ _≤_
  refl′ {a , b} {c , d} = ℕO.reflexive

\end{code}

transitivity of ≤
a ≤ b → b ≤ c → a ≤ c

\begin{code}

  trans′ : Transitive _≤_
  trans′ {a , b} {c , d} {e , f} a+d≤c+b c+f≤e+d =
    ℕ+l-cancel′ (c ℕ+ d) $
    r-≤resp (exchange₂ a d c f) $
    l-≤resp (exchange c b e d) $
    a+d≤c+b +≤ c+f≤e+d

\end{code}

≤ Respects₂ ∼
a = b → c ≤ a → c ≤ b
b = c → b ≤ a → c ≤ a

\begin{code}

  ≤resp : _≤_ Respects₂ _∼_
  ≤resp = (λ a∼b c≤a → trans′ c≤a (refl′ a∼b)) ,
          (λ b∼c b≤a → trans′ (refl′ (zsym b∼c)) b≤a)

\end{code}

c) (ℤ₀, ∼, ≤) is decidable total order

\begin{code}

decTotalOrder : DecTotalOrder _ _ _
decTotalOrder = record
  { Carrier         = ℤ₀
  ; _≈_             = _∼_
  ; _≤_             = _≤_
  ; isDecTotalOrder = record
      { isTotalOrder = record
          { isPartialOrder = record
              { isPreorder = ≤isPreorder
              ; antisym  = antisym
              }
          ; total = total
          }
      ; _≟_  = _≟_
      ; _≤?_ = _≤?_
      }
  }
  where

\end{code}

antisummetric
a ≤ b → b ≤ a → a = b

\begin{code}

  antisym : Antisymmetric _∼_ _≤_
  antisym {a , b} {c , d} = ℕO.antisym

\end{code}

total
∀ a b → a ≤ b ∨ b ≤ a 

\begin{code}

  total : Total _≤_
  total (a , b) (c , d) = ℕO.total (a ℕ+ d) (c ℕ+ b)

\end{code}

10. + preserves ≤
a ≤ b → c ≤ d → a + c ≤ b + d

\begin{code}

+cong′ : ∀ {a b c d} → a ≤ b → c ≤ d → a + c ≤ b + d
+cong′ {a1 , a2} {b1 , b2} {c1 , c2} {d1 , d2} a≤b c≤d = 
  r-≤resp (exchange₃ a1 b2 c1 d2) $ 
  l-≤resp (exchange₃ b1 a2 d1 c2) $
  a≤b +≤ c≤d

\end{code}

11. + cancellation for ≤
a + b ≤ a + c → b ≤ c

\begin{code}

+l-cancel′ : ∀ a {b c} → a + b ≤ a + c → b ≤ c
+l-cancel′ (a1 , a2) {b1 , b2} {c1 , c2} = 
  ℕ+l-cancel′ (a1 ℕ+ a2) ∘
  r-≤resp (exchange₃ a1 b1 a2 c2) ∘
  l-≤resp (exchange₃ a1 c1 a2 b2)

integrity′ : ∀ {a b} c → (suc c , 0) * a ≤ (suc c , 0) * b → a ≤ b
integrity′ {a1 , a2} {b1 , b2} c = 
  ℕintegrity′ c ∘ 
  r-≤resp (ℤ₀i-lem₁ a1 b2 c) ∘
  l-≤resp (ℤ₀i-lem₁ b1 a2 c)

\end{code}