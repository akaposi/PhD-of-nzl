\chapter{Definable Quotients and Others}

\todo{Before 18th-Dec-2013}

Sometimes types defined by quotienting other
types can also be defined inductively instead, for example the integers,
the rational numbers etc. It seems meaningless
to define them as quotient types, but is it really the case?
We are going to exploit the benefits from the definable quotient structures.
However there are some good
properties if we relate them with the base types and equivalence
relation, for example we can lift functions and them properties from base types to
quotient types. Moreover, if the base types are simpler to manipulate,
it is worthwhile using the base type to define functions and reasoning
and then lifting them. We can achieve more convenience by manipulating base types and then lifting the operators and propositions according to the relation between quotient types and base types.

In this Chapter we will show this using one of the examples, the set
of integers. Some of the work is is conducted by Thorsten Altenkirch,
Thomas Anberr\'{e}e and the author together, and summarised in \cite{aan} .


\subsection{Integers}

From the usual symbols to represent integers, we can easily figure out
one inductive definition for integers,

\begin{code}
\\
%
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{zero} \AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
%
\\
\end{code}

However we face a trade-off: three different representation for zero or
to use code $+0$ for number $+1$. Usually the principle is to not
losing canonicity because it requires unnecessary checking for whether
some functions respect the equivalence or not. Therefore, the second
choice makes more sense and we refine it a bit as:

\begin{code}
\\
%
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{zero} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
%
\\
\>\<\end{code}

This is better, but in practice it is expected to have more cases if
we use pattern matching. Every time we use pattern matching, a case will be
split into three. This becomes worse and worse when we have mutiple integer
arguments and we have to do case analysis on all of them. A simple
refinement is combining the first two constructors:

\begin{code}
\\
%
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+\_} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
%
\\
\>\<\end{code}

This is the most proper version we decided to use for integers. It is
inductively defined and is readable because it is just an
intepretation of the usual symbols for integers in regular mathematics.

Usually the reason of inventing integers is the lack of symbols to
represent the results of subtraction between two
natural numbers. Integers are used to represent these results, and
vice versa,
every integer can be represented as a pair of natural numbers and the
choice is not unique.
For example, from the equation $1 - 4 = - 3$, it is clear that the
integer $- 3$ can be represented the pair $(1,4)$. 
Therefore we can use the paired natural numbers as an alternative
definition for integers.

$$\Z_0=\N \times \N$$

However since there are different pairs for one integer, we have to
quotient it with an equivalence relation. For any two pairs of natural
numbers $(n_1, n_2)$ and $(n_3, n_4)$, we know they represent the same
integer if

$$ n_1 - n_2 = n_3 - n_4$$

Technically, this does not work because the subtraction defined for natural
numbers only returns zero if the pair is for negative number. We only
need to do some small modifications:

$$ n_1 + n_4 = n_3 + n_2$$

This helps us define a relation but it is not enough. This is an
equation in mathamtics, but in Type Theory we have to prove that it is an
equivalence relation, namely, it is reflexive, symmetric and transitive.

Combining the carrier (the pair of natural numbers), the equivalence
relation and its proof, we have a setoid.

\begin{code}
\\
\>\AgdaFunction{ℤ-Setoid} \AgdaSymbol{:} \AgdaRecord{Setoid}\<%
\\
\>\AgdaFunction{ℤ-Setoid} \AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{\{} \AgdaField{Carrier} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaFunction{ℤ₀}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{;} \AgdaField{\_≈\_} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaPostulate{\_∼\_}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{;} \AgdaField{isEquivalence} \AgdaSymbol{=} \AgdaPostulate{\_∼\_isEquivalence}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{\}}\<%
\\
\end{code}

Since integers is definable as we discussed before, they can
be seen as the normal forms of the equivalent classes. The normalisation
function can be defined as follows:
 
\begin{code}
\\
%
\\
\>\AgdaFunction{[\_]} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{[} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{0} \AgdaFunction{]} \<[18]%
\>[18]\AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaBound{m}\<%
\\
\>\AgdaFunction{[} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{]} \<[18]%
\>[18]\AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaBound{n}\<%
\\
\>\AgdaFunction{[} \AgdaInductiveConstructor{suc} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{]} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{n} \AgdaFunction{]}\<%
\\
%
\\
\end{code}

The function should be proved well-defined on the setoid, namely it
has to respect the equivalence relation. We call it soundness here. 
It is not trivial but easy to observe that the function is
sound\footnote{the formal proof can be found in appendix (we cheat a
  bit by defining embedding function to make it simpler)}.

A setoid and a function respects this equivalence (not necessary to be
a normalisation function) constitute a prequotient.

\begin{definition}
Prequotient.

\noindent
Given a setoid $(A,\sim)$,  a \emph{prequotient} $(Q,[\_],\sound)$ over that setoid consists in
\begin{enumerate}
\item \label{enum:Q} a set $Q$,
\item \label{enum:box}a function $[\_]: A \to Q$,
\item \label{enum:sound} a proof \emph{sound} that  the function $[\_]$ is compatible with the relation $\sim$,
that is \[\sound\colon (a,b : A) \to a\sim b \to [a] = [b],\]
\end{enumerate}


Prequotient only includes the formalisation rules and introduction
rules. To complete a \emph{quotient}, we also need the elimination rule added into such a prequotient

\begin{enumerate}
\setcounter{enumi}{3}
\item \label{enum:elim}
for any $B: Q\to\Set$, an eliminator
 \begin{align*}
 \qelim_B\,\,:\,\,\,&(f\colon (a:A) \to B\,\class a) \\
        {\to}\, &((p:a\sim b) \to f\,a \simeq_{\sound\,p}f\,b)\\
        {\to}\, &((q:Q) \to B\,q)
 \end{align*}
such that $\qelimbeta : \qelim_B\,f \,p\,\class a\equiv f\,a$.

\end{enumerate}

This eliminator is also called dependent lifting function because it
actually lifts a function which is well-defined on the setoid to a
function defined on the quotient type. The result type is also
dependent on the quotient type. There is an equivalent definition
given by Martin Hofmann
which has a non-dependent eliminator with an induction principle
instead.

\[\lift\colon (f\colon A \to B) \to (\forall a,b\cdot a\sim b \to f\,a
\equiv f\,b) \to (Q \to B)\]

Suppose $B$ is a predicate, 
\[\qind \colon((a: A)\to B \,\class a)\to ((q : Q)\to B\,q)\]

However, it is oberservable that given any non-empty set $Q$, all
constant functions fit in this definition. Any element of $Q$ has to
be mapped from at most one equivalence class of the setoid
$(A,\sim)$. This property is called \emph{exact} here 

\begin{enumerate}
\setcounter{enumi}{4}
\item $exact :(\forall a,b : A) \to  \class a \equiv \class b \to a \sim b$.

\end{enumerate}
\end{definition}

The quotient is exact if exactly one equivalence class corresponds to
an element of $Q$.

We already know that the integer is definable and it is plausible to
find a representative in each equivalence classes. Since
we treat elements of $Q$ as the name for the equivalence classes, the
selection function can be defined as an embedding function from  the
quotient type $Q$ to base type $A$. This is an alternative and more
flexible way to eliminate the quotient type $Q$ and if a
prequotient $(Q, \class{\dotph}, \sound)$ on a setoid $(A,\sim)$ has
an embedding function which is specified as
\begin{align*}
\emb &: Q \to A\\
\complete &: (a : A) \to \emb {\class a} \sim a\\
\stable &: (q:Q) \to \class{\emb\,q} \equiv q.\\
\end{align*}

Then it is a \emph{definable quotient}. Composing the ``normalisation'' function $\class\dotph$ with the
embedding function, we obtain the real normalisation function. A
definable quotient is an \emph{exact} quotient which is proved in \cite{aan}.



\paragraph{Operations}

For a definable quotient, we can lift an operation by mixing the
normalisation and embedding functions. For example, given an unary
operator 

\begin{code}
\\
\>\AgdaFunction{lift₁} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{op} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{lift₁} \AgdaBound{op} \AgdaSymbol{=} \AgdaFunction{[\_]} \AgdaFunction{∘} \AgdaBound{op} \AgdaFunction{∘} \AgdaFunction{⌜\_⌝}\<%
\\
\end{code}

To lift binary or n-ary operators, we only need to apply the operator
to the representative for each "equivalence class" and "normalise" the
result so that it becomes a function defined on the set of
"equivalence classes".

But there is a unavoidable problem: not all operations defined on
$\Z_0$ is defind on the setoid, namely respect the equivalence
relation. Therefore it is reasonable to verify if the function is
well-defined on the setoid:

$$a \sim b → op \, a \sim op \, b$$

We will show how to define the addition for the quotient
integers. Given two numbers $(a_1 , b_1)$ and $(a_2 , b_2)$ We
only need to add them pair-wisely together, and it can be verified
easily because we know that 

$(a_1 - b_1) + (a_2 - b_2) = (a_1 + a_2) - (b_1) - (b_2)$

The verification is not necessary here but should be important in
other cases.

\begin{code}
\\
\>\AgdaFunction{\_+\_} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{x+} \AgdaInductiveConstructor{,} \AgdaBound{x-}\AgdaSymbol{)} \AgdaFunction{+} \AgdaSymbol{(}\AgdaBound{y+} \AgdaInductiveConstructor{,} \AgdaBound{y-}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{x+} \AgdaFunction{ℕ+} \AgdaBound{y+}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{x-} \AgdaFunction{ℕ+} \AgdaBound{y-}\AgdaSymbol{)}\<%
\\
\end{code}


\paragraph{Properties}

We can also define the ring of $\Z$. It contains a lot of properties
to prove which are seemed as axioms in classic mathematics. In
constructive mathematics, the only axioms for integers are the
constructors and the elimination rules.

As what we have menetioned, even though the definition of integers
only has two constructors, it gradually increase the difficulty of
proving when doing case analyses on more and more integers. One
example is the proving of distributivity.

\paragraph{Comparison}

\todo{The advantage of use Quotient algebraic structure: the proving of distributivity}

If we try to prove distributivity for integers using the normal
definition, we have to do case analyses on all the three integers,
namely there are eight cases to prove in total. However, if we prove
the laws for quotient integers, it is much simpler since there is
only one case to prove.



However, if we prove it for the quotient integers, it is much
easier. In fact, it is in generally automatically provable. Since the
equality of any two quotient integers is just the equality of two
natural numbers, after some transformation. 
To prove the distributivity, what we need to do is to use the semiring
solver for natural numbers. $\AgdaFunction{DistributesOverˡ}$ means
that the distributivity of the first operators over the second one.
\todo{explain what is a ring solver?}


\begin{code}
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \<[9]%
\>[9]\AgdaFunction{\_*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{solve} \AgdaNumber{6} \<[40]%
\>[40]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{f} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{:=}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{e} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)))} \AgdaInductiveConstructor{refl} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\<%
\\
\end{code}


There are some drawbacks of this method. First, we have to explicitly
write the equations which means it is not elegant enough. What we
expect is something like the "ring" tactic in Coq which can solve any
equations automatically. This can be achieved by "reflection" which is
feature that returns the type of the goal as some terms such that we
can process it and using it in ring solver. There is already some work
done by van der Walt \cite{van2012reflection}.

Another disadvantage of this method is the type verification of the
terms automatically derived requires more computations than the terms
we manually construct. As long as we use the distributivity in later
proofs, it may heavily slow the type checking. Therefore although
it is very convenient to use the ring solver to prove any proposition for the quotient
integers, we still prove all the common properties for the commutative
ring of the integers. Luckily it is still much simpler than the ones
for the normal integers.


\subsection{Rational numbers}

The quotient of rational numbers is better known than the previous
quotient. We usually write two integers $m$ and $n$ ($n$ is not zero) in
fractional form $\frac{m}{n}$ to represent a rational number. Alternatively we
can use an integer and a positive natural number such that it is
simpler to exclude 0 in the denominator. Two fractions are equal if
they are reduced to the same irreducible term. If the numerator and
denominator of a fraction are coprime, it is said to be an irreducible
fraction. Based on this observation, it is naturally to form a definable quotient, where the base type is 

$$\Q_0 = \Z \times \N$$

The integer is \emph{numerator} and the natural number is \emph{denominator-1}. This approach avoids invalid fractions from construction. 

In Agda, to make the terms more meaningful we define it as

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℚ₀} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[-1]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_/suc\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{n} \AgdaSymbol{:} \AgdaDatatype{ℤ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{d} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\end{code}

In mathematics, to judge the equality of two fractions, it is easier to conduct the following conversion,

$$ \frac{a}{b} = \frac{c}{d} \iff a \times d = c \times b $$

Therefore the equivalence relation can be defined as,

\begin{code}
\\
\>\AgdaFunction{\_*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaNumber{0}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaInductiveConstructor{suc} \AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{\_∼\_} \<[35]%
\>[35]\AgdaSymbol{:} \AgdaFunction{Rel} \AgdaDatatype{ℚ₀} \AgdaSymbol{\_}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{n1} \AgdaInductiveConstructor{/suc} \AgdaBound{d1}\AgdaSymbol{)} \AgdaFunction{∼} \AgdaSymbol{(}\AgdaBound{n2} \AgdaInductiveConstructor{/suc} \AgdaBound{d2}\AgdaSymbol{)} \AgdaSymbol{=} \<[31]%
\>[31]\AgdaBound{n1} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d2} \AgdaDatatype{≡} \AgdaBound{n2} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d1}\<%
\\
\end{code}

The normal form of rational numbers, namely the quotient type in this quotient is the set of irreducible fractions. We only need to add a restriction that the numerator and denominator is coprime,

$$\Q = \Sigma (n \colon \Z). \Sigma (d \colon \N). \mathsf{coprime} \,n \,(d +1)$$

It can be defined as follows which is available in standard library,

\begin{code}
\\
\>\AgdaKeyword{record} \AgdaRecord{ℚ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{numerator} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{denominator-1} \AgdaSymbol{:} \AgdaDatatype{ℕ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{isCoprime} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{C.coprime?} \AgdaFunction{∣} \AgdaBound{numerator} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{denominator-1}\AgdaSymbol{))}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaFunction{denominator-1}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{:} \AgdaFunction{Coprime} \AgdaFunction{numerator} \AgdaFunction{denominator}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{=} \AgdaFunction{toWitness} \AgdaFunction{isCoprime}\<%
\\
\end{code}

The normalisation function is an implementation of the reducing
process. But first we need to  the |gcd| function which calculates the greatest common
divisor can help us reduce the fraction and give us the proof of
coprime. First we need to define the conversion from the results of GCD
to normal rational numbers,

\begin{code}
\\
\>\AgdaFunction{GCD′→ℚ} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{di} \AgdaSymbol{→} \AgdaBound{y} \AgdaFunction{≢} \AgdaNumber{0} \AgdaSymbol{→} \AgdaDatatype{C.GCD′} \AgdaBound{x} \AgdaBound{y} \AgdaBound{di} \AgdaSymbol{→} \AgdaRecord{ℚ}\<%
\\
\>\AgdaFunction{GCD′→ℚ} \AgdaSymbol{.(}\AgdaBound{q₁} \AgdaPrimitive{ℕ*} \AgdaBound{di}\AgdaSymbol{)} \AgdaSymbol{.(}\AgdaBound{q₂} \AgdaPrimitive{ℕ*} \AgdaBound{di}\AgdaSymbol{)} \AgdaBound{di} \AgdaBound{neo} \AgdaSymbol{(}\AgdaInductiveConstructor{C.gcd-*} \AgdaBound{q₁} \AgdaBound{q₂} \AgdaBound{c}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaKeyword{record} \AgdaSymbol{\{} \AgdaField{numerator} \AgdaSymbol{=} \AgdaFunction{numr}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{;} \AgdaField{denominator-1} \AgdaSymbol{=} \AgdaFunction{pred} \AgdaBound{q₂}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{;} \AgdaField{isCoprime} \AgdaSymbol{=} \AgdaFunction{iscoprime} \AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{numr} \AgdaSymbol{=} \AgdaInductiveConstructor{ℤ.+\_} \AgdaBound{q₁}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{deno} \AgdaSymbol{=} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{pred} \AgdaBound{q₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{numr≡q1} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaFunction{numr} \AgdaFunction{∣} \AgdaDatatype{≡} \AgdaBound{q₁}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{numr≡q1} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{lzero} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≡} \AgdaNumber{0} \AgdaSymbol{→} \AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{y} \AgdaDatatype{≡} \AgdaNumber{0}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{lzero} \AgdaSymbol{.}\AgdaNumber{0} \AgdaBound{y} \AgdaInductiveConstructor{refl} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{q2≢0} \AgdaSymbol{:} \AgdaBound{q₂} \AgdaFunction{≢} \AgdaNumber{0}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{q2≢0} \AgdaBound{qe} \AgdaSymbol{=} \AgdaBound{neo} \AgdaSymbol{(}\AgdaFunction{lzero} \AgdaBound{q₂} \AgdaBound{di} \AgdaBound{qe}\AgdaSymbol{)}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{invsuc} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{n} \AgdaSymbol{→} \AgdaBound{n} \AgdaFunction{≢} \AgdaNumber{0} \AgdaSymbol{→} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{pred} \AgdaBound{n}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaBound{n}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{invsuc} \AgdaInductiveConstructor{zero} \AgdaBound{nz} \AgdaKeyword{with} \AgdaBound{nz} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{...} \AgdaSymbol{|} \AgdaSymbol{()}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{invsuc} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaBound{nz} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{deno≡q2} \AgdaSymbol{:} \AgdaFunction{deno} \AgdaDatatype{≡} \AgdaBound{q₂}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{deno≡q2} \AgdaSymbol{=} \AgdaFunction{invsuc} \AgdaBound{q₂} \AgdaFunction{q2≢0}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{transCop} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{c} \AgdaDatatype{≡} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{d} \AgdaDatatype{≡} \AgdaBound{b} \AgdaSymbol{→} \AgdaFunction{C.Coprime} \AgdaBound{a} \AgdaBound{b} \AgdaSymbol{→} \AgdaFunction{C.Coprime} \AgdaBound{c} \AgdaBound{d}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{transCop} \AgdaInductiveConstructor{refl} \AgdaInductiveConstructor{refl} \AgdaBound{c} \AgdaSymbol{=} \AgdaBound{c}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{copnd} \AgdaSymbol{:} \AgdaFunction{C.Coprime} \AgdaFunction{∣} \AgdaFunction{numr} \AgdaFunction{∣} \AgdaFunction{deno}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{copnd} \AgdaSymbol{=} \AgdaFunction{transCop} \AgdaFunction{numr≡q1} \AgdaFunction{deno≡q2} \AgdaBound{c}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{a} \AgdaBound{b} \AgdaSymbol{→} \AgdaRecord{GCD} \AgdaBound{a} \AgdaBound{b} \AgdaNumber{1} \AgdaSymbol{→} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{C.coprime?} \AgdaBound{a} \AgdaBound{b}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaBound{a} \AgdaBound{b}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaKeyword{with} \AgdaFunction{GCD.unique} \AgdaBound{gcd1} \AgdaBound{y}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaSymbol{|} \AgdaSymbol{()}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{suc} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaSymbol{=} \AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaKeyword{with} \AgdaFunction{GCD.unique} \AgdaBound{gcd1} \AgdaBound{y}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaSymbol{|} \AgdaSymbol{()}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{iscoprime} \AgdaSymbol{:} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{C.coprime?} \AgdaFunction{∣} \AgdaFunction{numr} \AgdaFunction{∣} \AgdaFunction{deno}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{iscoprime} \AgdaSymbol{=} \AgdaFunction{witProp} \AgdaFunction{∣} \AgdaFunction{numr} \AgdaFunction{∣} \AgdaFunction{deno} \AgdaSymbol{(}\AgdaFunction{C.coprime-gcd} \AgdaFunction{copnd}\AgdaSymbol{)}\<%
\\
\end{code}

To normalise a fractional, we split it into 3 cases with respect to
the numerator. The idea is to calculate the "gcd'' and then use the
above function to get the normalised rational number.

\begin{code}
\\
\>\AgdaFunction{[\_]} \AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaRecord{ℚ}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{0}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{=} \AgdaInductiveConstructor{ℤ.+\_} \AgdaNumber{0} \AgdaFunction{÷} \AgdaNumber{1}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaSymbol{=} \AgdaFunction{GCD′→ℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaBound{di} \AgdaSymbol{(λ} \AgdaSymbol{())} \AgdaSymbol{(}\AgdaFunction{C.gcd-gcd′} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\end{code}


The embedding function is simple. We only need to forget the coprime proof in the normal form,

\begin{code}
\\
\>\AgdaFunction{⌜\_⌝} \AgdaSymbol{:} \AgdaRecord{ℚ} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\>\AgdaFunction{⌜} \AgdaBound{x} \AgdaFunction{⌝} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{ℤcon} \AgdaSymbol{(}\AgdaFunction{ℚ.numerator} \AgdaBound{x}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaSymbol{(}\AgdaFunction{ℚ.denominator-1} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\end{code} 

Similarly, we are able to construct the setoid, the prequotient and
then the definable quotient of rational numbers. We can benefit from
the ease of defining operators and proving theorems on setoids while
still using the normal form of rational numbers, the lifted operators
and properties which are safer.

The same approach works here as well. Since we can easily embed the natural numbers into integers, the
equations of the quotient rational numbers are degraded to equations of the
integers.  The commutative ring of integers also enable us to prove
all properties of rational numbers automatically.


\subsection{Real numbers}

The previous quotient types are all definable in \itt{}, so we can
construct the definable quotients for them. However, there are some
types undefinable in \itt{}. The set of real numbers $\R$ has been proved to be undefinable in \cite{aan}.

We have several choices to represent real numbers. We choose Cauchy
sequences of rational numbers to represent real numbers \cite{bis:85}.

$$\R_{0} = \set{s : \N\to\Q \mid \forall\varepsilon
  :\Q,\varepsilon>0\to\exists m:\N, \forall i:\N, i>m\to \vert  s_i -
  s_m \vert  <\varepsilon}$$

It is implementable in Type Theory, but there is a problem of the
choice of type of the second part of the cauchy sequence, namely the property
that it is a cauchy sequence. Do we distinguish the same sequences
with different proofs? Logically speaking we should not. It means that
we need to truncate it to proposition but we will lose the important
tool to guess what the real number is. To avoid this problem, we could
use an alternative equivalent definition which is a subset of $\R_{0}$:

$$\R_0' = \set{f: \N\to\Q \mid \forall k
  :\N,\forall m , n > k, \to \vert  f_m -
  f_n \vert  < \frac{1}{k}}$$

With the definition, the condition part is propositional and we can
guess the number by applying any number k to the sequence and we know
the interval where it should be located.

Different cauchy sequences can represent the same number. Therefore an equivalence relation\footnote{
The Agda version is in Appendix} is expected. In mathematics two Cauchy sequences $\R_0$ are said to be
equal if their pointwise difference converges to zero,

$$r \sim s = \forall\varepsilon :\Q,\varepsilon>0\to\exists m:\N,
\forall i:\N, i>m\to \vert  r_i - s_i \vert <\varepsilon$$

\subsection{Non-normalizability of Cauchy Sequences}

To prove that it is impossible to give a full definable quotient
structure of real numbers with the setoid of cauchy sequences, we
could show it by proving that it is impossible to define a
normalisation function for the cauchy sequences.

\begin{definition}\label{def:nor}
We say that a quotient structure $\qset{A}$ is definable via a
normalisation, if we have a normalisation function
 \begin{equation}
  nf : A \to A
 \end{equation}
 with the property that it respects $\sim$
\begin{equation}
 p : \prd{c_1,c_2 : A} c_1 \sim c_2 \to nf(c_1) = nf(c_2).
\end{equation}
such that
 \begin{equation}
 q : \prd{c : A}  {nf(c)} \sim c.
 \end{equation}
\end{definition}

It is equivalent to say that we have a definable quotient structure in
the sense of \cite{aan}, because we can form the set of equivalence
classes as

\begin{equation*}
Q \defeq \Sigma_{c : \R_0} nf(c) = c
\end{equation*}

where the second part is propositional, and the "normalisation''
function can be defined as

\begin{equation*}
[c] \defeq nf(c) , p(q)
\end{equation*}

and the embedding function is just the first projection. The properties can be verified
easily.

In the other way around, the true normalisation function is just

\begin{equation*}
n \defeq emb \circ [\_]
\end{equation*}

and the properties are holded as well.


We have made an attempt in the original version of our \cite{aan}
draft, but there is something important problem pointed out by Martin Escardo. Laterly, Nicolai
Kraus suggests to fix the proof by proving it as a meta-theoretical
property. We will show an adaption of his proof here.

\paragraph{Some preliminaries}

In fact the proof is mainly conducted using topological tools. The
following definitions are helpful for someone who are not so familiar
with topological concepts.


\begin{definition}
Metric space. In mathematics, a metric space is a set where a notion
of distance (called a metric) between elements of the set is defined.

A metric space is an ordered pair $(M , d)$ where M is a set and d is a metric on M:
\begin{enumerate}
\item M is a set,
\item and $d : M \times M \rightarrow \R$ s.t.
\item $d (x , y) = 0 \iff x = y$
\item $d(x,y)=d(y,x)$
\item $d(x,y)+d(y,z) \ge d(x,z)$ 
\end{enumerate}
\end{definition}

We usually define a standard topological structure for discrete types.

\begin{itemize}

\item $(\bool , h)$ where 
$h(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\item $(\N , d)$ where 
$d(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\item $(\Q , e)$ where 
$e(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\end{itemize}

We use a slightly different definition of cauchy sequences of rational
numbers here:

\begin{definition}
 We call a function $f : \PN \to \Q$\footnote{we
   use $\PN$ instead of $\N$ because $n$ must be positive in $\frac 1 n$} a \emph{Cauchy Sequence} if it satisfies
 \begin{equation}
  \iscauchy (f) \defeq \fa{n}{\PN} \fa{m} {\N+} m > n \to |f(n) - f(m)| < \frac 1 n. \label{eq:prop-property-short}
 \end{equation}
 The type of Cauchy Sequences is thus
 \begin{equation*}
  \R_0 \defeq \sm{f : \PN \to \Q} \iscauchy (f).
 \end{equation*}
\end{definition}

And the standard metric space for the sequences $\PN \rightarrow \Q $
is defined by the distance function

\begin{equation}
g(f_1,f_2) = 2^{-\mathsf{inf}\{k \in \N \; | \; f_1(k) \not= f_2(k)\}}
\end{equation}

Among all these standard metric spaces, It is a folklore that all
definable functions are continous.

\begin{theorem}\label{defcon}
All definable functions are continous.
\end{theorem}

Let us introduce the following auxiliary definition:
\begin{definition}
 For a sequence $f : \N \to \Q$, we say that $f$ is \emph{Cauchy with
   factor $k$}, written as $\iscauchy_k$, for some $k \in \Q$, $k > 0$, if
 \begin{equation}
  \iscauchy_k(f) \; \defeq \; \fapairs{n}{m}{\N} m > n \to |f(n) - f(m)| < \frac 1 {k \cdot n}. \label{eq:cauchy-aux}
 \end{equation}
 The usual Cauchy condition $\iscauchy$ is therefore ``Cauchy with factor $1$''.
\end{definition}

\begin{remark} If we claim a function $f$ is defined on $\R_0$ that
  respects $\sim$, it means that we have a proof
\begin{equation}
 p : \prd{c_1,c_2 : \R_0} c_1 \sim c_2 \to f(c_1) = f(c_2).
\end{equation}

\end{remark}

Now we have enough tools to prove the following proposition.

\begin{proposition} \label{prop:main}
 \textbf{"$\R_0 / \sim$" is connected.} It means that any continuous function $f$ 
 \begin{equation}
  f : \R_0 \to \bool
 \end{equation} that respects $\sim$ is constant. We prove that it is impossible to find $c_1, c_2:
\R_0$ such that $f(c_1) \not= f(c_2)$ meta-theoretically, instead of
deriving a proof term of this in type theory.

The definable of function implies that it is a continous function \ref{defcon}
between the standard metric spaces for $\R_0$ and $\bool$\footnote{The
  metric of $\R$ comes from the first component. Technically, if
  $\R_0$ is defined by \ref{eq:usedbytxa}, this would not make it a
  metric space (as the distance between non-equal elements could be
  $0$); however, this would not matter, and for our definition, there
  is no problem anyway.}.

\end{proposition}



\begin{proof}

The general idea is to interpret our definition in classical mathematics,
assume we have a non-constant function and deduce a
contradiction.
 
Consider the ``naive'' set model (with ``classical standard mathematics'' as meta-theory). This clearly works if we are in a minimalisitic type theory with $\Pi$, $\Sigma$, $\mathsf{W}$, $=$, $\mathbb N$; however, if we restrict ourselves to the types in the lowest universe of homotopy type theory (which is enough), it also works for HoTT.
 We use $\tometa \cdot$ as an interpreation function; 
 for example, we write $\R$ for the field of real numbers which can be defined as $\tometa {\R_0} / \tometa{\sim}$. 
 By abuse of notation, we write $\tometa {\R_0}$ for the set of Cauchy sequences in the model that fulfill the Cauchy condition, without the actual proof thereof. This is justified as this property is propositional. 
 
 For readability, we use the symbol $=$ for equality in the theory as well in the model, and we do not use the semantic brackets for natural numbers such as $2$ or $4$.
 In the model, we use $\clim \cdot : \tometa {\R_0} \to \R$ as the
 function that gives us the limit of a Cauchy sequence (Not all
 functions in the ``naive'' set model have to be continuous).
 Thus, for $r : \R_0$, we write $\climeta r \in \R$ for the real number it represents.

Assume $f, p$ are given. We prove that $\tometa f : \tometa {\R_0} \to \tometa \bool$ is constant in the model, which implies the statement of Proposition \ref{prop:main}.

Thus, assume $\tometa f$ is non-constant,  there are $c_1, c_2 : \tometa {\R_0}$ with $\tometa f(c_1) \not= \tometa f(c_2)$. 

 Define
 \begin{align}
  m_1 & \defeq \mathsf{sup} \{\clim d \in \R \; | \; d \in \tometa {\R_0}, \clim d \leq \mathsf{max}(\clim{c_1}, \clim{c_2}), \tometa f(d) = \tometa \btrue \}\\
  m_2 & \defeq \mathsf{sup} \{\clim d \in \R \; | \; d \in \tometa {\R_0}, \clim d \leq \mathsf{max}(\clim{c_1}, \clim{c_2}), \tometa f(d) = \tometa \bfalse \}
 \end{align}
 (note that one of these two necessarily has to be $\clim{c_1}$ or $\clim{c_2}$, whichever is bigger).
 Set $m \defeq \mathsf{min}(m_1,m_2)$, and we can observe that in
 \emph{every} neighborhood $U$ of $m$, given any $t$,
we can always find another point $x \in U$ such that $x = \clim e$
(for some $e$) with $\tometa f(e) \not= \tometa f(t)$.
 
 Let $c \in \tometa {\R_0}$ be a Cauchy sequence such that $\clim c$ is equal to $m$. 
 We may assume that $c$ satisfies the condition
 $\tometa{\iscauchy_5}$.\footnote{the factor 5 is chosen due to the
   need of a later proof.} 
%  The slight difference ($\frac 1 n$ is replaced by $\frac 1 {4n}$) will be important.
%  Without loss of generality, assume $\tometa{f}(c) = \tometa \btrue$. % not needed.
 
 As $f$ (and thereby $\tometa f$) is continuous (remember the metric
 spaces), there exists $n_0 \in \tometa {\N}$ such that for any Cauchy
 sequence $c' \in \tometa {\R_0}$, if the first $n_0$ sequence
 elements of $c'$ coincide with those of $c$ (namely the distance
 $g(c, c') = 2^{-\mathsf{inf}\{k \in \N \; | \; c(k) \not= c'(k)\}}
 \leq 2^{-{n_0}}$ ), then $\tometa f(c') = \tometa f(c)$. 
 Write $U \subset \tometa {\R_0}$ for the set of Cauchy sequences which fulfill this property, and $\clim U \defeq \{\clim d \; | \; d \in U\}$ for the set of reals that $U$ corresponds to.
 
 We claim that $\clim U$ is a neighborhood of $m$. 
 More precisely, we prove: 
 The interval $I \defeq (m - \frac 1 {2n_0} , m+ \frac 1 {2n_0})$ is contained in $\clim U$.
 Let $x \in \R$ be in $I$. There is a sequence $t : \tometa {\N \to \Q}$ such that $\tometa {\iscauchy_{5n_0}}(t)$ and $\clim t = x$. 
 Let us now ``concatenate'' the first $n_0$ elements of the sequence $c$ with $t$, that is, define
 \begin{align}
  &g : \tometa{\N \to \Q} \\
  &g (n) = \begin{cases}
            c(n) & \text{if $n \leq n_0$} \\
            t(n-n_0) & \text{else}.
           \end{cases}
 \end{align}

 Observe that $g$ is also a Cauchy sequence, i.e. $\tometa \iscauchy(g)$: The only thing that needs to be checked is whether the two ``parts'' of $g$ work well together. Let $0 < n \leq n_0$ and $m > n_0$ be two natural numbers. We need to show that
 \begin{equation}
  |g(n) - g(m)| < \frac 1 n.
 \end{equation}
 Calculate
 \begin{align}
  & \quad |g(n) - g(m)| \\
  = & \quad|c(n) - t(m - n_0)| \\
  = & \quad |c(n) - \clim c + \clim c - \clim t + \clim t - t(m - n_0)| \\
  \leq & \quad | c(n) - \clim c | + |\clim c - \clim t| + |\clim t - t(m - n_0)| \\
  \leq &  \quad  \frac{1}{5n}  + \frac{1}{2n_0} + \frac{1}{5n_0 \cdot (m-n_0)} \\
  \leq &  \quad  \frac{1}{5n}  + \frac{1}{2n} + \frac{1}{5n_0} \\
  <  & \quad \frac 1 n.
 \end{align}

From the continuity property of $f$ and the definition of
$g$ we know that $\tometa f (g) = \tometa f(c)$. Clearly, $\clim g =
\clim t = x \in I$. Therefore \emph{all}  $s \in \tometa {\R_0}$ with $\clim
s \in I$, we can use the "concatenation'' approach to find a $g$
satisfies $s \, \tometa \sim \,  g$ (namely $\clim s = \clim g$), and by the condition that $f$ (and
thereby $\tometa f$) repects $\sim$, we can conclude that $\tometa f
(s) = \tometa f (g) = \tometa f(c)$.
 
%  It is easy to see that $g$ is a Cauchy sequence, i.e. $\tometa \iscauchy(g)$,\footnote{Of course, this is why we needed $\iscauchy_5$ instead of $\iscauchy$ earlier. The $5$ is somewhat arbitrary (todo: think about what is actually needed).} with $\clim g = x$. Further, the first $n_0$ elements of $g$ coincide with those of $c$, and thus, $\tometa f(g) = \tometa f(c)$.
 
However, as we have seen, in \emph{every} neighborhood of $m$, and thus in particular in $(m - \frac 1 {2n_0} , m+ \frac 1 {2n_0})$, there is an $x$ such that $x = \clim e$ (for some $e$) with $\tometa f(e) \not= \tometa f(c)$, in contradiction to the just established statement.
\end{proof}

The proposition that "$\R_0 / \sim$ is connected'' implies the
following corollary:

\begin{corollary}\label{dis:con}
Any continous function from $\R_0$ to any discrete type that respects $\sim$ is constant.
\end{corollary}



\begin{theorem}
Any continuous endofunction $f$ on $\R_0$ that respects $\sim$ which means
 \begin{equation}
  p : \prd{c_1,c_2 : \R_0} c_1 \sim c_2 \to f(c_1) = f(c_2).
 \end{equation}
 is constant (in the sense of corollary \ref{dis:con}).
\end{theorem}
\begin{proof}

Assume we have $f,p$ as required. 

To prove $f$ is constant, it is enough to show that the sequence part is
constant because the proof part is propositional. Again, by slight abuse of notation, we write $\tometa f : \tometa{\R_0} \to \tometa {\R_0}$, omitting the proof part of $f$.
 

Given a postive natural number $n : \tometa \PN$, we have a projection
function $\pi_{n} : \tometa{ \R_0} \to \tometa \Q$. Define a function
$h_n : \tometa {\R_0} \to \tometa \Q$ as

 \begin{equation*}
 h_n(c) \defeq \pi_{n} \circ f
 \end{equation*}

By corollary \ref{dis:con} we know that $h_n$ is constant, hence $f$
is constant everywhere, it is enough to show that $f$ is constant.


% By Proposition \ref{prop:main} we know it is a constant function and
% we can observe that $h (\mathsf 0) = true$, can we infer that $\forall
% c : \tometa {\R_0}, \tometa f c = \tometa f (\mathsf 0)$


%  We only need to show that $\pi_1 \circ f$ (the actual sequence) is constant as the proof of being a Cauchy sequence is propositional.\footnote{Even if $\iscauchy$ is not a propositional predicate (as in \ref{eq:usedbytxa}), it will still be true that $m$ is constant. This is simply because $\sim$ is defined only in terms of the actual sequence part.} Again, by slight abuse of notation, we write $\tometa f : \tometa{\R_0} \to \tometa {\R_0}$, omitting the proof part of $f$.
 
%  Given $c : \tometa {\R_0}$, we want to show $\tometa f (c) = \tometa f (\mathsf 0)$, where $\mathsf 0$ is the sequence that is constantly $0$. 
%  To do so, it is enough to show that, for a given $k : \tometa \N$, we have $\tometa{f}(c)(k) = \tometa{f}(\mathsf 0)(k)$. 
%  If this was not true, we would have a function $\tometa \R \to \tometa \bool$, defined by 
%  \begin{equation*}
%   \lambda c . \mathsf{isEquval }\left(\tometa f (c)(k)\right) \left(\tometa f (\mathsf 0)(k)\right)
%  \end{equation*}
% that is not constant, contradicting Proposition \ref{prop:main}.
\end{proof}


\begin{corollary}
 There is no definable normalisation function on $\R_0$ in the sense
 of \ref{def:nor}
\end{corollary}

\begin{corollary}
 $\R_0 / \sim$ is not definable in the sense of \cite{aan}.
\end{corollary}


However, it doesn't imply that we cannot define the set of real numbers in minimalisitic type theory with $\Pi, \Sigma, \mathsf{W}, =,
\N$. The meaning of definability of real numbers is still not clear enough. To make it more precise, we define
it as whether there is a type $A$ in $\mathsf{TT}$ (minimalisitic type
theory) such that its embedding $\tometa A$ in $\mathsf{TT} + \mathsf{Q}$ (type theory
extended with quotient types) is isomorphic to $\tometa \R_0
/ \tometa \sim$ (where it is a valid type). We conjecture that it is still not
definable.

\begin{proof}
Assume the set of real numbers is definable, we have a type $A$ and
its embedding in $\mathsf{TT} + \mathsf{Q}$  is $\tometa A$. It also
gives us a normalisation function and a representative function
between $\tometa \R_0$ and $\tometa A$.

\end{proof}

\subsection{Cauchy completeness of the cauchy reals}

Whether our definition of cauchy sequence is cauchy complete? In other
words, is there a representative cauchy sequence as a limit for every
equivalence class? The answer is no.

In the HoTT book \cite{hott}, an alternative definition is used
instead which is called cauchy approximation. Because every
approximation has been proven to have a limit, it is cauchy complete.
The definition uses the higher inductive types which will be discussed
in later Chapter \ref{HITs}.

\subsection{Multisets}

\begin{definition}

Multiset. A multiset (or bag) is a set without the constraint that there is no repetitive elements.

\end{definition}

A set is just a special case of multiset when the
\emph{multiplicity}(the number of the occurences) of every element is one.
Multisets (or bags) are believed to be used in ancient times, but it
is only 
studied by mathematicans from 20th century.

In set theory, a multiset is defined as a pair of a set $A$ and a
occurences counting function $m : A \rightarrow \N$.

However in type theory, the set-theoretical "Set" is not available so
we choose another way to define multisets. A multiset can be
represented by some list which accepts multiple occurences like
multiset but is ordered which is a redundant property. In another
word, permutations of a list should represent the same multiset. That
is enough to define an equivalence relation,

Given two lists of type $A$, $p \, q : List A$,

$$ p \sim q = \Sigma f g : \N \rightarrow \N, \forall n, p_n = q_{f \, n}
\wedge q_n = p_{g \, n} $$
