\chapter{Definable Quotients}
\label{dq}

\todo{1. Distributivity 2. Rational numbers 3. other definable quotients}

Quotient types may be necessary for defining some types in \itt, but
it is not always the case. The set of integers and the set of rational
numbers can be defined without quotients types, but there are more
properties revealed if we view them as quotients. 
However there are some good
properties if we relate them with the base types and equivalence
relation, for example we can lift functions and their properties from base types to
quotient types. Moreover, if the base types are simpler to manipulate,
it is worthwhile using the base type to define functions and reasoning
and then lifting them. We can achieve more convenience by manipulating base types and then lifting the operators and propositions according to the relation between quotient types and base types. The main things we
are going to discuss in this chapter is called  definable quotient
structures which does not require quotient types
to be added into the \itt.

In this Chapter we will show this using one of the examples, the set
of integers. Some of the work is is conducted by Thorsten Altenkirch,
Thomas Anberr\'{e}e and the author together, and summarised in \cite{aan} .


\section{Integers}

From the usual symbols to represent integers, we can easily figure out
one inductive definition for integers,

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{zero} \AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\end{code}

However we face a trade-off: three different representation for zero or
to use code $+0$ for number $+1$. Usually the principle is to not
losing canonicity because it requires unnecessary checking for whether
some functions respect the equivalence or not. Therefore, the second
choice makes more sense and we refine it a bit as:

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{zero} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\<\end{code}

This is better, but in practice it is expected to have more cases if
we use pattern matching. Every time we use pattern matching, a case will be
split into three. This becomes worse and worse when we have mutiple integer
arguments and we have to do case analysis on all of them. A simple
refinement is combining the first two constructors:

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+\_} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\<\end{code}

This is the most proper version we decided to use for the set of integers. It is
inductively defined and is readable because it is just an
intepretation of the usual symbols for integers in regular mathematics.

Usually we believe that the reason of inventing integers is the lack of symbols to
represent the results of subtraction between two
natural numbers. Integers are used to represent these results, and
vice versa,
every integer can be represented as a pair of natural numbers and the
choice is not unique.
For example, from the equation $1 - 4 = - 3$, it is clear that the
integer $- 3$ can be represented the pair $(1,4)$. 
Therefore we can use the paired natural numbers as an alternative
definition for integers.

$$\Z_0=\N \times \N$$

However since there are different pairs for one integer, we have to
quotient it with an equivalence relation. For any two pairs of natural
numbers $(n_1, n_2)$ and $(n_3, n_4)$, we know they represent the same
integer if

$$ n_1 - n_2 = n_3 - n_4$$

Technically, this does not work because the subtraction defined for natural
numbers only returns zero if the pair is for negative number. We only
need to do some small modifications:

$$ n_1 + n_4 = n_3 + n_2$$

This helps us define a relation but it is not enough. This is an
equation in mathamtics, but in Type Theory we have to prove that it is an
equivalence relation, namely, it is reflexive, symmetric and transitive.

Combining the carrier (the pair of natural numbers), the equivalence
relation and its proof, we have a setoid.

\begin{code}
\\
\>\AgdaFunction{ℤ-Setoid} \AgdaSymbol{:} \AgdaRecord{Setoid}\<%
\\
\>\AgdaFunction{ℤ-Setoid} \AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{\{} \AgdaField{Carrier} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaFunction{ℤ₀}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{;} \AgdaField{\_≈\_} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaPostulate{\_∼\_}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{;} \AgdaField{isEquivalence} \AgdaSymbol{=} \AgdaPostulate{\_∼\_isEquivalence}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{\}}\<%
\\
\end{code}

Since the set of integers is definable as we discussed before, they can
be seen as the normal forms of the equivalent classes. The normalisation
function can be defined as follows:
 
\begin{code}
\\
\>\AgdaFunction{[\_]} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{[} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{0} \AgdaFunction{]} \<[18]%
\>[18]\AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaBound{m}\<%
\\
\>\AgdaFunction{[} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{]} \<[18]%
\>[18]\AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaBound{n}\<%
\\
\>\AgdaFunction{[} \AgdaInductiveConstructor{suc} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{]} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{n} \AgdaFunction{]}\<%
\\
\end{code}

The function should be proved well-defined on the setoid, namely it
has to respect the equivalence relation. We call it soundness here. 
It is not trivial but easy to observe that the function is
sound\footnote{the formal proof can be found in appendix (we cheat a
  bit by defining embedding function to make it simpler)}.

A setoid and a function respects this equivalence (not necessary to be
a normalisation function) constitute a prequotient.

\begin{definition}
Prequotient.

\noindent
Given a setoid $(A,\sim)$,  a \emph{prequotient} $(Q,[\_],\sound)$ over that setoid consists in
\begin{enumerate}
\item \label{enum:Q} a set $Q$,
\item \label{enum:box}a function $[\_]: A \to Q$,
\item \label{enum:sound} a proof \emph{sound} that  the function $[\_]$ is compatible with the relation $\sim$,
that is \[\sound\colon (a,b : A) \to a\sim b \to [a] = [b],\]
\end{enumerate}


Prequotient only includes the formalisation rules and introduction
rules. To complete a \emph{quotient}, we also need the elimination rule added into such a prequotient

\begin{enumerate}
\setcounter{enumi}{3}
\item \label{enum:elim}
for any $B: Q\to\Set$, an eliminator
 \begin{align*}
 \qelim_B\,\,:\,\,\,&(f\colon (a:A) \to B\,\class a) \\
        {\to}\, &((p:a\sim b) \to f\,a \simeq_{\sound\,p}f\,b)\\
        {\to}\, &((q:Q) \to B\,q)
 \end{align*}
such that $\qelimbeta : \qelim_B\,f \,p\,\class a\equiv f\,a$.
\end{enumerate}

This eliminator is also called dependent lifting function because it
actually lifts a function which is well-defined on the setoid to a
function defined on the quotient type. The result type is also
dependent on the quotient type. There is an equivalent definition
given by Martin Hofmann
which has a non-dependent eliminator with an induction principle
instead.

\[\lift\colon (f\colon A \to B) \to (\forall a,b\cdot a\sim b \to f\,a
\equiv f\,b) \to (Q \to B)\]

Suppose $B$ is a predicate, 
\[\qind \colon((a: A)\to B \,\class a)\to ((q : Q)\to B\,q)\]

However, it is oberservable that given any non-empty set $Q$, all
constant functions fit in this definition. Any element of $Q$ has to
be mapped from at most one equivalence class of the setoid
$(A,\sim)$. This property is called \emph{exact} here 

\begin{enumerate}
\setcounter{enumi}{4}
\item $exact :(\forall a,b : A) \to  \class a \equiv \class b \to a \sim b$.

\end{enumerate}
\end{definition}

The quotient is exact if exactly one equivalence class corresponds to
an element of $Q$.

We already know that the integer is definable and it is plausible to
find a representative in each equivalence classes. Since
we treat elements of $Q$ as the name for the equivalence classes, the
selection function can be defined as an embedding function from  the
quotient type $Q$ to base type $A$. This is an alternative and more
flexible way to eliminate the quotient type $Q$ and if a
prequotient $(Q, \class{\dotph}, \sound)$ on a setoid $(A,\sim)$ has
an embedding function which is specified as
\begin{align*}
\emb &: Q \to A\\
\complete &: (a : A) \to \emb {\class a} \sim a\\
\stable &: (q:Q) \to \class{\emb\,q} \equiv q.\\
\end{align*}

Then it is a \emph{definable quotient}. Composing the ``normalisation'' function $\class\dotph$ with the
embedding function, we obtain the real normalisation function. A
definable quotient is an \emph{exact} quotient which is proved in \cite{aan}.



\paragraph{Operations}

For a definable quotient, we can lift an operation by mixing the
normalisation and embedding functions. For example, given an unary
operator 

\begin{code}
\\
\>\AgdaFunction{lift₁} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{op} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{lift₁} \AgdaBound{op} \AgdaSymbol{=} \AgdaFunction{[\_]} \AgdaFunction{∘} \AgdaBound{op} \AgdaFunction{∘} \AgdaFunction{⌜\_⌝}\<%
\\
\end{code}

To lift binary or n-ary operators, we only need to apply the operator
to the representative for each "equivalence class" and "normalise" the
result so that it becomes a function defined on the set of
"equivalence classes".

But there is a unavoidable problem: not all operations defined on
$\Z_0$ is defind on the setoid, namely respect the equivalence
relation. Therefore it is reasonable to verify if the function is
well-defined on the setoid:

$$a \sim b → op \, a \sim op \, b$$

We will show how to define the addition for the quotient
integers. Given two numbers $(a_1 , b_1)$ and $(a_2 , b_2)$ We
only need to add them pair-wisely together, and it can be verified
easily because we know that 

$(a_1 - b_1) + (a_2 - b_2) = (a_1 + a_2) - (b_1) - (b_2)$

The verification is not necessary here but should be important in
other cases.

\begin{code}
\\
\>\AgdaFunction{\_+\_} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{x+} \AgdaInductiveConstructor{,} \AgdaBound{x-}\AgdaSymbol{)} \AgdaFunction{+} \AgdaSymbol{(}\AgdaBound{y+} \AgdaInductiveConstructor{,} \AgdaBound{y-}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{x+} \AgdaFunction{ℕ+} \AgdaBound{y+}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{x-} \AgdaFunction{ℕ+} \AgdaBound{y-}\AgdaSymbol{)}\<%
\\
\end{code}


\paragraph{Properties}

We can also define the ring of $\Z$. It contains a lot of properties
to prove which are seemed as axioms in classic mathematics. In
constructive mathematics, the only axioms for integers are the
constructors and the elimination rules.

As what we have menetioned, even though the definition of integers
only has two constructors, it gradually increase the difficulty of
proving when doing case analyses on more and more integers. One
example is the proving of distributivity.

\paragraph{An efficient utilization of quotient structure: the proving of distributivity}

One of the most important motivations of using setoid integers is that
the setoid definition reduces the complexity of programs involving
integers. We have shown it is simpler to define some operators, but it
will be much more evident when proving properties of the ring of integers.

Most simple laws of the ring of integers are not as unbearably
complicated as the distributivity laws. An attempt of the right
distributivity for $\Z$ ($ (y + z) \times x = y \times x + z \times x$)
is shown as below. The multiplication is not defined with pattern
matching, but in the arithmetic approach.

\begin{code}
\\
\>\AgdaFunction{\_ℤ*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaBound{i} \AgdaFunction{ℤ*} \AgdaBound{j} \AgdaSymbol{=} \AgdaFunction{sign} \AgdaBound{i} \AgdaFunction{S*} \AgdaFunction{sign} \AgdaBound{j} \AgdaFunction{◃} \AgdaFunction{∣} \AgdaBound{i} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{j} \AgdaFunction{∣}\<%
\\
%
\\
\end{code}

The first idea which I came up
with is to use the right distributivity law of natural
numbers. It is observable that if all three variables have the same
signs, it is easy to apply the right distributivity law of natural
numbers. We can relax the constraint a bit, only y and z have the
same symbol, it is still plausible. To prove this part we need three
lemmas,

\begin{code}
\\
\>\AgdaFunction{lem1} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y} \AgdaFunction{∣} \AgdaDatatype{≡} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ+} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \<[61]%
\>[61]\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{m+1+n≡1+m+n} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(} \AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{0} \AgdaBound{s} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{ℤ-id-l} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{lem3} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-+-assoc} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaBound{n} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaBound{x}\AgdaSymbol{)))))}\<%
\\
\>[13]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{s} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaBound{y} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{))} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaBound{s} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-id-r} \AgdaSymbol{\_)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.-} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\end{code}

The following is a partial definition with the first case that 

\begin{code}
\\
\>\AgdaFunction{distʳ} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaFunction{\_ℤ*\_} \AgdaFunction{DistributesOverʳ} \AgdaFunction{\_ℤ+\_}\<%
\\
\>\AgdaFunction{distʳ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaKeyword{with} \AgdaFunction{sign} \AgdaBound{y} \AgdaFunction{S≟} \AgdaFunction{sign} \AgdaBound{z}\<%
\\
\>\AgdaFunction{distʳ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \<[15]%
\>[15]\AgdaSymbol{|} \AgdaInductiveConstructor{yes} \AgdaBound{p} \<[23]%
\>[23]\<%
\\
\>[4]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaKeyword{rewrite} \AgdaFunction{lem1} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \AgdaSymbol{|} \AgdaBound{p} \<[32]%
\>[32]\<%
\\
\>[9]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaSymbol{|} \AgdaFunction{lem2} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \AgdaSymbol{=} \<[30]%
\>[30]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{z} \AgdaFunction{S*} \AgdaFunction{sign} \AgdaBound{x} \AgdaFunction{◃} \AgdaBound{n}\AgdaSymbol{)} \<[47]%
\>[47]\<%
\\
\>[0]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{(}\AgdaFunction{distribʳ} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)))} \<[44]%
\>[44]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣}\AgdaSymbol{)} \<[46]%
\>[46]\<%
\\
\>[0]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{(}\AgdaFunction{sign} \AgdaBound{z} \AgdaFunction{S*} \AgdaFunction{sign} \AgdaBound{x}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{distʳ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{|} \AgdaInductiveConstructor{no} \AgdaBound{¬p} \AgdaSymbol{=} \AgdaBound{...}\<%
\\
\end{code}

If y and z have different
signs, it is impossible to apply the right distributivity law for
natural numbers. We have to prove it from scratch. Even though it
seems that there are only two cases to prove, it is conceivable that how
many lemmas we need as prerequisites. The proving is as complicated as
using pattern matching on each variable. This is not the best solution
we want. We should benefit more from the observation that any equation
of integers can be turned into equation of natural numbers\ref{obs-int-nat}.










However, if we prove
the laws for quotient integers, it is much simpler since there is
only one case to prove.

However, if we prove it for the quotient integers, it is much
easier. In fact, it is in generally automatically provable. Since the
equality of any two quotient integers is essentially the equality of two
natural numbers after normalising. To prove the distributivity, the
simpliest way is to use semiring
solver for natural numbers. $\AgdaFunction{DistributesOverˡ}$ means
that the distributivity of the first operators over the second one.

\begin{remark}
A ring solver is an automatic equation checker for rings e.g.\ the
ring of integers. It is implemented based on the theory described in
"Proving Equalities in a Commutative Ring Done Right in Coq" by
Grégoire and Mahboubi \cite{gregoire2005proving}.

\end{remark}

\begin{code}
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \<[9]%
\>[9]\AgdaFunction{\_*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{solve} \AgdaNumber{6} \<[40]%
\>[40]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{f} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{:=}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{e} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)))} \AgdaInductiveConstructor{refl} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\<%
\\
\end{code}

The utilization of ring solver can be simplified even further by
adopting "reflection". It helps us quote the type of the goal so
that we can define a function that automatically do it without
explicitly providing the equations. There is already some work
done by van der Walt \cite{van2012reflection}. It can be seen as an
analogy of the "ring" tactic from Coq.



The main drawback of this method is the type verification of the
terms automatically generated requires more computations than the terms
we manually construct. The optimization of Agda already shows a big
improvement in this technical efficiency issue. However it will affect
other functions that use this proof. It may heavily slow the type
checking.
Therefore although it is still very convenient to use the ring solver to prove any proposition for the quotient
integers, we decide to prove commonly used properties for the commutative
ring of the integers by hand. Luckily it is still much simpler than the ones
for the set of integers $\Z$.


This is a good example of how the definable quotient structure helps
simplifying definiting and proving about new types based on existing
functions and theorems. 


\section{Rational numbers}

The quotient of rational numbers is better known than the previous
quotient of integers. We usually write two integers $m$ and $n$ ($n$ is not zero) in
fractional form $\frac{m}{n}$ to represent a rational number. Alternatively we
can use an integer and a positive natural number such that it is
simpler to exclude 0 in the denominator. Two fractions are equal if
they are reduced to the same irreducible term. If the numerator and
denominator of a fraction are coprime, it is said to be an irreducible
fraction. Based on this observation, it is naturally to form a definable quotient, where the base type is 

$$\Q_0 = \Z \times \N$$

The integer stands for the \emph{numerator} and the natural number is
\emph{denominator-1} (We use $N$ for $N^{+}$ to avoid invalid
fractions from construction rather than from zero test)

In Agda, to make the terms more meaningful we define it as

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℚ₀} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[-1]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_/suc\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{n} \AgdaSymbol{:} \AgdaDatatype{ℤ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{d} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\end{code}

In mathematics, to judge the equality of two fractions, it is easier to conduct the following conversion,

$$ \frac{a}{b} = \frac{c}{d} \iff a \times d = c \times b $$

Therefore the equivalence relation can be defined as,

\begin{code}
\\
\>\AgdaFunction{\_*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaNumber{0}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaInductiveConstructor{suc} \AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{\_∼\_} \<[35]%
\>[35]\AgdaSymbol{:} \AgdaFunction{Rel} \AgdaDatatype{ℚ₀} \AgdaSymbol{\_}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{n1} \AgdaInductiveConstructor{/suc} \AgdaBound{d1}\AgdaSymbol{)} \AgdaFunction{∼} \AgdaSymbol{(}\AgdaBound{n2} \AgdaInductiveConstructor{/suc} \AgdaBound{d2}\AgdaSymbol{)} \AgdaSymbol{=} \<[31]%
\>[31]\AgdaBound{n1} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d2} \AgdaDatatype{≡} \AgdaBound{n2} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d1}\<%
\\
\end{code}

The normal form of rational numbers, namely the quotient type in this quotient is the set of irreducible fractions. We only need to add a restriction that the numerator and denominator is coprime,

$$\Q = \Sigma (n \colon \Z). \Sigma (d \colon \N). \mathsf{coprime} \,n \,(d +1)$$

It can be defined as follows which is available in standard library,

\begin{code}
\\
\>\AgdaKeyword{record} \AgdaRecord{ℚ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{numerator} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{denominator-1} \AgdaSymbol{:} \AgdaDatatype{ℕ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{isCoprime} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{C.coprime?} \AgdaFunction{∣} \AgdaBound{numerator} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{denominator-1}\AgdaSymbol{))}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaFunction{denominator-1}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{:} \AgdaFunction{Coprime} \AgdaFunction{numerator} \AgdaFunction{denominator}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{=} \AgdaFunction{toWitness} \AgdaFunction{isCoprime}\<%
\\
\end{code}

The normalisation function is an implementation of the reducing
process. But first we need to  the |gcd| function which calculates the greatest common
divisor can help us reduce the fraction and give us the proof of
coprime. First we need to define the conversion from the results of GCD
to normal rational numbers (the full definition can be found in
Appendix \autoref{rational-gcd}),

\begin{code}
\\
\>\AgdaFunction{GCD′→ℚ} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{di} \AgdaSymbol{→} \AgdaBound{y} \AgdaFunction{≢} \AgdaNumber{0} \AgdaSymbol{→} \AgdaDatatype{C.GCD′} \AgdaBound{x} \AgdaBound{y} \AgdaBound{di} \AgdaSymbol{→} \AgdaRecord{ℚ}\<%
\\
\end{code}

To normalise a fractional, we split it into 3 cases with respect to
the numerator. The idea is to calculate the "gcd'' and then use the
above function to get the normalised rational number.

\begin{code}
\\
\>\AgdaFunction{[\_]} \AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaRecord{ℚ}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{0}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{=} \AgdaInductiveConstructor{ℤ.+\_} \AgdaNumber{0} \AgdaFunction{÷} \AgdaNumber{1}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaSymbol{=} \AgdaFunction{GCD′→ℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaBound{di} \AgdaSymbol{(λ} \AgdaSymbol{())} \AgdaSymbol{(}\AgdaFunction{C.gcd-gcd′} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\end{code}


The embedding function is simple. We only need to forget the coprime proof in the normal form,

\begin{code}
\\
\>\AgdaFunction{⌜\_⌝} \AgdaSymbol{:} \AgdaRecord{ℚ} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\>\AgdaFunction{⌜} \AgdaBound{x} \AgdaFunction{⌝} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{ℤcon} \AgdaSymbol{(}\AgdaFunction{ℚ.numerator} \AgdaBound{x}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaSymbol{(}\AgdaFunction{ℚ.denominator-1} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\end{code} 

Similarly, we are able to construct the setoid, the prequotient and
then the definable quotient of rational numbers. We can benefit from
the ease of defining operators and proving theorems on setoids while
still using the normal form of rational numbers, the lifted operators
and properties which are safer.

The same approach works here as well. Since we can easily embed the natural numbers into integers, the
equations of the quotient rational numbers are degraded to equations of the
integers.  The commutative ring of integers also enable us to prove
all properties of rational numbers automatically.

