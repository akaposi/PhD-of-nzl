\chapter{Introduction}

Type theory is usually considered as an more rigorous foundation of
constructive mathematics that set theory.
 It is a formal system serves as not only a foundation of constructive mathematics but also a dependently typed programming language. A number of
dependently typed functional programming languages are implementations of \mltt, including NuPRL, LEGO, Coq, Agda, Epigram, Pi-Sigma etc.


Type Theory is based on Curry-Howard isomorphism which is a correspondence between propositions and types such that one can build constructive proofs as programs in  implementations of Type Theory like Agda. Compared to other programming languages, one can reason about programs in themselves and thus write certified programs.
Since Type Theory provides computer aid formal reasoning, there have been a lot of \maths formalised in it. The encoding of constructive mathematics also helps in program specification and verification. 

However, most of the implementations are based on the \emph{intensional} variant of \mltt where \emph{propositional equality} is different to \emph{definitional equality}. The propositional equality which induced by the identity type is intensional such that extensionally equal terms like point-wise equal functions, logically equivalent propositions are not propositionally equal. \itt is preferable because type checking is decidable so that it has good computational behaviours. However the lack of extensional concepts in current implementations like Agda, hinders them from becoming a more popular theorem prover.

The notion of \emph{quotient types} is one of the essential extensional concepts which is not available in current implementations of \itt. A quotient type is obtained by redefining equality of a type with a given equivalence relation which is not supported. This thesis mainly studies quotient types from a discussion on the definability of quotients via a normalisation to models where quotient types are available. Most of the work is conducted in Agda.


\section{Equality}

We first learn equality for numbers in \maths. Generally speaking, it
expresses the sameness of two mathematical objects such as numbers or sets.
$1+2=3$ tells us the mathematical object calculated from $1+2$ is the
same as $3$.

From ages before, mathematicians are arguing about the correct way to
characterise equality. The most common idea is that equality is just
identity. Leibniz's law can be seen as a "definition" of
equality:

Given any $x$ and $y$, $x = y$ if, given any predicate $P$, $P(x)$ if and only
if $P(y)$.

In Type Theory, the encoding of equality is also contentious. Considering a variety of issues, there are
several notions of equality in type theory.
We can compare whether two types are equal or two terms are equal. If two
expressions can be computed to the same object then we claim they are
 \emph{definitionally} equal.  
 We can also internalise definitional equality by defining \emph{identity types}. An inhabitant of identity type is an evidence of the \emph{propositional equality} between two terms or types are equal and is usually denoted as refl. 

In \ett, propositional equality is identified with definitional equality which makes definitional equality undecidable and then type checking undecidable. However in \itt, they are different. Propositional equality is only induced by identity types which captures equality on two closed terms. 
Functions are considered equal if they are extensionally equal, namely point-wise equal, but can be definitionally different. For example, $\lambda n \to n$ and $\lambda n \to n + 0$ does not equal in the usual definition of addition, because $n+0$ does not reduce to $n$.
The problem arises from the computational difficulties. A type checker can easily decide whether two
values of inductive types are the same, but not whether two functions
are extensionally equal. Even suppose we encode the method to compute
the definitional equality of the outputs for each given input, it can
only decide the equality for finite types.

There are also many other extensional concepts missing as Martin Hofmann pointed out in \cite{hof:phd}.Quotient types is one of them and is essential for construction of \maths and programs.

% Because there is no attached equality for each types other than trivial identity, it is
% necessary to use a different model of type theory in which types are
% equipped with equalities.

\subsection{Quotient types}

In \maths, a quotient set is a set of the equivalence classes of
some equivalence relation on another set. Abstracted from this
concept, there are also quotient groups, quotient categories etc.

Naturally, given a type and an equivalence relation, one would expect a \emph{quotient type}
which can be intuitively thought as a new type generated by redefining equality on original type with the given equivalence relation.
However such a type former does not exist in current formulation of \itt because there is no attached equivalence on each type except definitional equality which can not be changed. Usually a setoid which consists of a set and an equivalence relation on it is used to represent quotients. However, this will not ideal because we have to redefine everything on sets for setoids.

Some quotients can be defined inductively without using quotient types. 
For example integers can be represented as pairs of natural numbers which are equivalent if the subtraction of first number from the second are equal.  This setoid gives rise to a quotient, but the set of integers can also be inductively. An algebraic structure of quotients consists of the set definition and a normalisation mapping from the "base" type to the "quotient" type and essential properties and operations. Such a framework provides a flexible approach to lifting functions and proofs from base types to quotient types. The simulation sounds superfluous at first, but in practice, it is much easier to define
functions for the base types (because usually they have a bundle of
library codes) on underlying level, and the ''quotient types'' has no
redundant on the surface level.

However not all types are definable with a normalisation functions, for example real numbers, multisets etc. Thus quotient types are essential for encoding of these important constructions.

If a type is treat like a set, it seems impossible to enforce a equality on it. Therefore, it becomes more and more popular to interpret types as structure objects like setoids, groupoids and \wog which internalising equality as definitions. 

There are several different models of Type Theory where extensional concepts including quotient types are derivable.

\begin{itemize}

\item Altenkirch's setoid model. Altenkirch \cite{alti:lics99} proposed an intensional setoid model
with a proof-irrelevant universe of propositions \textbf{Prop} which
is closed under $\Pi$ and $\Sigma$. It interprets types as setoids
such that quotient types are just setoids whose equality is replaced
by given equivalence relation.

\item Hofmann and Streicher's groupoid model. They give a model in which
types are interpreted as groupoids. In this model, propositional
equality is interpreted as isomorphism and $K$ eliminator for equality
types is unavailable. 

\item Homotopy type theory and \wog model. It can be seen as a
generalisation of the groupoid model above. Types are interpreted as
higher groupoids.

\end{itemize}

\section{Programming in Agda}

In this thesis we use Agda to implement our constructions in \itt. 
Agda is a dependently typed, functional programming language, which is
based on the intensional version of \mltt. It is mainly developed by
Ulf Norell, Nils Anders Danielsson, and Andreas Abel.
It is a functional language like Haskell, but has dependent types. It has dependent pattern
matching, type checker, coverage checker and termination checker. It
supports a bundle of scheme of defining data types such as inductive, inductive-recursive, mutually inductive,
coinductive types. Its syntax is close to Haskell, in addition, it has
unicode support and mixfix operators. All these features including
type checker, unicode typing and interactive programming present in
its Emacs interface. It is quite popular in the field of mathematical reasoning and programs
verifications. Many researchers implement their work of type theory in
Agda. It is also one of the popular languages in the community of the recently
developed field \hott and the library of \hott is under construction.
The adequate reasoning library code also helps in writing certified programs.

In \autoref{bg} we present a brief introduction to it for someone
who meet this language for the first time. In \autoref{dq} we use Agda to implement our definable quotient algebraic structures. In \autoref{models} we build a category with families of setoids in Agda. In \autoref{wog}, we implement a syntactic construction of \wog.

Agda wiki\cite{agdawiki:main} is a good reference to it and there are
several good tutorials to Agda for example Ulf Norell's
\cite{tutorial}, Ana Bove, Peter Dybjer, and Ulf Norell's \cite{bove2009brief}.



\section{Applications}


Quotient types are very useful or even essential in some
mathematics formalisation. 

For quotients which are definable without quotient types, it is
possible to relate them with setoid representation within some
algebraic structures. 
These structures of definable quotients can facilitate the
manipulation of some complicated types which
are semantically quotients of some other setoids. It can be seen as a
simulation of quotient types in a pure \itt. Even though it does not
automatically provide some constructions, it is still helpful because
of the comparatively ease of reasoning about setoids and flexible
conversion between the setoids and sets.


In a type theory with quotient type, real numbers can be encoded as
the Cauchy sequences with an equivalence relation.
From programming perspective,  it also provides more algebraic
datatypes and enable us to reason about infinite types and
semantics-based verification of concurrent programs \cite{hof:phd}.


\section{Overview}


%compact, comprehensive Overview: Add overview of each part, as much as you can, and compact



In \autoref{bg}, we introduce Type Theory as background of our study. We provide a brief
history of it and some basic rules of it as a formal system.
We also introduce a dependent functional
programming language called Agda which is designed based on Type Theory.
we also discuss the new area between \maths and
computer science -- \hott. Quotient types can be encoded in \hott simply.


In \autoref{qt}, we discuss quotient types which is the topic of
this thesis in detail. We explain what is a quotient type by a set of rules  together with a categorical explanation.



In \autoref{dq}, we start introducing one of our achievements, the
definable quotient algebraic structures. A quotient structure consists of a set definition servers as the "quotient" type and a normalisation function with several essential functions and conditions.
For quotients that are definable inductively, a new type former of quotient seems unnecessary.
As a example, integers can be encoded as the
quotients types of paired natural numbers over the equivalence
relation that two pairs are equal if they represent the same
subtraction. Integers can also be defined inductive as a set. Definable quotient structures abstract the relation between these two representations and provides a flexible way of conversions. It can be seen as 
a simulation of the quotient types.



In \autoref{rl}, we discuss quotients that are undefinable as a inductive set with a normalisation mapping, such as the real numbers, finite multisets and partiality monads. We show a meta-theoretical proof of the undefinability of real numbers and generalise it.


In \autoref{models}, we discussed several models where quotient types are available. We present an implementation on the setoid model approach to encode
extensional concepts. The work is mainly extending the setoid model
done by Altenkirch in \cite{alti:lics99} to
quotient types. Some other models including models of \hott are also mentioned.






Finally, in \autoref{wog}, we present a new formalisation of the syntax of weak
  $\omega$-groupoids in Agda using heterogeneous equality. We show how
  to recover basic constructions on $\omega$-groupoids using
  suspension and replacement. In particular we show that any type
  forms a groupoid and we outline how to derive higher dimensional
  composition. We present a possible semantics using globular sets and
  discuss the issues which arise when using globular types instead. The work in the chapter has been published in \cite{LFMTP14} together with Thorsten Altenkich and Ond\v{r}ej Ryp\'{a}\v{c}ek.


In Appendix, we present the complete code of as a reference for someone who is interested in our work.
