\chapter{Introduction}

\mltt (or just Type Theory) is a type theory which serves as a foundation of constructive mathematics and is also a dependently typed programming language. Different from other foundations like set theory, it is not based on predicate logic but internalises the BHK interpretation of intuitionistic logic through the Curry-Howard isomorphism. It identifies a proposition with a type such that a proof of it is a term of that type. 
As a programming language, it means that we can express a specification as a type of the programs satisfying it.
Moreover, one can write programs and reason about them in it, thus write certified programs. There are a number of implementations of it, such as NuPRL, LEGO, Coq, Agda, Epigram, Pi-Sigma etc.


As a foundation of constructive mathematics, there have been a lot of \maths formalised in it, for example a formal proof of the four-colour theorem by Georges Gonthier \cite{gonthier08ams} \footnote{More formalised mathematics can be found in \cite{sbfm}}. The formalisation of mathematics in programming languages not only provides mathematicians a powerful theorem prove to constructively prove theorems with computerised verification, but also helps in program specification and reasoning. 

There are two versions of \mltt, the \emph{intensional} version (\itt) and the \emph{extensional} version (\ett).  They differ in the treatment of two notions of equality, \emph{propositional equality} and \emph{definitional equality}.  Roughly speaking, if two expressions can be computed to the same object then we make the judgement that they are definitionally equal. On the other side, we have \emph{identity types} which are types as propositions expressing the equality between two terms of the same type, so it is called propositional equality.

In \ett they are identified, which makes definitional equality undecidable and then type checking undecidable. But in \itt, propositional equality does not imply definitional equality.
In \itt, the propositional equalities induced by the identity type are intensional so that it 
can not capture the equality between extensionally equal terms like two point-wise equal functions, two logically equivalent propositions, and the two ``equivalence classes'' $[a]$, $[b]$ where $a \sim b$. 
For example, $\lambda n \to n$ and $\lambda n \to n + 0$ are intensionally different \footnote{Considering the definition of $+$ where $n+0$ can not be reduced to $n$.} so they are not propositionally equal.
Even if we encode the method to compute
the definitional equality of the outputs for each given input, it can
only decide the equality for for finite inputs.
Therefore the equality of two functions are undecidable in general.

%A type checker can easily decide whether two values of a inductive type are the intensionally equal, but not whether two functions are extensionally equal. 

In fact there is a list of extensional concepts (see \autoref{extensionality}) which are useful, justifiable but not available in \itt.
Nevertheless \itt is still preferable than \ett as the basis for programming languages, because its type checking is decidable so that it has good computational behaviours.
Therefore, we would like to extend \itt with these extensional concepts, and the notion of quotient types is one of them.

%and is essential for construction of \maths and programs.


\section{Quotient types}


\emph{Quotient} is a primitive notion in mathematics. In arithmetic, quotient refers to the result of division

$$8 \div 4 = 2 ~~ \text{or}~~ 8/4 = 2$$

The notion is generalised in more abstract branches of mathematics, such as set theory, group theory, topology etc. For example in set theory, given a set $A$ and an equivalence relation $\sim$, the set of all equivalence classes of $\sim$ is called the \emph{quotient set} of $A$ by $\sim$.

An \textbf{equivalence relation} is a binary relation which is 

\begin{itemize}
\item reflexive: $\forall a \in A, a \sim a$,
\item symmetric: $\forall a~ b \in A, a \sim b \to b \sim a$
\item transitive: $\forall a ~ b~ c \in A, a \sim b \to b \sim c \to a \sim c$.
\end{itemize}

The \textbf{equivalence class} of an element $a$ is a subset of $A$ which contains all elements equivalent to $a$:

\begin{equation*}
[a] = \{x \in A \;| \; a \sim x \}
\end{equation*}

The \textbf{quotient set} of $A$ by $\sim$ is just the set of equivalence classes:

\begin{equation*}
\qset{A} = \{ [ a ] \;|\; a : A \}
\end{equation*}

Similarly, we can also ``divide'' a group, space, category or another algebraic structure by a given structure-preserving equivalence relation on it.

Naturally one would also expect \textbf{quotient types} in Type Theory. Intuitively speaking, a \emph{quotient type} $\qset{A}$ is a type $A$ whose equality is redefined by an equivalence relation on it. In \ett, it is possible to redefine the equalities of types. 
For example, in NuPRL which is an implementation of \ett, there is a quotient operator which builds a new type from a given type and an equivalence relation on it \cite{DBLP:books/daglib/0068834}. There are some problems of it: we can recover the witness of the equality between two equal elements in quotient types \cite{nog:02}; we can define functions on quotient types which do not respect the equivalence relation (see \autoref{related}).



Because of the good computational property of \itt, we would like to have quotient types in \itt as well.
However in traditional formulation of \itt, such a type former does not exist because there is no attached equivalence on each type except definitional equality which can not be changed. Instead \textbf{setoids} are usually used to represent quotients:

\begin{definition}
\textbf{Setoid}.
\noindent A setoid $(A,\sim,\text{eqv}_{\sim})$ (usually written as just $(A,\sim)$) consists of
\begin{enumerate}
\item a set (type) $A : \Set$,
\item a binary relation $\sim : A \to A \to \Prop$, and
\item it is an equivalence, i.e.\ the proofs that it is reflexive, symmetric and transitive.
\end{enumerate}
\end{definition}

Notice that this notion is also called a \emph{total setoid}. If the relation of a total setoid is not required to be reflexive, then it becomes a \emph{partial setoid}. In this thesis, the word "setoid" usually refers to a total setoid.


A function $f : A \to B$ is well-defined on a setoid $(A,\sim)$ only if it respects $\sim$ or it is \emph{compatible} with $\sim$:

\begin{definition}\label{compatible}
We say a function $f : A \to B$ is \textbf{compatible} with $\sim$ if

$$\forall (x, y : A) \to x \sim y \to f(x) =_{B} f(y)$$
\end{definition}

However using setoids to represents quotients is not an ideal solution. Since it is an alternative representation of sets, everything defined on $\Set$ has to be redefined on $\Setoid$ again. 
For example, functions between setoids, equalities on setoids,
products on setoids etc. Moreover, considering a quotient $\qset{A}$ whose $A$ is already defined as a setoid, it is essential to define generalised "setoids" on setoids.
In fact, in other branches of mathematics, the quotient object is essentially the same kind of object as the base one.
Therefore, it is better to have a representation of the quotient $\qset{A}$ which is in the same sort as $A$ is. 

In fact not all quotients have to be defined using a quotient type former. For example integers can be represented as pairs of natural numbers $\N \times \N$ which are equivalent if the subtraction of first number from the second are equal. This gives rise to a quotient. However the set of integers can also be defined inductively from the observation that $\Z \simeq \N + \N$.
For these quotients, the set definition can be seen as the normal form of "equivalence classes" which is usually described by a mapping from setoid representation to set representation called \textbf{normalisation function}. In this thesis we say that such quotients \emph{definable via a normalisation (function)} (see \autoref{dq}).


However, there are also some quotients that are not definable via normalisation, for example, the set of real numbers represented by the Cauchy sequences of rational numbers, the finite multisets represented as lists quotiented by permutation equivalence (or bag equivalence \cite{DBLP:conf/itp/Danielsson12}) etc. In these cases, a general schema to define quotient types is essential.

It we simply introduce quotient types as axioms into \itt, we lose the \emph{canonicity} property, in other words, we can construct non-canonical terms of $\N$ which can not be reduced to numerals (see \autoref{quotientcanonicity}). In fact, similar issues arise when adding other extensional concepts as axioms e.g.\ functional extensionality. Therefore it is essential to find a computational interpretation of these extensional concepts including quotient types.

To achieve the goals, we have to "refine" our interpretation of types. Usually a type is treated as a set without attached equality. If a type is interpreted as a \emph{setoid}, in other words internalising propositional equality, quotient types can be defined simply by replacing ``internal'' equality. This is called \emph{setoid interpretation} which is inspired by Bishop's \cite{bishop} definition of sets and 
some research has been done by Martin Hofmann \cite{hof:phd,hof:95:sm}, and Thorsten Altenkirch \cite{alti:lics99,alti:ott-conf}. Based on this interpretation, we can build a setoid model in \itt which gives us the  computational interpretation of quotient types.

It has been unclear for a long time what identity types are in \itt. Intuitively, the uniqueness of identity proof (UIP), namely two terms of a same identity type is always propositional equal, is valid because there is at most one canonical element expressing the equality between two objects. However UIP is not derivable from $\J$ but an extra eliminator $\K$ suggested by Thomas Streicher \cite{streicherinvestigations}.
Hofmann and Streicher further \cite{MR1686862} propose a groupoid interpretation of \itt where $\K$ is refuted and then UIP fails. The groupoid interpretation  can be seen as a generalisation of setoid one, where the identity type is not a proposition but a set. 

In fact, it is more accurate to interpret a type as an $\infty$-groupoid which is a generalisation of a groupoid. Since Grothendieck's homotopy hypothesis states that $\infty$-groupoids are spaces \cite{homotopyhyp}, we can interpret types as spaces indeed. In recent years, such a interpretation has been developed into a new field called \hott where types are interpreted as spaces (abstractly).
Because the coherence conditions like the groupoid laws hold as propositional equality in \itt, it is better to interpret types as \emph{weak} $\omega$-groupoids. Usually the definitions of \wog are too involved to state, it is more popular to decribe them using some simpler incarnations  like simplicial sets or cubical sets. However it is still possible to build a syntactic type theory to describe \wog in \itt.

In \hott, the most important axiom is \emph{univalence} which is suggested by Voevodsky \cite{VV}. Roughly speaking, univalence states that isomorphic types are propositional equal. Many extensional concepts are derivable including functional extensionality, propositional extensionality, quotient types \footnote{...in the traditional sense}, Voevodsky has proposed an impredicative encoding of quotient types (see \autoref{impredicative}). However the computational interpretation of univalence remains an open problem.


Quotient types can be applied in both formalisation of mathematics and program verification. As we mentioned, one of the fundamental mathematical notions \emph{real numbers} can be defined by as a quotient where the base set is the Cauchy sequences of rational numbers. 
From programming perspective,  it also provides more algebraic
datatypes and enable us to reason about infinite types and
semantics-based verification of concurrent programs as suggested by Hofmann \cite{hof:phd}.


\section{Overview}



In \autoref{bg}, we introduce \mltt as the background of our study. We provide a brief
history of it and some basic rules of it.
We also introduce the main tool we use -- Agda, which is a dependently typed functional
programming language based on intensional version of \mltt. Then we discuss the missing extensional concepts in \itt excluding quotient types. We also introduce the new interpretation of \hott, where we have univalence, and higher inductive types which allow constructors for internal equalities. Finally we discuss the extensional concepts in it and the potential computational interpretations of it in \itt.


In \autoref{qt}, we provide the syntactic rules of quotient types together with a discussion of effectiveness. Categorically speaking, a quotient type is a \emph{coequalizer}. We also explain the rules of quotient types given by an adjunction. In \hott because of the different interpretation of sets, the traditional quotient types are just quotient \emph{sets}. We first introduce the Voevodsky's impredicative encoding of quotient sets together with a set of proofs that all essential rules are derivable. We also introduce quotient inductive types (QITs) i.e.\ quotient sets defined using higher inductive types.
 


In \autoref{dq}, we introduce one of our original achievements, the
definable quotient algebraic structures. A quotient structure consists of a set definition servers as the "quotient" type and a normalisation function with several essential functions and conditions.
For quotients that are definable inductively, a new type former of quotient seems unnecessary.
As a example, integers can be encoded as the
quotients types of paired natural numbers over the equivalence
relation that two pairs are equal if they represent the same
subtraction. Integers can also be defined inductive as a set. Definable quotient structures abstract the relation between these two representations and provides a flexible way of conversions. It can be seen as 
a simulation of the quotient types.


In \autoref{rl}, we discuss quotients that are undefinable as an inductive type with a normalisation mapping, such as the real numbers, finite multisets and partiality monads. We present a proof of the undefinability of real numbers via normalisation based on meta-theoretical assumptions. The proof was mainly conducted by Nicolai Kraus and amended by the author.

In \autoref{models}, we discussed several models where quotient types are available. We present an implementation on the setoid model approach to encode
extensional concepts. The work is mainly extending the setoid model
done by Altenkirch in \cite{alti:lics99} to
quotient types. Some other models including models of \hott are also mentioned.


In \autoref{wog}, we present a new formalisation of the syntax of weak
  $\omega$-groupoids in Agda using heterogeneous equality. We show how
  to recover basic constructions on $\omega$-groupoids using
  suspension and replacement. In particular we show that any type
  forms a groupoid and we outline how to derive higher dimensional
  composition. We present a possible semantics using globular sets and
  discuss the issues which arise when using globular types instead. The work in the chapter has been published in \cite{LFMTP14} together with Thorsten Altenkich and Ond\v{r}ej Ryp\'{a}\v{c}ek.


In appendix, we present Agda code for our implementations in \autoref{dq}, \autoref{models} and \autoref{wog}, which are too complicated to show in text.
