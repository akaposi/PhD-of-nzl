\chapter{Introduction}

\mltt (Type Theory) is a type theory which serves as a foundation of constructive mathematics and is also a dependently typed programming language. Different from other foundations like set theory, it is not based on predicate logic but internalises the BHK interpretation of intuitionistic logic through the Curry-Howard isomorphism. It identifies a proposition with a type such that a proof of it is a term of that type. 
As a programming language, it means that we can express a specification as a type of the programs satisfying it.
Moreover, one can write programs and reason about them in it, thus write certified programs. There are a number of implementations of it, such as NuPRL, LEGO, Coq, Agda, Epigram, Pi-Sigma etc.


As a foundation of constructive mathematics, there have been a lot of \maths formalised in it, for example a formal proof of the four-colour theorem by Georges Gonthier \cite{gonthier08ams} \footnote{More formalised mathematics can be found in \cite{sbfm}}. The formalisation of mathematics in programming languages not only provides mathematicians a powerful theorem prove to constructively prove theorems with computerised verification, but also helps in program specification and reasoning. 




However, most of the implementations are based on the \emph{intensional} variant of \mltt where \emph{propositional equality} is different to \emph{definitional equality}. The propositional equalities induced by the identity type are intensional such that extensionally equal terms like point-wise equal functions, logically equivalent propositions are not propositionally equal. \itt is preferable because type checking is decidable so that it has good computational behaviours. However the lack of extensional concepts may hinder the formalisation of mathematics in current implementations like Agda, for example functional extensionality and quotient types.







A \emph{quotient type} is a type obtained by redefining equality of an existing type with a given equivalence relation which is not supported. This thesis mainly studies quotient types from a discussion on the definability of quotients via a normalisation to models where quotient types are available. Most of the work is conducted in Agda.







In NuPRL as a implementation of \ett, there is a quotient operator which builds a new type from a given type and an equivalence relation on it \cite{DBLP:books/daglib/0068834}. However it is impossible to recover the witness of the equality between two equal elements in quotient type in general \cite{nog:02}.
Because of the computational property of \itt, we would like to have quotient types in \itt as well.








\section{Equality}

We first learn equality for numbers in \maths. Generally speaking, it
expresses the sameness of two mathematical objects such as numbers or sets.
$1+2=3$ tells us the mathematical object calculated from $1+2$ is the
same as $3$.

From ages before, mathematicians are arguing about the correct way to
characterise equality. The most common idea is that equality is just
identity. Leibniz's law can be seen as a "definition" of
equality:

Given any $x$ and $y$, $x = y$ if, given any predicate $P$, $P(x)$ if and only
if $P(y)$.

In Type Theory, the encoding of equality is also contentious. Considering a variety of issues, there are
several notions of equality in type theory.
We can compare whether two types are equal or two terms are equal. If two
expressions can be computed to the same object then we claim they are
 \emph{definitionally} equal.  
 We can also internalise definitional equality by defining \emph{identity types}. An inhabitant of identity type is an evidence of the \emph{propositional equality} between two terms or types are equal and is usually denoted as refl. 

In \ett, propositional equality is identified with definitional equality which makes definitional equality undecidable and then type checking undecidable. However in \itt, they are different. Propositional equality is only induced by identity types which captures the definitional equality of terms or types. The equality of functions are usually judged extensionally, and the point-wise equalities of functions are not captured by identity types. For example, $\lambda n \to n$ and $\lambda n \to n + 0$ are intensionally different considering $n+0$ does not reduce to $n$ in the the usual definition of addition.
The problem arises from the computational difficulties. A type checker can easily decide whether two
values of inductive types are the same, but not whether two functions
are extensionally equal. Even suppose we encode the method to compute
the definitional equality of the outputs for each given input, it can
only decide the equality for finite types.

There are also many other extensional concepts missing as Martin Hofmann pointed out in \cite{hof:phd}.Quotient types is one of them and is essential for construction of \maths and programs.

% Because there is no attached equality for each types other than trivial identity, it is
% necessary to use a different model of type theory in which types are
% equipped with equalities.

\section{Quotient types}

In \maths, a quotient set is a set of the equivalence classes of
some equivalence relation on another set. Abstracted from this
concept, there are also quotient groups, quotient categories etc.

Naturally, given a type and an equivalence relation, one would expect a \emph{quotient type}
which can be intuitively thought as a new type generated by redefining equality on original type with the given equivalence relation.
However such a type former does not exist in current formulation of \itt because there is no attached equivalence on each type except definitional equality which can not be changed. Usually a setoid which consists of a set and an equivalence relation on it is used to represent quotients. However, this will not be ideal because we have to redefine everything on sets for setoids.

Some quotients can be defined inductively without using quotient types. 
For example integers can be represented as pairs of natural numbers which are equivalent if the subtraction of first number from the second are equal.  This setoid gives rise to a quotient, but the set of integers can also be inductively. An algebraic structure of quotients consists of the set definition and a normalisation mapping from the "base" type to the "quotient" type and essential properties and operations. Such a framework provides a flexible approach to lifting functions and proofs from base types to quotient types. The simulation sounds superfluous at first, but in practice, it is much easier to define
functions for the base types (because usually they have a bundle of
library codes) on underlying level, and the ''quotient types'' has no
redundant on the surface level.

However not all types are definable with a normalisation functions, for example real numbers, multisets etc. Thus quotient types are essential for encoding of these important constructions.

If a type is treat like a set, it seems impossible to enforce a equality on it. Therefore, it becomes more and more popular to interpret types as structure objects like setoids, groupoids and \wog which internalising equality as definitions. 

There are several different models of Type Theory where extensional concepts including quotient types are derivable.

\begin{itemize}

\item Altenkirch's setoid model. Altenkirch \cite{alti:lics99} proposed an intensional setoid model
with a proof-irrelevant universe of propositions \textbf{Prop} which
is closed under $\Pi$ and $\Sigma$. It interprets types as setoids
such that quotient types are just setoids whose equality is replaced
by given equivalence relation.

\item Hofmann and Streicher's groupoid model. They give a model in which
types are interpreted as groupoids. In this model, propositional
equality is interpreted as isomorphism and $K$ eliminator for equality
types is unavailable. 

\item Homotopy type theory and \wog model. It can be seen as a
generalisation of the groupoid model above. Types are interpreted as
higher groupoids.

\end{itemize}

\section{Methods}




\section{Programming in Agda}

In this thesis we use Agda to implement our constructions in \itt. 
Agda is a dependently typed, functional programming language, which is
based on the intensional version of \mltt. It is mainly developed by
Ulf Norell, Nils Anders Danielsson, and Andreas Abel.
It is a functional language like Haskell, but has dependent types. It has dependent pattern
matching, type checker, coverage checker and termination checker. It
supports a bundle of schema of defining data types such as inductive, inductive-recursive, mutually inductive,
coinductive types. Its syntax is close to Haskell, in addition, it has
unicode support and mixfix operators. All these features including
type checker, unicode typing and interactive programming present in
its Emacs interface. It is quite popular in the field of mathematical reasoning and programs
verifications. Many researchers implement their work of type theory in
Agda. It is also one of the popular languages in the community of the recently
developed field \hott and the library of \hott is under construction.
The adequate reasoning library code also helps in writing certified programs.

In \autoref{bg} we present a brief introduction to it for someone
who meet this language for the first time. In \autoref{dq} we use Agda to implement our definable quotient algebraic structures. In \autoref{models} we build a category with families of setoids in Agda. In \autoref{wog}, we implement a syntactic construction of \wog.

Agda wiki\cite{agdawiki:main} is a good reference to it and there are
several good tutorials to Agda for example Ulf Norell's
\cite{tutorial}, Ana Bove, Peter Dybjer, and Ulf Norell's \cite{bove2009brief}.



\section{Applications}


Quotient types are very useful or even essential in some formalisation of mathematics. 

For quotients which are definable without quotient types, it is
possible to relate them with the setoid representation within some
algebraic structures. 
These structures of definable quotients can facilitate the
manipulation of some complicated types which
are semantically quotients of some other setoids. It can be seen as a
simulation of quotient types in a pure \itt. Even though it does not
automatically provide some constructions, it is still helpful because
of the comparative ease of reasoning about setoids and flexible
conversion between the setoids and sets.


In a type theory with quotient type, real numbers can be encoded as
the Cauchy sequences with an equivalence relation.
From programming perspective,  it also provides more algebraic
datatypes and enable us to reason about infinite types and
semantics-based verification of concurrent programs \cite{hof:phd}.


\section{Overview}


%compact, comprehensive Overview: Add overview of each part, as much as you can, and compact



In \autoref{bg}, we introduce Type Theory as background of our study. We provide a brief
history of it and some basic rules of it as a formal system.
We also introduce a dependent functional
programming language called Agda which is designed based on Type Theory.
we also discuss the new area between \maths and
computer science -- \hott. Quotient types can be encoded in \hott simply.


In \autoref{qt}, we discuss quotient types which is the topic of
this thesis in detail. We explain what is a quotient type by a set of rules  together with a categorical explanation.


In \autoref{dq}, we start introducing one of our achievements, the
definable quotient algebraic structures. A quotient structure consists of a set definition servers as the "quotient" type and a normalisation function with several essential functions and conditions.
For quotients that are definable inductively, a new type former of quotient seems unnecessary.
As a example, integers can be encoded as the
quotients types of paired natural numbers over the equivalence
relation that two pairs are equal if they represent the same
subtraction. Integers can also be defined inductive as a set. Definable quotient structures abstract the relation between these two representations and provides a flexible way of conversions. It can be seen as 
a simulation of the quotient types.


In \autoref{rl}, we discuss quotients that are undefinable as a inductive set with a normalisation mapping, such as the real numbers, finite multisets and partiality monads. We present a proof of the undefinability of real numbers via normalisation based on meta-theoretical assumptions. The proof is made by Nicolai Kraus and the author.

In \autoref{models}, we discussed several models where quotient types are available. We present an implementation on the setoid model approach to encode
extensional concepts. The work is mainly extending the setoid model
done by Altenkirch in \cite{alti:lics99} to
quotient types. Some other models including models of \hott are also mentioned.


In \autoref{wog}, we present a new formalisation of the syntax of weak
  $\omega$-groupoids in Agda using heterogeneous equality. We show how
  to recover basic constructions on $\omega$-groupoids using
  suspension and replacement. In particular we show that any type
  forms a groupoid and we outline how to derive higher dimensional
  composition. We present a possible semantics using globular sets and
  discuss the issues which arise when using globular types instead. The work in the chapter has been published in \cite{LFMTP14} together with Thorsten Altenkich and Ond\v{r}ej Ryp\'{a}\v{c}ek.


Finally, we present the complete Agda code for our implementations in \autoref{dq}, \autoref{models} and \autoref{wog}.
