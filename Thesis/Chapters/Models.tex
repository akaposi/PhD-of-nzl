%\chapter{Homotopy Type Theory and higher inductive types}\label{HITs}


\chapter{Models of Type Theory}\label{models}


To introduce extensional concepts in \itt, one can simply postulate them as axioms but the good computational properties of Type Theory will be lost. Therefore it is crucial that these axioms have 
a computational interpretation. One solution is to construct a model of theses axioms in \itt or in a constructive setting such that extensional concepts like functional extensionality, quotient types, univalence are automatically derivable. Types as usually interpreted as structured objects rather than sets, and the model is named after the structured objects, for example, setoid, groupoid, simplicial sets. 

% We can postulate these axioms but then we can not keep the good computational properties. Therefore it is crucial that axioms have a computational interpretation. One solution is 


In this chapter, we discuss several models of extensional concepts, and mainly introduce Altenkirch's setoid model. We build a category with families of setoids to accommodate the types theory described in
\cite{alti:lics99}  so that it is possible to define quotient types following Martin Hofmann's Paper \cite{hof:95:sm}. We also briefly introduce several models of \hott where quotient types are also available.

\section{The setoid model}


One of the intensional models of extensional concepts inside \itt is setoid model where types are interpreted as setoids. Martin Hofmann has studied this approach in \cite{hof:phd}, but a naive version of setoid model does not satisfy all definitional equalities. The version in \cite{DBLP:conf/tlca/Hofmann95} which is a model for quotient types does not allow large eliminations (defining a dependent type by recursion).

Altenkirch then proposes \cite{alti:lics99} a different approach in which the setoid model serves as the metatheory.
He uses an extension of \itt by a universe of propositions $\Prop$ as metatheory, and the $\eta$-rules for $\Pi$-types and $\Sigma$-types hold. 

%In \cite{DBLP:conf/csl/Hofmann94}, Martin Hofmann first proposes a setoid model where types are interpreted as setoids, and the function are equivalence preserving. Cateogically, a setoid is a special groupoid where every isomorphism is unique, and then functions between two setoids are just functors.


\infrule[proof-irr]{\Gamma \vdash P : \Prop \andalso \Gamma \vdash p,q : P}{\Gamma \vdash p \equiv q : P}



 $\Prop$ only contains "propositional'' sets which has at most one
inhabitant. Notice that it is not a definition of types, which means
that we cannot conclude a type is of type \textbf{Prop} if we have a
proof that all inhabitants of it are definitionally equal.

The propositional universe is closed under $\Pi$-types and $\Sigma$-types:



\infrule[$\Pi$-Prop]{\Gamma \vdash A : \Set \andalso \Gamma, x : A \vdash P : \Prop}
{\Gamma \vdash \Pi~ (x : A) \to P : \Prop}



\infrule[$\Sigma$-Prop]{\Gamma \vdash P : \Prop \andalso \Gamma,x : P \vdash Q : \Prop}
{\Gamma \vdash \Sigma ~(x : P) ~ Q : \Prop}


The metatheory is proved {\cite{alti:lics99}} to be:

\begin{itemize}
\item Decidable. The definitional equality is decidable, hence type checking is decidable.

\item Consistent. Not all types inhabited and not all well typed definitional equality holds. 

\item Adequate. All terms of type $\N$ are reducible to numerals.
\end{itemize}


And then Altenkirch construct an intensional model within this metatheory which is decidable and adequate, functional extensionality is inhabited and it permits large elimination. 


% Within this type theory, introduction of quotient types is straightforward. 
%The set of functions are naturally quotient types, the hidden information is the definition of the functions and the equivalence relation is the functional extensionality.



\begin{remark}[The setoid model is not LCCC]
This model is different to a setoid model as an E-category, for instance
the one introduced by Hofmann \cite{hofmann1995interpretation}. An E-category is a category equipped with
an equivalence relation for homsets. To distinguish them, we call this
category \textbf{E-setoids}.  All morphisms of \textbf{E-setoids}
gives rise to types and they are Cartesian closed, namely it is a a locally
Cartesian closed category (LCCC). However not all morphisms in our category of setoids give rise to types which means that it is not an LCCC. Every LCCC can serve as a model for categories with
families but not every category with families has to be a LCCC. 

This setoid model is the category of setoids \textbf{Std} which is a full subcategory of \textbf{Gpd} (the category of small groupoids). Every object of \textbf{Gpd} whose all homsets contain at most one morphism are in this subcategory. Altenkirch and Klaus \cite{Altenkirch12setoidsare} prove that both \textbf{Gpd} and \textbf{Std} are Cartesian closed but not locally Cartesian closed.
\end{remark}


\section{Category with families}


The setoid model is defined as categories with families as introduced by Dybjer \cite{Dyb:96} and Hofmann
\cite{hof:97}. The object theory is decidable because its definitional equalities are interpreted by definitional equality in the metatheory which is decidable.

We construct the setoid model in Agda together with some basic types including quotient types. We will introduce our implementation with real Agda code. We omit some unnecessary part of the code, but the complete code can be found in \autoref{app:cwf}.


\subsection{Metatheory}

We first postulate axioms for metatheory. We define \textbf{HProp} which serves as the proof-irrelevant universe of propositions although it is not exactly the same as the \textbf{Prop} universe which is judgemental. A set can only be claimed in $\textbf{Prop}$. However any set behaves like a proposition can be encoded as \textbf{HProp} but not in \textbf{Prop}. Another difference is that the uniqueness of identity proof is propositional which complicates the proving.

\begin{code}\>\<%
\\
\>\AgdaKeyword{record} \AgdaRecord{HProp} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{constructor} \AgdaInductiveConstructor{hProp}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{prf} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{Uni} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{p} \AgdaBound{q} \AgdaSymbol{:} \AgdaBound{prf}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{p} \AgdaDatatype{≡} \AgdaBound{q}\<%%
\\
\>\AgdaKeyword{open} \AgdaModule{HProp} \AgdaKeyword{public} \AgdaKeyword{renaming} \AgdaSymbol{(}prf \AgdaSymbol{to} <\_>\AgdaSymbol{)}\<%
\end{code}

We also define basic propositions $\top$ and $\bot$ and the universal and existential quantifier, namely it is closed under $\Pi$-types and $\Sigma$-types. Notice that, the $\Pi$-closure requires functional extensionality which can be postulated since $\Pi$-closure is itself an axiom in this model.

\begin{code}\>\<
%
\\
\>\AgdaFunction{∀'} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)(}\AgdaBound{P} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaRecord{HProp}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaRecord{HProp}\<%
\\
\>\AgdaFunction{∀'} \AgdaBound{A} \AgdaBound{P} \AgdaSymbol{=} \AgdaInductiveConstructor{hProp} \AgdaSymbol{((}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{P} \AgdaBound{x} \AgdaFunction{>}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{ext} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{Uni} \AgdaSymbol{(}\AgdaBound{P} \AgdaBound{x}\AgdaSymbol{)))}\<%
\>\<\end{code}

Notice that we use a syntactic abbreviation $<\_>$ for projection of proof in $\textbf{HProp}$. Moever to avoid conficts with existing code, we sometimes add a $'$ symbol in names. 

The $\eta$-rules for both $\Pi$-types and $\Sigma$-types automatically holds in Agda. Finally, the metatheory which is extended is proved to be decidable, consistent and adequate as mentioned earlier.

\subsection{Category of setoids}

Then setoids can be defined as follows.

\begin{code}\>\<%
\\
\>\AgdaKeyword{record} \AgdaRecord{HSetoid} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{Carrier} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{\_≈h\_} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaBound{Carrier} \AgdaSymbol{→} \AgdaBound{Carrier} \AgdaSymbol{→} \AgdaRecord{HProp}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{refl} \<[12]%
\>[12]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{x} \AgdaSymbol{:} \AgdaBound{Carrier}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{x} \AgdaBound{≈h} \AgdaBound{x} \AgdaFunction{>}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{sym} \<[12]%
\>[12]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaBound{Carrier}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{x} \AgdaBound{≈h} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{y} \AgdaBound{≈h} \AgdaBound{x} \AgdaFunction{>}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{trans} \<[12]%
\>[12]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{:} \AgdaBound{Carrier}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{x} \AgdaBound{≈h} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{y} \AgdaBound{≈h} \AgdaBound{z} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{x} \AgdaBound{≈h} \AgdaBound{z} \AgdaFunction{>}\<%
\\
\>\<\end{code}

Notice that since \textbf{HProp} is not considered as a sort of types, we simplified the definition by defining the laws non-propositionally, e.g.\ reflexivity.



Functors between setoids can be given as

\begin{code}
\\
\>\AgdaKeyword{record} \AgdaRecord{\_⇉\_} \AgdaSymbol{(}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaRecord{HSetoid}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{fn} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{A} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{B} \AgdaFunction{∣}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{resp} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{A} \AgdaFunction{∣}\AgdaSymbol{\}} \AgdaSymbol{→} \<[27]%
\>[27]\<%
\\
\>[4]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]} \AgdaBound{x} \AgdaFunction{≈} \AgdaBound{y} \AgdaSymbol{→} \<[25]%
\>[25]\<%
\\
\>[4]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]} \AgdaBound{fn} \AgdaBound{x} \AgdaFunction{≈} \AgdaBound{fn} \AgdaBound{y}\<%
\\
\end{code}

%大略介绍thorsten的model和martin hofmann的Quotient types就可以了

With identity morphisms, composition operator and all other ingredients we can build the category of setoids of $\textbf{Std}$.


\subsection{Categories with families}

Usually a a categories with families is defined as follows:

\begin{definition}\label{cwf:def}
\textbf{Categories with families}.

\begin{itemize}
\item A category $\mathsf{C}$ with a terminal object where objects are contexts and morphisms are substitutions.

\item A functor $F : \mathsf{C}^{op} \to Fam$ where $Fam$ is a category of families whose objects are dependent products and morphisms are naturally pairs of functions. The types and terms are projections of this functor: given an object $\Gamma : \mathsf{C}$, we usually write $F ~ \Gamma \defeq \Sigma A : \text{Ty} ~\Gamma, \text{Tm} ~\Gamma ~ A)$, and the substitution of types and terms are just contained in the morphism part of this functor. 

\item A comprehension of $\Gamma$ and $A : \text{Ty}~ \Gamma$ written as $\Gamma, A$ is a construction of a new object in $\mathsf{C}$ such that it expresses the extension of contexts.
\end{itemize}

\end{definition}

In the setoid model, both the category $\mathsf{C}$ and $Fam$ are not based on sets, but setoids.
The category of contexts is just $\textbf{Std}$,

\begin{code}
%
\\
\>\AgdaFunction{Con} \AgdaSymbol{=} \AgdaRecord{HSetoid}\<%
\\
\end{code}

The second ingredient is the functors, namely types and terms.
Given a context $\Gamma$, types of the context can be defined as functors from $\Gamma \to \textbf{Std}$ since a context is a setoid which are special cases of groupoids. However setoids are not implemented as categories, we manually build \emph{functors} which respects the internal equivalence of setoids:

\begin{code}%
\\
\>\AgdaKeyword{record} \AgdaRecord{Ty} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{fm} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaRecord{HSetoid}\<%
\\
%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{substT} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{\}} \AgdaSymbol{→} \<[29]%
\>[29]\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]} \AgdaBound{x} \AgdaFunction{≈} \AgdaBound{y} \AgdaSymbol{→}\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{∣} \AgdaBound{fm} \AgdaBound{x} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{fm} \AgdaBound{y} \AgdaFunction{∣}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{subst*} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]} \AgdaBound{x} \AgdaFunction{≈} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{\{}\AgdaBound{a} \AgdaBound{b} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{fm} \AgdaBound{x} \AgdaFunction{∣}\AgdaSymbol{\}} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{[} \AgdaBound{fm} \AgdaBound{x} \AgdaFunction{]} \AgdaBound{a} \AgdaFunction{≈} \AgdaBound{b} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{[} \AgdaBound{fm} \AgdaBound{y} \AgdaFunction{]} \AgdaBound{substT} \AgdaBound{p} \AgdaBound{a} \AgdaFunction{≈} \AgdaBound{substT} \AgdaBound{p} \AgdaBound{b}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{refl*} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀(}\AgdaBound{x} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{)(}\AgdaBound{a} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{fm} \AgdaBound{x} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \<[42]%
\>[42]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{[} \AgdaBound{fm} \AgdaBound{x} \AgdaFunction{]} \AgdaBound{substT} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]refl} \AgdaBound{a} \AgdaFunction{≈} \AgdaBound{a}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{trans*} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{\{}\AgdaBound{p} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]} \AgdaBound{x} \AgdaFunction{≈} \AgdaBound{y}\AgdaSymbol{\}\{}\AgdaBound{q} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]} \AgdaBound{y} \AgdaFunction{≈} \AgdaBound{z}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaBound{a} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{fm} \AgdaBound{x} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \<[30]%
\>[30]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{[} \AgdaBound{fm} \AgdaBound{z} \AgdaFunction{]} \AgdaBound{substT} \AgdaBound{q} \AgdaSymbol{(}\AgdaBound{substT} \AgdaBound{p} \AgdaBound{a}\AgdaSymbol{)} \AgdaFunction{≈} \AgdaBound{substT} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]trans} \AgdaBound{p} \AgdaBound{q}\AgdaSymbol{)} \AgdaBound{a}\<%
\\
\end{code}

Notice that there is a problem arising from the fact that $HProp$ is not definitionally proof-irrelevant which means that the substitution here is not automatically proof-irrelevant. Therefore we have to define a series of proof-irrelevance lemmas to help construction and reasoning which are omitted here.

Terms follows naturally as families of elements in the underlying set of types indexed by $\gamma : \Gamma$ which respects the equality as well:


\begin{code}
%
\\
\>\AgdaKeyword{record} \AgdaRecord{Tm} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{constructor} \AgdaInductiveConstructor{tm:\_resp:\_}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{tm} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{x} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{x} \AgdaFunction{∣}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{respt} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{\}} \AgdaSymbol{→} \<[30]%
\>[30]\<%
\\
\>[4]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]} \AgdaBound{x} \AgdaFunction{≈} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{→} \<[30]%
\>[30]\<%
\\
\>[4]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{y} \AgdaFunction{]} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst} \AgdaBound{p} \AgdaSymbol{(}\AgdaBound{tm} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{≈} \AgdaBound{tm} \AgdaBound{y}\<%
\\
\end{code}


Due to the record type mechanism in Agda, given a type $A : \text{Ty} ~\Gamma$, one has to write $\text{substT} ~A$ to use the field. For readability, we adopt a better syntax using renaming of fields to highlight the precise types or terms in the style of $\text{[} ~A ~\text{]substT}$ , but the detailed code is also omitted here. Indeed, an example can be found in the above code where we already adopt the syntax style for internal equivalence of setoids.


The substitution of types can be defined simply by composing the underlying objects of types and context morphisms:

\begin{code}
%
\\
\>\AgdaFunction{\_[\_]T} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Ty} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaRecord{⇉} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaRecord{Ty} \AgdaBound{Γ}\<%
\\
\>\AgdaFunction{\_[\_]T} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}} \AgdaBound{A} \AgdaBound{f}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{\{} \AgdaField{fm} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaFunction{fm} \AgdaFunction{∘} \AgdaFunction{fn}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{;} \AgdaField{substT} \AgdaSymbol{=} \AgdaFunction{substT} \AgdaFunction{∘} \AgdaFunction{resp}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{;} \AgdaField{subst*} \AgdaSymbol{=} \AgdaFunction{subst*} \AgdaFunction{∘} \AgdaFunction{resp}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{;} \AgdaField{refl*} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaBound{\_} \AgdaSymbol{→} \AgdaFunction{subst-pi'}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{;} \AgdaField{trans*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaSymbol{→} \AgdaFunction{[} \AgdaFunction{fm} \AgdaSymbol{(}\AgdaFunction{fn} \AgdaSymbol{\_)} \AgdaFunction{]trans} \AgdaSymbol{(}\AgdaFunction{trans*} \AgdaSymbol{\_)} \AgdaFunction{subst-pi}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{\}}\<%
\\
\>[2]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaKeyword{where} \<[11]%
\>[11]\<%
\\
\>[5]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaKeyword{open} \AgdaModule{Ty} \AgdaBound{A}\<%
\\
\>[5]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaKeyword{open} \AgdaModule{\_⇉\_} \AgdaBound{f}\<%
\\
\end{code}

The substitution of terms are similarly natural so that we omit it here.


To complete the categories with families, the terminal object is just empty context
\begin{code}
%
\\
\>\AgdaFunction{●} \AgdaSymbol{:} \AgdaRecord{HSetoid}\<%
\\
\>\AgdaFunction{●} \<[4]%
\>[4]\AgdaSymbol{=} \AgdaKeyword{record} \AgdaSymbol{\{}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaField{Carrier} \AgdaSymbol{=} \AgdaRecord{⊤}\AgdaSymbol{;}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaField{\_≈h\_} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaBound{\_} \AgdaSymbol{→} \AgdaFunction{⊤'}\AgdaSymbol{;}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaField{refl} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaInductiveConstructor{tt}\AgdaSymbol{;}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaField{sym} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaSymbol{→} \AgdaInductiveConstructor{tt}\AgdaSymbol{;}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaField{trans} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaBound{\_} \AgdaSymbol{→} \AgdaInductiveConstructor{tt} \AgdaSymbol{\}}\<%
\\
\end{code}

and context comprehension is encoded as follows:

\begin{code}
%
\\
\>\AgdaFunction{\_\&\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaRecord{Ty} \AgdaBound{Γ} \AgdaSymbol{→} \AgdaRecord{HSetoid}\<%
\\
\>\AgdaBound{Γ} \AgdaFunction{\&} \AgdaBound{A} \AgdaSymbol{=} \AgdaKeyword{record} \<[15]%
\>[15]\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{\{} \AgdaField{Carrier} \AgdaSymbol{=} \AgdaRecord{Σ[} \AgdaBound{x} \AgdaRecord{∶} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣} \AgdaRecord{]} \AgdaFunction{∣} \AgdaFunction{fm} \AgdaBound{x} \AgdaFunction{∣}\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{;} \AgdaField{\_≈h\_} \<[15]%
\>[15]\AgdaSymbol{=} \AgdaSymbol{λ\{(}\AgdaBound{x} \AgdaInductiveConstructor{,} \AgdaBound{a}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{→} \<[37]%
\>[37]\<%
\\
\>[7]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaFunction{Σ'[} \AgdaBound{p} \AgdaFunction{∶} \AgdaBound{x} \AgdaFunction{≈h} \AgdaBound{y} \AgdaFunction{]} \AgdaFunction{[} \AgdaFunction{fm} \AgdaBound{y} \AgdaFunction{]} \AgdaFunction{substT} \AgdaBound{p} \AgdaBound{a} \AgdaFunction{≈h} \AgdaBound{b}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{;} \AgdaField{refl} \<[15]%
\>[15]\AgdaSymbol{=} \AgdaFunction{refl} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaFunction{refl*} \AgdaSymbol{\_} \AgdaSymbol{\_)}\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{;} \AgdaField{sym} \<[15]%
\>[15]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{(}\AgdaBound{p} \AgdaInductiveConstructor{,} \AgdaBound{q}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaBound{p}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \<[40]%
\>[40]\<%
\\
\>[7]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaFunction{[} \AgdaFunction{fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \AgdaSymbol{(}\AgdaFunction{subst*} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{fm} \AgdaSymbol{\_} \AgdaFunction{]sym} \AgdaBound{q}\AgdaSymbol{))} \AgdaFunction{trans-refl} \AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{;} \AgdaField{trans} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{(}\AgdaBound{p} \AgdaInductiveConstructor{,} \AgdaBound{q}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaFunction{trans} \AgdaBound{p} \AgdaBound{m} \AgdaInductiveConstructor{,} \<[29]%
\>[29]\<%
\\
\>[0]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaFunction{[} \AgdaFunction{fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{fm} \AgdaSymbol{\_} \AgdaFunction{]sym} \AgdaSymbol{(}\AgdaFunction{trans*} \AgdaSymbol{\_))}\<%
\\
\>[0]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaSymbol{(}\AgdaFunction{subst*} \AgdaSymbol{\_} \AgdaBound{q}\AgdaSymbol{))} \AgdaBound{n} \AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaKeyword{where} \<[13]%
\>[13]\<%
\\
\>[7]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaKeyword{open} \AgdaModule{HSetoid} \AgdaBound{Γ}\<%
\\
\>[7]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaKeyword{open} \AgdaModule{Ty} \AgdaBound{A} \<[23]%
\>[23]\<%
\\
\end{code}

Since the context $\Gamma$ and type $A$ as record types are opened in the scope, we can unambiguously use fields such as $fm$ and $subst*$.

\subsection{$\Pi$-types and some basic types}

Dependent function types $\Pi$-types are essential in a dependent theory and serves as a fundamental test case of the type construction in the setoid model. 
The following code is an example of the complicated and nearly unreadable encoding of types in this model, but in fact it just follows the reasoning and construction in \cite{alti:lics99} with minor adaption. Later explanations where detailed real codes is not shown can be found in \autoref{app:cwf}.

\begin{code}
%
\\
\>\AgdaFunction{Π} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\AgdaSymbol{)(}\AgdaBound{B} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaFunction{\&} \AgdaBound{A}\AgdaSymbol{))} \AgdaSymbol{→} \AgdaRecord{Ty} \AgdaBound{Γ}\<%
\\
\>\AgdaFunction{Π} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{=} \AgdaKeyword{record} \<[19]%
\>[19]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{\{} \AgdaField{fm} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaKeyword{let} \AgdaBound{Ax} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{x} \AgdaKeyword{in}\<%
\\
\>[0]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaKeyword{let} \AgdaBound{Bx} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{,} \AgdaBound{a}\AgdaSymbol{)} \AgdaKeyword{in}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaKeyword{record}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{\{} \AgdaField{Carrier} \AgdaSymbol{=} \AgdaRecord{Σ[} \AgdaBound{fn} \AgdaRecord{∶} \AgdaSymbol{((}\AgdaBound{a} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Ax} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{Bx} \AgdaBound{a} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaRecord{]}\<%
\\
\>[9]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaSymbol{((}\AgdaBound{a} \AgdaBound{b} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Ax} \AgdaFunction{∣}\AgdaSymbol{)}\<%
\\
\>[9]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Ax} \AgdaFunction{]} \AgdaBound{a} \AgdaFunction{≈} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[9]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaFunction{[} \AgdaBound{Bx} \AgdaBound{b} \AgdaFunction{]} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]refl} \AgdaInductiveConstructor{,} \<[54]%
\>[54]\<%
\\
\>[9]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaFunction{[} \AgdaBound{Ax} \AgdaFunction{]trans} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]refl*} \AgdaBound{x} \AgdaBound{a}\AgdaSymbol{)} \AgdaBound{p}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{fn} \AgdaBound{a}\AgdaSymbol{)} \AgdaFunction{≈} \AgdaBound{fn} \AgdaBound{b}\AgdaSymbol{)} \<[68]%
\>[68]\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{\_≈h\_} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaSymbol{λ\{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaSymbol{\_)} \AgdaSymbol{(}\AgdaBound{g} \AgdaInductiveConstructor{,} \AgdaSymbol{\_)} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{21}{}\<[21]%
\>[21]\AgdaFunction{∀'[} \AgdaBound{a} \AgdaFunction{∶} \AgdaSymbol{\_} \AgdaFunction{]} \AgdaFunction{[} \AgdaBound{Bx} \AgdaBound{a} \AgdaFunction{]} \AgdaBound{f} \AgdaBound{a} \AgdaFunction{≈h} \AgdaBound{g} \AgdaBound{a} \AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{refl} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{Bx} \AgdaBound{a} \AgdaFunction{]refl} \<[40]%
\>[40]\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{sym} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{f} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{Bx} \AgdaBound{a} \AgdaFunction{]sym} \AgdaSymbol{(}\AgdaBound{f} \AgdaBound{a}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{trans} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{f} \AgdaBound{g} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{Bx} \AgdaBound{a} \AgdaFunction{]trans} \AgdaSymbol{(}\AgdaBound{f} \AgdaBound{a}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{g} \AgdaBound{a}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{\}}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{;} \AgdaField{substT} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{}\AgdaBound{x}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{y}\AgdaSymbol{\}} \AgdaBound{p} \<[25]%
\>[25]\<%
\\
\>[0]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaSymbol{→} \AgdaKeyword{let} \AgdaBound{y2x} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]sym} \AgdaBound{p}\AgdaSymbol{)} \AgdaBound{a} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaKeyword{let} \AgdaBound{x2y} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst} \AgdaBound{p} \AgdaBound{a} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaKeyword{let} \AgdaBound{p'} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]trans-refl} \AgdaKeyword{in}\<%
\\
\>[-11]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{λ\{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaBound{rsp}\AgdaSymbol{)} \AgdaSymbol{→} \<[28]%
\>[28]\<%
\\
\>[0]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst} \AgdaSymbol{(}\AgdaBound{p} \AgdaInductiveConstructor{,} \AgdaBound{p'} \AgdaBound{a}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{f} \AgdaSymbol{(}\AgdaBound{y2x} \AgdaBound{a}\AgdaSymbol{)))}\<%
\\
\>[0]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaInductiveConstructor{,} \<[49]%
\>[49]\<%
\\
\>[0]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{q} \AgdaSymbol{→} \<[26]%
\>[26]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaKeyword{let} \AgdaBound{a'} \AgdaSymbol{=} \AgdaBound{y2x} \AgdaBound{a} \AgdaKeyword{in} \<[34]%
\>[34]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaKeyword{let} \AgdaBound{b'} \AgdaSymbol{=} \AgdaBound{y2x} \AgdaBound{b} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaKeyword{let} \AgdaBound{q'} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst*} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]sym} \AgdaBound{p}\AgdaSymbol{)} \AgdaBound{q} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaKeyword{let} \AgdaBound{H} \AgdaSymbol{=} \AgdaBound{rsp} \AgdaBound{a'} \AgdaBound{b'} \AgdaBound{q'} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaKeyword{let} \AgdaBound{r} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{\&} \AgdaBound{A} \AgdaFunction{]} \AgdaSymbol{(}\AgdaBound{x} \AgdaInductiveConstructor{,} \AgdaBound{b'}\AgdaSymbol{)} \AgdaFunction{≈} \AgdaSymbol{(}\AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)}
                    r \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{p} \AgdaInductiveConstructor{,} \AgdaBound{p'} \AgdaBound{b}\AgdaSymbol{)} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaKeyword{let} \AgdaBound{pre} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst*} \AgdaBound{r} \AgdaBound{H} \AgdaKeyword{in}\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{(}\AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaFunction{]trans} \<[41]%
\>[41]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]trans*} \AgdaSymbol{\_)} \<[48]%
\>[48]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{(}\AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaFunction{]trans} \<[42]%
\>[42]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst-pi} \<[30]%
\>[30]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{(}\AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaFunction{]trans} \<[42]%
\>[42]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{(}\AgdaBound{y} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaFunction{]sym} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]trans*} \AgdaSymbol{\_))} \<[57]%
\>[57]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaBound{pre}\AgdaSymbol{))} \<[23]%
\>[23]\<%
\\
\>[15]\AgdaIndent{16}{}\<[16]%
\>[16]\AgdaSymbol{)} \<[22]%
\>[22]\<%
\\
\>[-12]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{;} \AgdaField{subst*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaBound{q} \AgdaBound{\_} \AgdaSymbol{→} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst*} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaBound{q} \AgdaSymbol{\_)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{;} \AgdaField{refl*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{}\AgdaBound{x} \AgdaSymbol{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaBound{rsp}\AgdaSymbol{)} \AgdaBound{a} \<[29]%
\>[29]\<%
\\
\>[2]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{→} \AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst-pi} \<[47]%
\>[47]\<%
\\
\>[2]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{(}\AgdaBound{rsp} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]sym} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]refl}\AgdaSymbol{)} \AgdaBound{a}\AgdaSymbol{)} \AgdaBound{a} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst-pi'}\AgdaSymbol{)} \<[72]%
\>[72]\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{;} \AgdaField{trans*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{(}\AgdaBound{f} \AgdaInductiveConstructor{,} \AgdaBound{rsp}\AgdaSymbol{)} \AgdaBound{a} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \<[32]%
\>[32]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \<[33]%
\>[33]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]trans*} \AgdaSymbol{\_)} \<[29]%
\>[29]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{\_} \AgdaFunction{]sym} \AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \<[51]%
\>[51]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]trans*} \AgdaSymbol{\_)} \AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst-pi}\AgdaSymbol{)))} \<[46]%
\>[46]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{B} \AgdaFunction{]subst*} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaBound{rsp} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaFunction{[} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaSymbol{\_} \AgdaFunction{]trans} \<[57]%
\>[57]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]trans*} \AgdaSymbol{\_)} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst-pi}\AgdaSymbol{)))} \AgdaSymbol{\}} \<[48]%
\>[48]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{\}}\<%
\\
\end{code}

The type construction is not complete because it also includes lambda abstraction and function application which correspond to introduction and elimination rules respectively. The verification of $\beta$ and $\eta$ laws are also essential, but we can not implement it in Agda due to technical issue. Hopeful the problem can be fixed in later patches.

We also construct some basic types including natural numbers simply typed universe, equality types. $\Sigma$-types and quotient types are not discussed in the Altenkirch's original paper, which we cover here. $\Sigma$-types are intuitively simple, but the construction of it in setoid models still requires a lot of unification proofs due to the type dependency. The more important one is the construction of quotient types.


\subsection{Quotient types}

To formulate quotient types, we have to provide the encoding of equivalence in setoid model. First of all, the universe of propositions can be encoded as a setoid whose objects are meta-theoretical $\HProp$ with logical equivalence:

\begin{code}
%
\\
\>\AgdaFunction{Pu} \AgdaSymbol{:} \AgdaRecord{HSetoid}\<%
\\
\>\AgdaFunction{Pu} \AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{\{} \AgdaField{Carrier} \AgdaSymbol{=} \AgdaRecord{HProp}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{;} \AgdaField{\_≈h\_} \<[16]%
\>[16]\AgdaSymbol{=} \AgdaFunction{\_⇄\_}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{;} \AgdaField{refl} \<[16]%
\>[16]\AgdaSymbol{=} \AgdaFunction{id} \AgdaInductiveConstructor{,} \AgdaFunction{id} \<[26]%
\>[26]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{;} \AgdaField{sym} \<[16]%
\>[16]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{a}\AgdaSymbol{)\}}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{;} \AgdaField{trans} \<[16]%
\>[16]\AgdaSymbol{=} \AgdaSymbol{λ} \AgdaSymbol{\{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{a'} \AgdaInductiveConstructor{,} \AgdaBound{b'}\AgdaSymbol{)} \<[39]%
\>[39]\<%
\\
\>[6]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{a'} \AgdaFunction{∘} \AgdaBound{a}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{b} \AgdaFunction{∘} \AgdaBound{b'}\AgdaSymbol{)\}}\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{\}}\<%
\\
%
\\
\>\AgdaFunction{⟦Prop⟧} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Ty} \AgdaBound{Γ}\<%
\\
\>\AgdaFunction{⟦Prop⟧} \AgdaSymbol{=} \AgdaKeyword{record} \<[16]%
\>[16]\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{\{} \AgdaField{fm} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{Pu}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{;} \AgdaField{substT} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaBound{x} \AgdaSymbol{→} \AgdaBound{x}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{;} \AgdaField{subst*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{p} \AgdaBound{x} \AgdaSymbol{→} \AgdaBound{x}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{;} \AgdaField{refl*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{x} \AgdaBound{a} \AgdaSymbol{→} \AgdaFunction{id} \AgdaInductiveConstructor{,} \AgdaFunction{id}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{;} \AgdaField{trans*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{\_} \AgdaSymbol{→} \AgdaFunction{id} \AgdaInductiveConstructor{,} \AgdaFunction{id} \AgdaSymbol{\}}\<%
\\
\end{code}

and then a propositional binary relation can be constructed as:

\begin{code}
%
\\
\>\AgdaFunction{PropRel} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaRecord{Ty} \AgdaBound{Γ}\<%
\\
\>\AgdaFunction{PropRel} \AgdaBound{A} \AgdaSymbol{=} \AgdaBound{A} \AgdaFunction{⇒} \AgdaBound{A} \AgdaFunction{⇒} \AgdaFunction{⟦Prop⟧}\<%
\\
\end{code}

However there are some problems arising here. First of all, $\HProp$ is not a $\Set$ which means we can only encode the object-level universe of proposition if we accept $\Set : \Set$. As long as we have a term of $R : \AgdaFunction{PropRel} ~\AgdaBound{A}$, the attempt of extracting properties of $R$ takes too long to type check for Agda due to the complex of construction. Moreover, when we extract an object or a property, it is usually not as simple as we want. For example the term of $\Pi$-types always equipped with equivalence preservation proofs, therefore a binary relation carries a proof for each abstraction:

\begin{code}
%
\\
\>\AgdaFunction{PropRel-set} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaRecord{Tm} \AgdaSymbol{(}\AgdaFunction{PropRel} \AgdaBound{A}\AgdaSymbol{)} \<[51]%
\>[51]\<%
\\
\>[10]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{∣} \AgdaSymbol{→} \<[45]%
\>[45]\AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaRecord{HProp}\<%
\\
\>\AgdaFunction{PropRel-set} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{m} \AgdaBound{n} \AgdaSymbol{=} \AgdaFunction{proj₁} \AgdaSymbol{(}\AgdaFunction{proj₁} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{R} \AgdaFunction{]tm} \AgdaBound{γ}\AgdaSymbol{)} \AgdaBound{m}\AgdaSymbol{)} \AgdaBound{n}\<%
\\
\end{code}

Thus we use the underlying set of a propostion which is more convenient to use.

\begin{code}\>\<%
\\
\>\AgdaFunction{PropRel} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\AgdaSymbol{)(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaFunction{PropRel} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaBound{A} \AgdaBound{γ} \AgdaSymbol{=} \AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaRecord{HProp}\<%
\\
\>\<\end{code}

Similarly, when we try to encode properties for equivalences such as symmetry and transitive, the terms are always too cumbersome to use. Considering we use our code here for explanation rather than practical use, we only assume the necessary objects and properties in the simplest form instead of assuming a single equivalence relation constructed as a type in the setoid model. Still one can extract and adapt properties and apply them to obtain the same construction.

In a context $\Gamma$, there is a type $A : Ty ~\Gamma$, and a relation $R : A \to A \to \Prop$, the corresponding quotient type is a type $Q$ who shares the same underlying set with $A$ and the setoid equivalence is replaced by $R$. The underlying substitution is the same since it also preserves the relation $R$.


\begin{code}
%
\\
\>\AgdaKeyword{module} \AgdaModule{Q} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaFunction{Con}\AgdaSymbol{)(}\AgdaBound{A} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{(}\AgdaBound{R} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{PropRel} \AgdaBound{A} \AgdaBound{γ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{(}\AgdaBound{Rrsp} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{γ} \AgdaBound{a} \AgdaBound{b}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{[} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{]} \AgdaBound{a} \AgdaFunction{≈} \AgdaBound{b} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{a} \AgdaBound{b} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{(}\AgdaBound{Rref} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{γ} \AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{a} \AgdaBound{a} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{(}\AgdaBound{Rsym} \AgdaSymbol{:} \AgdaSymbol{(∀} \AgdaSymbol{\{}\AgdaBound{γ} \AgdaBound{a} \AgdaBound{b}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{a} \AgdaBound{b} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{b} \AgdaBound{a} \AgdaFunction{>}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{(}\AgdaBound{Rtrn} \AgdaSymbol{:} \<[18]%
\>[18]\AgdaSymbol{(∀} \AgdaSymbol{\{}\AgdaBound{γ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{a} \AgdaBound{b} \AgdaFunction{>} \<[45]%
\>[45]\<%
\\
\>[9]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaSymbol{→} \<[20]%
\>[20]\AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{b} \AgdaBound{c} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{a} \AgdaBound{c} \AgdaFunction{>}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{(}\AgdaBound{Rsubst} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{γ} \AgdaBound{γ'} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣}\AgdaSymbol{\}} \<[35]%
\>[35]\<%
\\
\>[0]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaSymbol{(}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaSymbol{(}\AgdaBound{p} \AgdaSymbol{:} \AgdaFunction{[} \AgdaBound{Γ} \AgdaFunction{]} \AgdaBound{γ} \AgdaFunction{≈} \AgdaBound{γ'}\AgdaSymbol{)} \AgdaSymbol{→}\<%
\\
\>[0]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ} \AgdaBound{x} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \<[33]%
\>[33]\<%
\\
\>[0]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{<} \AgdaBound{R} \AgdaBound{γ'} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst} \AgdaBound{p} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst} \AgdaBound{p} \AgdaBound{y}\AgdaSymbol{)} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaKeyword{where}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦Q⟧₀} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{Γ} \AgdaFunction{∣} \AgdaSymbol{→} \AgdaRecord{HSetoid}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦Q⟧₀} \AgdaBound{γ} \AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{\{} \AgdaField{Carrier} \AgdaSymbol{=} \AgdaFunction{∣} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]fm} \AgdaBound{γ} \AgdaFunction{∣}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{\_≈h\_} \AgdaSymbol{=} \AgdaBound{R} \AgdaBound{γ}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{refl} \AgdaSymbol{=} \AgdaBound{Rref}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{sym} \AgdaSymbol{=} \AgdaBound{Rsym}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{;} \AgdaField{trans} \AgdaSymbol{=} \AgdaBound{Rtrn}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{\}}\<%
\\
%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦Q⟧} \AgdaSymbol{:} \AgdaRecord{Ty} \AgdaBound{Γ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦Q⟧} \AgdaSymbol{=} \AgdaKeyword{record} \<[15]%
\>[15]\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaSymbol{\{} \AgdaField{fm} \AgdaSymbol{=} \AgdaFunction{⟦Q⟧₀}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaSymbol{;} \AgdaField{substT} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]subst}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaSymbol{;} \AgdaField{subst*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{p} \AgdaBound{q} \AgdaSymbol{→} \AgdaBound{Rsubst} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaBound{p} \AgdaBound{q}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaSymbol{;} \AgdaField{refl*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{γ} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{Rrsp} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]refl*} \AgdaSymbol{\_} \AgdaSymbol{\_)}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaSymbol{;} \AgdaField{trans*} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{Rrsp} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{A} \AgdaFunction{]trans*} \AgdaSymbol{\_)}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaSymbol{\}}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦[\_]⟧} \AgdaSymbol{:} \AgdaRecord{Tm} \AgdaBound{A} \AgdaSymbol{→} \AgdaRecord{Tm} \AgdaFunction{⟦Q⟧}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{⟦[} \AgdaBound{x} \AgdaFunction{]⟧} \AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[2]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{\{} \AgdaField{tm} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{x} \AgdaFunction{]tm}\<%
\\
\>[2]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{;} \AgdaField{respt} \AgdaSymbol{=} \AgdaSymbol{λ} \AgdaBound{p} \AgdaSymbol{→} \AgdaBound{Rrsp} \AgdaSymbol{(}\AgdaFunction{[} \AgdaBound{x} \AgdaFunction{]respt} \AgdaBound{p}\AgdaSymbol{)}\<%
\\
\>[2]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{\}}\<%
\\
\end{code}

Q-\textbf{Ax} is can be simply proved because the underlying equivalence is definitionally equal to the equvalence relation $R$.

The elimination rule and induction principle for quotient types are also straightforward. Given a function $f : A \to B$ (precisely functors) which respects $R$, we can lift it as a function  $\hat{f} : Q \to B$ whose underlying function is the same as $f$, and it is also functorial because $f$ also respects $R$ which is the internal equivalence relation of $Q$.
The implementation is quite involved although the idea is clear and simple.


\section{Other models}


\subsection{Groupoid model}

There are many other relevant models proposed to explain the essence of identity types in Type Theory and to extend Type Theory with different extensional concepts. 

Martin Hofmann and Thomas Streicher's \cite{MR1686862} groupoid model interprets types as groupoids where the identity types endow every type with a groupoid structure. Instead of basic equivalence properties in setoid model, there are five more groupoid laws where $p$ and $q$ are level-$1$ morphisms:

\begin{equation*}
\begin{array}[b]{l}
\lambda : id \circ p = p \\
\rho : p \circ id = p \\
\alpha : p \circ (q \circ r) = (p \circ q) \circ r \\
\kappa : p^{-1}\circ p = id \\
\kappa' : p \circ p^{-1} = id
 \end{array}
\end{equation*}

In a groupoid model UIP does not hold in general because there can be different inhabitants of the same identity types. In fact, propositional equality is a generalisation of isomorphism. For example to prove that $\bool = \bool$, there are two intensionally different inhabitants: one is given by identity function on $\bool$, the other is given by negation on $\bool$.

\subsection{Models of \hott}



The idea of view types as groupoids later inspires mathematicians such as Warren \cite{Warren} who interprets types as strict \og, and Voevodsky \cite{klv:ssetmodel} who interprets types as \wog, which is a generalised notion of groupoids. 

To interpret types as weak $\omega$-groupoids, one main problems is
the complexity of the definition of weak $\omega$-groupoid. The
coherence conditions are very difficult to specified.
It is much simpler to interpret types as \emph{Kan simplicial sets}.
Voevodsky's univalent model\cite{klv:ssetmodel} is based on Kan simplicial sets. 
 Streicher wrote a concise introduction to this model \cite{DBLP:dblp_journals/japll/Streicher14}. 
However the simplicial set model is not constructive as Coquand showed
that it requires classical logic in an essential way \cite{TC:sset}.

\begin{remark}[Simplicial set]
A simplicial set $X$ is a functor from $\Delta^{op}$ to $\Set$ where
$\Delta$ is the simplex category.

$\Delta^{op}$ is a category whose objects are non-empty totally ordered
finite sets. The morphisms are order-preserving functions. 
Face maps and degeneracy maps are the most important morphisms in this
category.

A simplexes is a generalisation of a triangle to arbitrary
dimensions. $3$-dimensional simplex is tetrahedron and $k+1$-simplex can
be obtained by adding one point to $k$-simplex which does not lie in the
dimension where the $k$-simplex is.

A simplicial complex is a collection of simplexes. Topologically speaking, it
is constructed by gluing n-dimensional simplexes together. 
%\todo{show an example graph}

A simplicial set, therefore, can be illustrated by the same graph where
the set of points is given by $X_0$, the set of lines is $X_1$ and so
on.
\end{remark}


To avoid the use classical logic, types can be interpreted as \emph{semi-simplicial sets} which are similar to simplicial sets, but there is only face maps
but no degeneracy maps. We can denote a semi-simplicial set as a
functor $X : \Delta_{inj} \rightarrow |Set$. The morphisms in $\Delta_{inj}$ are not only order preserving but also injective.
An “iterated dependency” approach is believed to solve the coherence
issues. However we have not successfully implemented the notion of semi-simplicial sets in an \itt like Agda. Some relevant discussion of it can be found online \cite{ssSet}.
%Klaus and me were trying to implement semi-simplical set in Agda. 


Recently, Bezem, Coquand and Huber \cite{bezem2013model} proposed another model of dependent type theory 
in \emph{cubical sets}. Similarly, a cubical set is a presheaf on cube category, denoted as $S : \Box^{op} \rightarrow \Set$ . Different to simplicial set model, it is expressed in a constructive metalogic which makes it more plausible model to obtain a computational interpretation of univalence.


\section{Summary}

In this chapter we have introduced several models of Type Theory where extensional concepts are derivable. We mainly present an implemntation of Altenkirch's setoid model where types are interpreted as setoids. It is then very straightforward to define quotient types in this model by simply replacing underlying setoid equivalence with given equivalence relation. 
We can simplify the setoid model by adopting McBride's heterogeneous
approach to equality introdced in \cite{alti:ott-conf} where Altenkirch, McBride and Swierstra
 proposed \emph{Observational Type Theory}. They identifies values up to observation rather than construction which is called \textbf{observational equality}. It is the propositional equality induced by the setoid model.  In general we have a heterogeneous equality which allows us to compare terms of different types. However it only make sense when we can prove the types are the same, in other words, only if two types are definitionally equal, it can be inhabited.
The heterogeneous equality usually helps us avoid the heavy use of $subst$ which complicates formalisation and reasoning. 
However it also means that we accept UIP and $K$ in general, which is not the case in groupoid model.



We also briefly compared different models of \hott where types are interpreted as different forms of \wog, e.g.\ simplicial sets. In these models, quotient types are available as a special case of higher inductive types. However only constructive models can possibly provide a computational interpretation of univalence.
Although coherence laws of \wog are very involved, there are some attempts of encoding it in Type Theory. We will introduce a syntactic implementation of \wog by the author in next chapter.










% In \itt, the uniqueness of identity types is not
% accepted in general, but derivable for types whose propositional
% equality is decidable. The homotopy interpretation fits
% nicely by provides higher levels structures which are weaker
% equivalence relation (compared to strict equality) between identity types.



%\hott does not only help us model type theory with a focus on the equality, but also provides mathematicians type theoretical tools to study homotopy theory.

