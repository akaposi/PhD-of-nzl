\chapter{Quotient Types}
\label{qt}
% Quotient type or quotient types?


%Quotient type is a type generated by redefining equality on a given type. 

%Technically we cannot redifine equality

 %Generally speaking, given a setoid $A$ and an 
 %equivalence relation $\sim$ on it, a quotient type denoted as
%$\qset{A}$ is a type generated by redefining equality of $A$ by
%$\sim$. In \itt, we usually use setoids to represent quotients but it
%is not satisfactory. It is a very important topic to extend \itt with
%quotient types.

%From a programmming persepective, there are more tools to define data
%types. 
%In the chapter, we first introduce the quotients in Mathematics and
%then quotient types in type theory with categorically interpretations.


%\section{Quotients in Mathematics}

% "M"athematics must be capital


%structures  used also extended to other branches, such as set
%theory, group theory, topology etc.

%we usually use the same operators for abstractly similar 
%operations. For instance, the product is extended to the cartesian product in set theory.


Quotient is one of the primitive notions in \maths. 
In arithmetic, quotient is the result of division

$$8 \div 4 = 2 ~~ \text{or}~~ 8/4 = 2$$


In abstract algebra quotient is the result of ``dividing'' a set, group, space or another algebraic structure (dividend) with respect to an given equivalence relation on it. We use quotient set as an example here.

\begin{definition}
\textbf{Equivalence relation}.
An equivalence relation is a binary
relation which is reflexive, symmetric and transitive.
\end{definition}

Intuitively, given any equivalence relation, a set can be partitioned into
some equivalence classes,

\begin{definition}
\textbf{Equivalence class}.
The equivalence class of an element $a$ is a set whose elements are
all equivalent to $a$
\begin{equation}
\class a = \{x : A \;| \; a \sim x \}
\end{equation}
\end{definition}

The collection of these equivalence classes is called
the quotient set.

\begin{definition}
\textbf{Quotient set}.
Given a set A equipped with an equivalence relation $\sim$, a quotient
set is denoted as $\qset{A}$,
\begin{equation}
\qset{A} = \{ [ a ] \;|\; a : A \}
\end{equation}
\end{definition}

Similarly in topology, group theory or other branches there are also quotient space, quotient group and other quotients. How can we construct a quotient set in type theory? How about a quotient type?

\section{Quotient types in type theory}

As long as we define a set as a type in type theory, for example the set of natural numbers $\N$, and an equivalence relation on it, we would like to have a quotient set immediately. In \ett like NuPRL, it is possible to redefine
equality of some types, hence we can define extensional quotient
types. However since the equality is extensional, we cannot recover the witness of
the equality.
%\footnote{See http://www.cs.cornell.edu/home/sfa/Nuprl/NuprlPrimitives/Xquotient_doc.html}
In \itt which lacks quotient types, setoids are often used to represent quotients.



\begin{definition}
\textbf{Setoid}.
\noindent A setoid (usually written as $(A,\sim)$) consists of
\begin{enumerate}
\item a set $A : \Set$,
\item a relation $\sim : A \to A \to \Prop$, and
\item it is an equivalence, i.e.\ the proofs that it is reflexive, symmetric and transitive.
\end{enumerate}
\end{definition}

Since it is an alternative representation of sets, everything defined on $\Set$ has to be redefined on setoids again.
For example, functions on setoids, equalities on setoids,
products on setoids etc. Moreover it is essential to define higher setoids, when the base set is represent as setoids. Not only the manipulation of equivalence complicates
these definitions, from a programming perspective, setoids are also
unsafe because we have access to the underlying
 sets \cite{aan}. We can perform operations which does not respect
 equivalence relation and the result does not make any sense.
Therefore, setoids are not considered as a good solution.

From other quotient algebraic structures in abstract algebra, usually the quotients are same kind of object as the base one. Hence in type theory it is also expected
that the type representing a quotient set is of sort $\Set$ rather that $\Setoid$. 

\subsection{An impredicative encoding of quotient types}\label{impredicative}

An natural idea is to imitate the set theoretical construction. We would like to define an equivalence class first.

An equivalence class of $a$ can be defined as a tuple

$$[ a ] \defeq \Sigma (x : A) , x \sim a $$

However, given $a ~ b$, $[ a ]$ is not propositionally equal to $[ b ]$. The reason is that $x \sim a$ is not propositional equal to $x \sim b$ even though they are logically equivalent due to the lack of propositional extensionality.


\begin{definition}
\textbf{propositional extensionality} (propositional univalence).

$\forall P, Q : \Prop, (P \iff Q) \iff P = Q.$
\end{definition}

Vladimir Voevodsky introduces an impredicative definition of quotients
%\footnote{\url{http://www.cse.chalmers.se/~coquand/cirm.pdf}} 
which has been encoded in Coq
\cite{voe:hset}. 

Given a setoid $(A,\sim)$, an equivalence class is a subtype given by a predicate $P : A \to \Prop$.

$\text{EqClass} ~ P \defeq (\exists a : A, P ~ a) \times \forall x ~ y : A, P x \to (x \sim y \iff P ~ y)$


The \textbf{set quotient} is then defined as

$\qset{A} \defeq \Sigma P : A \to \Prop, \text{EqClass} ~P$

Notice that it is impossible to extract an element of $A$ from an proof of $\text{EqClass} ~ P$ because the encoding of $\exists a : A, P ~ a$ is impredicative as truncated $Sigma$-type: $\| \Sigma a : A, P ~ a \|$.
The truncation $\|-\|$ is defined impredicatively as

$\|A\| \defeq \forall P : \Prop \to (A \to P) \to P$

$\|A\|$ is in the universe of $\Set_1$($\mathsf{U}_1$ in some articles) and with resizing rules, $\|A\|$
is moved to the universe of $\Set$ (or $\mathsf{U}$). With resizing rules,
$\qset{A}$ is then in the universe of $\Set$ as expected.

% \footnote{\url{http://www.math.ias.edu/~vladimir/Site3/Univalent_Foundations_files/2011_Bergen.pdf}}

There is a function $[\_] : A \to \qset{A}$ which is compatible with $\sim$ and
we can lift any function $f : A \to B$ compatible with $\sim$ such that $\hat{f} [ a ] \equiv f a$

Assume $x \sim y$, $[ x ]$ and $[ y ]$ have to be propositionally equal which can be proved with propositional extensionality.
There is an alternative type-theoretical encoding which is sometimes called intensional quotient set.


%with the proposional extensionality we can prove that
%\begin{theorem}\label{thm-p-e}
%Given $(P , prf) : \qset{A}$, all proofs of $\exists x : A, P (x)$ are equal
%\end{theorem}

%\begin{proof}
%Given any two proofs of $\exists x : A, P (x)$ written as $(x , px)$ and $(y
%, py)$, apply the $EqClass(P)$ to $(x, y, px, py)$ we know that $x
%\sim y$. Hence the truncation of 
%\end{proof}

%Given a element $a : A$, the equivalence class is


%It is called impredicative because it uses resizing rules \footnote{\url{http://phdsinlogic2014.wp.hum.uu.nl/files/2014/04/thierry-coquand1.pdf}} in the encoding of existential proof.

%$|| A || = (P : \Prop)(A \to P) \to P$


\subsection{Intensional quotient set}

In type theory, given a setoid $(A,\sim)$, an intensional quotient set is given by
following rules:

\infrule[Q-\bf{Form}]
{A : \Set  \andalso \sim : A \to A
  \to \bf{Prop}  \andalso \sim \text{is an equivalence
    relation \footnote{i.e.\ it is reflexive, transitive and symmetric}}}
{\qset{A} : \Set}


\begin{multicols}{2}
\infrule[Q-\bf{Intro}]{a : A}{[ a ] : \qset{A}}
\columnbreak
\infrule[Q-\bf{Ax}]
{a ~ b :  A  \andalso p : a \sim b}
{\text{Qax} ~ p : [a]=[b]}
\end{multicols}

where $=$ stands for propositional equality.

According to Hofmann's\cite{hof:95:sm} definition, an eliminator or lifting rule


\infrule[Q-\bf{elim}]
{B :  \Set      \andalso f : A \to B             \andalso        q : \qset{A}\\
f^{=} : \forall a ~ b : A, p : a \sim b  \to f ~a =  f ~ b}
{\hat{f} ~ q ~ f^{=} : B}


\infrule[Q-\bf{comp}]{a : A}{f_{\beta} a  : \hat{f} ~ [ a ] ~ f^{=} = f a }

it also comes with an induction principle

\infrule[Q-\bf{ind}]
{P : \qset{A} \to \Prop \andalso ~ h : (a : A) \to P ~ [ a ] \andalso ~ q :  q : \qset{A}}
{\text{Qind} ~h ~q :P~q}

An alternative equivalent elimination rule is a depedent lifting rule

\infrule[Q-\bf{dep-elim}]
{B : \qset{A} \to  \Set \andalso f : (a : A) \to B\, [ a ] \andalso q :
\qset{A} \\
f^= : \forall a ~ b : A, p : a \sim b  \to f ~a
\stackrel{p}{=}  f ~b}
{\hat{f} ~q ~ f^= : B~ q}

\infrule[Q-\bf{dep-comp}]{a : A}
{f_{\beta} a  : \hat{f} ~ [ a ] ~ f^= = f a }

Here, $\stackrel{p}{=}$ stands for equality under unification on types by substitution by $p$.

A quotient is \emph{exact} (or effective) if exactly one equivalence class corresponds to
an element of $Q$,

\infrule[Q-\bf{exact}]
{a , b :  A  \andalso p : [a] = [b] }
{\text{Qexact}~{p} : a \sim b}


With propositional extensionality, we can prove that all quotients are effective.

\begin{theorem} \label{PUEF}
\emph{propositional extensionality} (or propositional univalence) implies that all quotients are effective.
\end{theorem}

\begin{proof}
Suppose we have a set $A$ with an equivalence relation $\sim : A \to A
\to \Prop$, a quotient set is $\qset{A}$.

Given $a : A$, and a predicate $P_a : A \to \Prop$ defined as 
$$P_a ~ x \defeq a \sim x$$

To lift it we have to check $P_a$ is compatible with $\sim$.

Suppose $x \sim y$

by symmetry and transitivity

$\Rightarrow a \sim x \iff a \sim y$

$\equiv P_a~x \iff P_a~y$

by propositional extensionality

$\Rightarrow P_a~x = P_a~y$


To prove the quotient $\qset{A}$ is effective, suppose $[ a ] = [ b ]$, we can simply prove $ \hat{P} [ a ] = \hat{P} [ b ]$ and then

$$a \sim a \equiv \hat{P} [ a ] = \hat{P} [ b ] \equiv a \sim b$$

Finally with eliminator J and $\text{refl} : a \sim a$ we can easily prove

$$a \sim b$$.

\end{proof}

%Alternatively, we can prove it as follows:

%\begin{proof}

%Firstly we prove the equivalence relation is well-defined on the
%quotient types, namely it respects the equivalence relation:

%Suppose we have $a \sim b$ and $c \sim d$, we can deduce $a \sim c \iff
%b \sim d$. Then applying the propositional univalence axiom, we know
%that $a \sim c = b \sim d$, hence the equivalence relation is
%well-defined.

%Because it is well-defined, we can lift it such that

%$[ a ] ~\hat{\sim}~ [ b ] \equiv a \sim b$


%From reflexivity of the equivalence relation, $\forall x : A, x \sim x$, 
%we know that $\forall x : A, [x]~\hat{\sim}~[x]$.

%Assume $[a]=[b]$, using J-eliminator in $[a]~\hat{\sim}~[a]$
%(reflexivity), $[a]~\hat{\sim}~[b]$ which is definitionally equal to $a \sim b$, Hence the quotient is
%effective.
%\end{proof}





\subsection{Quotient types are coequalizers}

The intensional quotient set is indeed characterised in category-theoretical way.
Categorically speaking, a quotient is a coequalizer.

\begin{definition}
\textbf{Coequalizer}.
Given two objects $X$ and $Y$ and two parallel morphisms $f, g : \morph{X}{Y}$ , a coequalizer is an object Q with a morphism $q : \morph{Y}{Q}$ such that $q \circ f = q \circ g$. It has to be universal as well. Any pair (Q' , q') $q' \circ f = q' \circ g$ has a unique factorisation u such that $q' = u \circ q$
\begin{displaymath}
    \xymatrix{X \ar@<0.5ex>[rr]^f \ar@<-0.5ex>[rr]_g && Y \ar[rr]^q
      \ar[ddrr]_{q'} && Q
      \ar@{.>}[dd]^u \\ \\
& &&& Q' }
\end{displaymath}
\end{definition}

A quotient is the coequalizer when we have two projections $\pi_1$ and
$\pi_2$ from the relation $R = \{(a_1,a_2) : A \times A ~|~ a_1 \sim a_2\}$
\begin{displaymath}
    \xymatrix{R \ar@<0.5ex>[rr]^{\pi_1} \ar@<-0.5ex>[rr]_{\pi_2} && A \ar[rr]^{ [\_]}
      \ar[ddrr]_{f} && Q
      \ar@{.>}[dd]^{\hat{f}} \\ \\
& &&& B }
\end{displaymath}


The exactness corresponds to effectiveness of coequalizer,

\[\xymatrix{
R\pullbackcorner\ar[r]^\pi_1\ar[d]_\pi_2 & A\ar[d]^{[\_]} \\
A\ar[r]_{[\_]} & Q
}\]


A quotient with a right inverse "emb" for $[\_]$ corresponds to \emph{split coequalizer} which is a fork 

\[\xymatrix{
R\ar@<0.5ex>[r]^{\pi_0}\ar@<-0.5ex>[r]_{\pi_1}& A\ar[r]^{[\_]}
& Q
}\]

with morphisms $\emb : Q \to A$ and $t : A \to R$ such that 

$[\_] \circ emb = 1_Q$

$\emb \circ [\_]  = \pi_2 \circ t$ and 

$\pi_1 \circ t = 1_A$ (i.e.\ $t ~ a = (\emb [ a ] , a)$)



\subsection{Quotient types is a left adjoint functor}

Recalling the definition of adjunction.

\begin{definition}
\text{Adjunction}.
Given two categories $A$ $B$, a functor $F : A \to B$ is left adjoint
to $G : B \to A$ if we have a natural isomorphism
$\Omega : hom_{B}(F ~\_ , \_) \to hom_{A}(\_, G ~\_)$
\end{definition}


Quotient can also be seen as a functor $\textbf{Q} : \textbf{Setoids} \to \textbf{Sets}$ which is
left-adjoint to embedding functor $\nabla$
where

$\textbf{Q} ~ (B , \sim) \defeq \qset{B}$, and

$\nabla A \defeq (A , =)$


The adjunction above can be given by following natural isomorphism

\begin{equation*}
\begin{aligned}
\qset{B} & \to A \\
\midrule
\midrule
(B , \sim) & \to (A , =)
\end{aligned}
\end{equation*}

To prove that this is an isomorphism, assume $f : \qset{B} \to A$, there exists a mapping

$\Omega ~ f = f \circ [\_]$ and its inverse

$\Omega^{-1} ~ g = \hat{g}$ (we omit the property that $g$ respects $\sim$)

The isomorphic properties can be verified as follows,

$\Omega^{-1} (\Omega~f) = \dlift{f \circ [\_]} = f$ by the uniqueness from lifting.

$\Omega (\Omega^{-1}~g) = \hat{g} \circ [\_] = g$ by definition of lifting.


\subsection{Quotient inductive types}

As we have seen in \autoref{hott:ext}, quotient inductive types is an alternative way to define quotients in \hott. In fact, some examples suggests that QITs are more powerful than quotient types.

One of the example is the definition of reals which will be discussed in \autoref{rl}. Our construction of reals by Cauchy sequences of rational numbers is not Cauchy complete because there is no limit of each equivalence class. However, the Cauchy approximation approach in \cite{hott} using quotient inductive types is Cauchy complete due to the fact that the equivalence relation and limits are included in its definition.

Another example is unordered trees (rooted tree). An unordered tree is a tree connected to a multiset of rooted trees, hence there is no ordering on subtrees.

Firstly we define ordered trees as:

\begin{itemize}
\item A leaf $l: \mathsf{Tree}$, or
\item An ordered list of subtrees indexed by $\mathbb{N}$, $st : (\mathbb{N} \rightarrow \mathsf{Tree}) \rightarrow \mathsf{Tree}$,
\end{itemize}

With the following equivalence relation:

\begin{itemize}
\item $l_{eq} : l \sim l$,
\item $st_{eq} : (f , g : \N \to \mathsf{Tree}) \to f \sim_{p} g \to sp~f \sim sp~g$
\end{itemize}

where $f \sim_{p} g$ stands for $f$ is a permutation of $g$. The permutation can be defined using a bijective map $p : \N \to \N$ which relates equivalent subtrees recursively.

%However, if we use quotient type $\mathsf{Tree^{\sim}} := \qset{\mathsf{Tree}}$, the resulting trees have unordered subtrees which are themselves ordered.

If we define unordered trees as a quotient type $\mathsf{Tree^{\sim}} := \qset{\mathsf{Tree}}$, 
there is some problem of lifting the $st$. 
For finitely branching trees like binary trees,$st$ can be lifted by nesting lifting functions,

$$\overline{st}~a~b = \text{lift}~(\text{lift}~st~a)~b$$

because its type is isomorphic to $\mathsf{BTree} \rightarrow \mathsf{BTree} \rightarrow \mathsf{BTree}$.
Intuitively we can apply this approach to trees with finite subtrees. However it fails if have infinite subtrees.

Quotient inductive types does not have such problems:

\begin{itemize}
\item $l: \mathsf{Tree}$, 
\item $st : (\mathbb{N} \rightarrow \mathsf{Tree}) \rightarrow \mathsf{Tree}$,
  and
\item a set of paths relates two permuted trees:

$l_{eq} : l  =_{\mathsf{Tree}} l $

$st_{eq} : \forall (f, g : \N \to \mathsf{Tree}) \rightarrow
f \sim_{p} g \rightarrow  st~f =_{\mathsf{Tree}} st~g$
\end{itemize}

The cumulative hierarchy of all sets introduced in \cite{hott} also suggests that quotient types have some weaknesses compared to quotient inductive types.

A cumulative hierarchy can be given by constructors,

$\{\_\} : (I : \Set) \to (I \to M_0) \to M_0$

along with a subset relation,

$\_\in\_ : M_0 \to M_0 \to \Prop$

which is inhabited if $ f(i) \in \{ I , f \}$

Then we can easily define the equivalence relation using set-theoretical definition

$A \sim B \defeq \forall m : M_0, m \in A \iff m \in B$

Similar to unordered trees, we can not obtain the constructor $\overline{\{\_\}}$ because the index set $I$ can be infinite.


In the above examples, it seems that quotient inductive types are more powerful than quotient types due to the ability of defining term constructors and equivalence relations simultaneously. 
However, quotient inductive types are not available in type theories other than \hott and the computational interpretation of it is still an open problem.

%However, it is still an open problem to find a computational interpretation of higher inductive types.

\section{Literature review}

%\todo{rewrite}

\begin{itemize}

\item In \cite{cab}, Mendler et al. have firstly considered building new types from a
given type using a quotient operator $//$. Their work is done in an
implementation of \ett, NuPRL. 
In NuPRL, every type comes with its own equality relation, so the quotient operator can be
seen as a way of redefining equality in a type. But it is not all
about building new types. They also discuss problems that arise from
defining functions on the new type which can be illustrated using a simple example. 

Assume the base type is $A$ and the new equivalence relation is $E$, the new
type can be formed as $A//E$. 

When we want to define a function $f \,\colon\, A//E \to Bool$,  $f\,a \not= f\,b$ may
exists for $a, b \,\colon A$ such that $E\,a\,b$. This will lead to
inconsistency since $E\,a\,b$ implies $a$ converts to $b$ in \ett{}, hence
the left hand side $f\,a$ can be converted to $f\,b$, namely we get $f\,b \not= f\,b$
which is contradicted with the equality reflection rule. 

Therefore a function is said to be well-defined \cite{cab} on the new type only
if it respects the equivalence relation $E$, namely

$$\forall \, a\,b\,\colon A, E\,a\,b \to f\,a = f\,b$$

We call this \emph{soundness} property in \cite{aan}.

 After the introduction of quotient types, Mendler further investigates
 this topic from a categorical perspective in ~\cite{men:90}. He uses
 the correspondence between quotient types in \mltt{} and coequalizers
 in a category of types to define a notion called \emph{squash types},
 which is further discussed by Nogin \cite{nog:02}.

\item To add quotient types to \mltt{}, Hofmann proposes  three models for
quotient types in his PhD thesis \cite{hof:phd}. The first one is a setoid model for
quotient types. In this model all types are attached with partial
equivalence relations, namely all types are setoids rather than
sets. Types without a specific equivalence relation can be seen as
setoids with the basic intensional equality. This is similar to
\ett{} in some sense. The second one is groupoid model which solves some problems
but it is not definable in \itt{}. He also proposes a third model to
combine the advantages of the first two models, but it also has some
disadvantages. Later in \cite{hof:95:sm} he gives a simple model in which we have type dependency only at the propositional level, he also shows that extensional Type Theory is conservative over \itt  extended with quotient types and a universe \cite{hof:95:con}.

\item Nogin \cite{nog:02} considers a modular approach to axiomatizing the
same quotient types in NuPRL as well. Despite the ease of constructing new types
from base types, he also discusses some
problems about quotient types. For example, since the equality is
extensional, we cannot recover the
witness of the equality.  He suggests including more axioms to
conceptualise quotients. He decomposes the formalisation of quotient type
into several smaller primitives such that they can be handled much
simpler.

\item Homeier \cite{hom} axiomatises quotient types in Higher Order Logic
(HOL), which is also a theorem prover. He creates a tool package to
construct quotient types as a conservative extension of HOL such that
users are able to define new types in HOL. Next he defines the
normalisation functions and proves several properties of
these. Finally he discussed the issues when quotienting on the
aggregate types such as lists and pairs.


\item Courtieu \cite{cou:01} shows an extension of Calculus of Inductive Constructions
with \emph{Normalised Types} which are similar to quotient types, but equivalence relations are replaced by normalisation functions. 
However not all quotient types have normal forms. Normalised types are
proper subsets of quotient types, because we can easily recover a quotient
type from a normalised type as below
%$$ \[ (A, Q, \class\dotph \colon A \to Q) \to (A, \lambda \,a \,b \to \class a = \class b)\]$$


\item Barthe and Geuvers \cite{bar:96} also propose a new notion called
\emph{congruence types}, which is also a special class of quotient
types, in which the base type are inductively defined and with a set
of reduction rules called the term-rewriting system. The idea behind
it is the $\beta$-equivalence is replaced by a set of
$\beta$-conversion rules. Congruence types can be treated as an
alternative to the pattern matching introduced in \cite{coq:92}. The main
purpose of introducing congruence types is to solve problems in
term rewriting systems rather than to implement quotient types.


\item Barthe and Capretta \cite{bar:03} compare different ways to setoids in type theory.
The setoid is classified as partial setoid or total setoid depending
on whether the equality relation is reflexive or not. They also
consider obtain quotients with different kinds of setoids, especially
the ones from partial setoids are difficult to define because the lack
of reflexivity.

\item Abbott, Altenkirch et al. \cite{abb:04} provides the basis for
programming with quotient datatypes polymorphically based on their
works on containers which are datatypes whose instances are
collections of objects, such as arrays, trees and so on. Generalising
the notion of container, they define quotient containers as the
containers quotiented by a collection of isomorphisms on the positions
within the containers.

\item Voevodsky \cite{voe:hset} implements quotients in Coq based on a set
of axioms of Homotopy Type Theory. He firstly implement
equivalence class and use it to implement quotients which is an
analogy to the construction of quotient sets in set theory. The detail has been given in \autoref{impredicative}.


\end{itemize}



