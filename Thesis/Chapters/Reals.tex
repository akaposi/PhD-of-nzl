\chapter{Real numbers}
\label{rl}

%If you mean something specific, always write "the"

In the previous chapter, we discussed quotients which are definable via normalisation.
To encode these types, quotient types are not necessary. However there are some quotients undefinable in the sense of normalisation, for example the set of real numbers, the multisets and the partiality monad. Intuitively they can be interpreted as setoids but there is no normalisation function which returns a canonical choice for each equivalence class, hence no normalisation function.

\section{Real numbers as Cauchy sequences}
To construction real numbers in Type Theory, there are several different approaches, for example Cauchy sequences, Dedekind cut, decimal representation, etc. Here we use Cauchy construction of real numbers as in \cite{bis:85}:
%In \cite{hott} it has been proved that Cauchy reals and Dedekind reals are equivalent if excluded middle or countable choice holds.
\begin{definition}\label{R01}
$$\R_{0} = \set{s : \N\to\Q \mid \forall\varepsilon
  :\Q^{+}, \exists m:\N, \forall i:\N, i>m\to \vert  s_i -
  s_m \vert  <\varepsilon}$$
\end{definition}


This definition is equipped with a proof which can help us guess the real number if the existential quantifier is not truncated. However usually we would like the proof to be truncated so that the Cauchy sequences are proof-irrelevant. 

To avoid this problem, we can use an alternative equivalent definition which is a subset of $\R_{0}$:

$$\R_0' = \set{f: \N\to\Q \mid \forall k
  :\PN,\forall m , n > k, \to \vert  f_m -
  f_n \vert  < \frac{1}{k}}$$ \label{R02}

The rate of convergence is fixed so that we can guess the number while the condition is propositional.


We can slightly modify the definition which is still equivalent,

$$\R_0'' = \set{f: \PN\to\Q \mid \forall n ~m
  :\PN, n > m \to \vert f_n -
  f_m \vert  < \frac{1}{n}}$$ \label{R03}


Cauchy sequences can be added and multiplied point-wisely and the result is still Cauchy sequences.

If the point-wise difference between two Cauchy sequences tends to zero, we say they are equivalent.

$$r \sim s \defeq \forall\varepsilon :\Q^{+},\to\exists m:\N,
\forall i:\N, i>m\to \vert  r_i - s_i \vert <\varepsilon$$

With this equivalence relation, we can define the set of real numbers as long as we have quotient types.
But different to the set of integers and the set of rational numbers, it is not definable via normalisation, in other words we cannot define a normalisation function $[\_]_0: \R_0 \to R_0$ which returns a canonical choice for each equivalent class.

\subsection{$\R$ is undefinable via normalisation}

We have made an attempt to prove that the set of reals is undefinable in \cite{aan} which was pointed out wrong by Martín Escardó. He shows an counterexample to prove that there can be no definable function into $\bool$ for two distinguishable terms \footnote{Agda proof can be found in online \cite{martinsproof}}.

$\N_\infty : \Set$ is a decreasing sequence of $\bool$ which is called generic convergent sequence, where $11000\ldots$ represents $2$ and the sequence of $1$, namely $1111\ldots$ is $\infty$, thus it can be seen as $\N + \infty$. For simplicity, we write $s_k$ for the sequence whose first $k$ digits are $1$ and the rest digits are $0$.

From continuity, we know that:

given any definable function $f : \N_\infty \to \bool$, there exists $n : \N$ such that for all $s_k : \N_\infty$ ($k \geq n$) whose first $n$ digits coincide with $\infty$,  $f(s_k) = f(\infty)$.

Set 
$X \defeq \Sigma u : \N_\infty, u = \infty \to \bool$,

$s^0_k \defeq (s_k, \lambda r \to 0)$ and 

$s^1_k \defeq (s_k, \lambda r \to 1)$,

there are two separable terms of $X$, $\infty_0 = s^0_\infty$ and $\infty_1 = s^1_\infty$,

such that for all definable function $f : X \to \bool$, $f(\infty_0) = f(\infty_1)$.

To prove it, assume $f(\infty_0) \not= f(\infty_1)$.
We can prove that for all $k : N$ ($s_k \not= \infty$), $f(s^0_k) = f(s^1_k)$ because the second part is always the same due to the fact that $s_k \not= \infty$. From continuity, we can deduce that $f(\infty_0) =f(s^0_k) = f(s^1_k) = f(\infty_1)$, which contradicts to the premise.


In this chapter, we refined our approach to conduct a meta-level reasoning which can be further generalised.

%\begin{definition}
%\textbf{Discrete type}.

%A type $A$ is discrete if there exists a definable test $P : A \to \textbf{2}$ such that $\forall a~ b ∶ A, a \neq b \to P ~a \neq P~ b$.
%\end{definition}



%We have made an attempt in the original version of our \cite{aan} draft, but there is something important problem pointed out by Martin Escardo. Laterly, Nicolai Kraus suggests to fix the proof by proving it as a meta-theoretical property. We will show an adaption of his proof here.

\textbf{Some preliminaries}

The proof is mainly conducted using topological tools. Following are some relevant topological concepts.

\begin{definition}
\textbf{Metric space}. In \maths, a metric space is a set where a notion
of distance (called a metric) between elements of the set is defined.

A metric space is an ordered pair $(M , d)$ where $M$ is a set and d is a metric on $M$:
\begin{enumerate}
\item $M$ is a set,
\item and $d : M \times M \rightarrow \R$ s.t.
\item $d (x , y) = 0 \iff x = y$
\item $d(x,y)=d(y,x)$
\item $d(x,y)+d(y,z) \ge d(x,z)$ 
\end{enumerate}
\end{definition}

We usually use the \textbf{discrete spaces} for types like $\bool$, $\N$, $\Q$ etc.

\begin{itemize}

\item $(\bool , h)$ where 
$h(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\item $(\N , d)$ where 
$d(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\item $(\Q , e)$ where 
$e(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\end{itemize}

For Cauchy sequences, recall the third definition of $\R_0$ as \ref{R03}:

\begin{definition}
 We call a function $f : \PN \to \Q$ a \emph{Cauchy sequence} if it satisfies
 \begin{equation}
  \iscauchy ~f \defeq \forall n~m : \PN, n < m \to |f_n - f_m| < \frac 1 n. \label{eq:prop-property-short}
 \end{equation}
 The type of Cauchy sequences is thus
 \begin{equation*}
  \R_0 \defeq \Sigma f : \PN \to \Q, \iscauchy ~ f.
 \end{equation*}
\end{definition}

The canonical distance function for $\R_0$ is

\begin{equation}
g(f_1,f_2) = 2^{-\mathsf{inf}\{k \in \PN \; | \; f_1(k) \not= f_2(k)\}}
\end{equation}

and the metric space is not discrete.

Technically, if we define $\R_0$ as \ref{R01}, there would be different proof terms for the same sequence which means the distance between two non-equal elements may be $0$, hence not metric space.


\begin{definition}
\textbf{Continuous function.} Let $(X, d)$ and $(Y, e
)$ be metric spaces. A function $f : X \to Y$ is called
continuous if for every $x : X$ and $\epsilon > 0$ there exists a $\delta > 0$ such that

$$\forall y : X, d(x,y) < \delta \Rightarrow e(f(x),f(y)) < \epsilon$$
\end{definition}


Among all these standard metric spaces, It is a folklore that all
definable functions are continuous.

\begin{theorem}\label{defcon}
All definable functions are continuous.
\end{theorem}




Let us introduce the following auxiliary definition:
\begin{definition}
 For a sequence $f : \PN \to \Q$, we say that $f$ is \emph{Cauchy with
   factor $k$}, written as $\iscauchy_k$, for some $k \in \Q^+$, if
 \begin{equation}
  \iscauchy_k ~ f \; \defeq \; \forall n ~m : \PN, n < m \to |f_n - f_m| < \frac 1 {k \cdot n}. \label{eq:cauchy-aux}
 \end{equation}
 The usual Cauchy condition $\iscauchy$ is therefore ``Cauchy with factor $1$''.
\end{definition}

Now we have enough tools to prove the following proposition.

\begin{proposition} \label{prop:main}
 \textbf{$\R_0 / \sim$ is connected.} It means that any continuous function
 \begin{equation}
  f : \R_0 \to \bool
 \end{equation} that respects $\sim$ is constant.
\end{proposition}



\begin{remark} If we claim a function $f$ is defined on $\R_0$ that
  respects $\sim$, it means that we have a proof
\begin{equation}
 p : \forall c_1 ~ c_2 : \R_0  \to c_1 \sim c_2 \to f(c_1) = f(c_2).
\end{equation}

\end{remark}


\begin{proof}\label{realconnected}

The general idea is to interpret our definition in classical \maths,
assume we have a non-constant function and deduce a contradiction.
Consider the ``naive'' set model (with ``classical standard \maths'' as meta-theory). This clearly works if we are in a minimalistic type theory with $\Pi$, $\Sigma$, $\mathsf{W}$, $=$, $\mathbb N$; however, if we restrict ourselves to the types in the lowest universe of homotopy type theory (which is enough), it also works for HoTT.
 We use $\tometa \cdot$ as an interpretation function; 
 for example, we write $\R$ for the field of real numbers which can be defined as $\tometa {\R_0} / \tometa{\sim}$. 
 By abuse of notation, we write $\tometa {\R_0}$ for the set of Cauchy sequences in the model that fulfil the Cauchy condition, without the actual proof thereof. This is justified as this property is propositional. 
 
 For readability, we use the symbol $=$ for equality in the theory as well in the model, and we do not use the semantic brackets for natural numbers such as $2$ or $4$.
 In the model, we use $\clim \cdot : \tometa {\R_0} \to \R$ as the
 function that gives us the limit of a Cauchy sequence (Not all
 functions in the ``naive'' set model have to be continuous).
 Thus, for $r : \R_0$, we write $\climeta r \in \R$ for the real number it represents.

Assume $f, p$ are given. We prove that $\tometa f : \tometa {\R_0} \to \tometa \bool$ is constant in the model, which implies the statement of \autoref{prop:main}.

Thus, assume $\tometa f$ is non-constant,  there are $c_1, c_2 : \tometa {\R_0}$ with $\tometa f(c_1) \not= \tometa f(c_2)$. 

 Define
 \begin{align}
  m_1 & \defeq \mathsf{sup} \{\clim d \in \R \; | \; d \in \tometa {\R_0}, \clim d \leq \mathsf{max}(\clim{c_1}, \clim{c_2}), \tometa f(d) = \tometa \btrue \}\\
  m_2 & \defeq \mathsf{sup} \{\clim d \in \R \; | \; d \in \tometa {\R_0}, \clim d \leq \mathsf{max}(\clim{c_1}, \clim{c_2}), \tometa f(d) = \tometa \bfalse \}
 \end{align}
 (note that one of these two necessarily has to be $\clim{c_1}$ or $\clim{c_2}$, whichever is bigger).
 Set $m \defeq \mathsf{min}(m_1,m_2)$, because $m$ is a supremum, we can observe that in
 \emph{every} neighbourhood $U$ of $m$, given any $t$,
we can always find another point $x \in U$ such that $x = \clim e$
(for some $e$) with $\tometa f(e) \not= \tometa f(t)$. 


 Let $c \in \tometa {\R_0}$ be a Cauchy sequence such that $\clim c = m$. 
 We may assume that $c$ satisfies the condition
 $\tometa{\iscauchy_5}$.
%  The slight difference ($\frac 1 n$ is replaced by $\frac 1 {4n}$) will be important.
%  Without loss of generality, assume $\tometa{f}(c) = \tometa \btrue$. % not needed.
 
 As $f$ is definable (and thereby $\tometa f$ is continuous \autoref{defcon}), for an arbitrary $\epsilon < 1$, there exists $n_0 \in \tometa {\N}$ such that for any Cauchy
 sequence $c' \in \tometa {\R_0}$, if the first $n_0$ sequence
 elements of $c'$ coincide with those of $c$ (namely the distance
 $g(c, c') = 2^{-\mathsf{inf}\{k \in \N \; | \; c(k) \not= c'(k)\}}
 \leq 2^{-{n_0}}$ ), then $h (\tometa f(c), \tometa f(c'))< \epsilon < 1$, hence $\tometa f(c') = \tometa f(c)$. 

 Write $U \subset \tometa {\R_0}$ for the set of Cauchy sequences which fulfil this property, and $\clim U \defeq \{\clim d \; | \; d \in U\}$ for the set of reals that $U$ corresponds to.
 We claim that $\clim U$ is a neighbourhood of $m$ by proving an open interval $I \defeq (m - \frac 1 {2n_0} , m+ \frac 1 {2n_0})$ is contained in $\clim U$, i.e.\ $m \in I \subset \clim U$.

 Let $x \in I$, there is a Cauchy sequence $t : \tometa {\R_0}$ such that $\clim t = x$ and we may assume that $t$ satisfies the condition $\tometa {\iscauchy_{5n_0}}$.

 Let us now ``concatenate'' the first $n_0$ elements of the sequence $c$ with $t$, that is, define
 \begin{align}
  &g : \tometa{\PN \to \Q} \\
  &g (n) = \begin{cases}
            c(n) & \text{if $n \leq n_0$} \\
            t(n-n_0) & \text{else}.
           \end{cases}
 \end{align}

 Observe that $g$ is also a Cauchy sequence, i.e. $\tometa \iscauchy(g)$: The only thing that needs to be checked is whether the two ``parts'' of $g$ work well together. Let $0 < n \leq n_0$ and $m > n_0$ be two natural numbers. We need to show that
 \begin{equation}
  |g(n) - g(m)| < \frac 1 n.
 \end{equation}
 Calculate
 \begin{align}
  & \quad |g(n) - g(m)| \\
  = & \quad|c(n) - t(m - n_0)| \\
  = & \quad |c(n) - \clim c + \clim c - \clim t + \clim t - t(m - n_0)| \\
  \leq & \quad | c(n) - \clim c | + |\clim c - \clim t| + |\clim t - t(m - n_0)| \\
  \leq &  \quad  \frac{1}{5n}  + \frac{1}{2n_0} + \frac{1}{5n_0 \cdot (m-n_0)} \\
  \leq &  \quad  \frac{1}{5n}  + \frac{1}{2n} + \frac{1}{5n_0} \\
  <  & \quad \frac 1 n
 \end{align}

From the continuity property of $f$ and the definition of
$g$ we know that $\tometa f (g) = \tometa f(c)$. Clearly, $\clim g =
\clim t = x \in I$. 

Therefore \emph{all} $s \in \tometa {\R_0}$ with $\clim
s \in I$, we can use the "concatenation'' approach to find a $g$
satisfies $s \, \tometa \sim \,  g$ (namely $\clim s = \clim g$), and by the condition that $f$ (and
thereby $\tometa f$) respects $\sim$, we can conclude that $\tometa f
(s) = \tometa f (g) = \tometa f(c)$, thus $\clim U$ is a neighbourhood of $m$.
However, as we have seen, in \emph{every} neighbourhood of $m$, and thus in particular in $(m - \frac 1 {2n_0} , m+ \frac 1 {2n_0})$, we can always find an $x$ such that $x = \clim e$ (for some $e$) with $\tometa f(e) \not= \tometa f(c)$ which contradicts to the just established statement.
\end{proof}


%  It is easy to see that $g$ is a Cauchy sequence, i.e. $\tometa \iscauchy(g)$,\footnote{Of course, this is why we needed $\iscauchy_5$ instead of $\iscauchy$ earlier. The $5$ is somewhat arbitrary (todo: think about what is actually needed).} with $\clim g = x$. Further, the first $n_0$ elements of $g$ coincide with those of $c$, and thus, $\tometa f(g) = \tometa f(c)$.

We can easily generate similar proofs by replacing $\bool$ by any discrete type, hence the proposition "$\R_0 / \sim$ is connected'' implies that:

\begin{corollary}\label{dis:con}
Any continuous function from $\R_0$ to any discrete type that respects $\sim$ is constant.
\end{corollary}



\begin{theorem}
Any continuous endofunction $f$ on $\R_0$ that respects $\sim$ is constant
\end{theorem}

\begin{proof}

Assume we have $f,p$ as required. 

To prove $f$ is constant, it is enough to show that the sequence part is
constant because the proof part is propositional. Again, by slight abuse of notation, we write $\tometa f : \tometa{\R_0} \to \tometa {\R_0}$, omitting the proof part of $f$.
 

Given a positive natural number $n : \tometa \PN$, we have a projection
function $\pi_{n} : \tometa{ \R_0} \to \tometa \Q$. Define a function
$h_n : \tometa {\R_0} \to \tometa \Q$ as

 \begin{equation*}
 h_n(c) \defeq \pi_{n} \circ f
 \end{equation*}

By \autoref{dis:con} we know that $h_n$ is constant, hence $f$
is constant everywhere, it is enough to show that $f$ is constant.
% By Proposition \ref{prop:main} we know it is a constant function and
% we can observe that $h (\mathsf 0) = true$, can we infer that $\forall
% c : \tometa {\R_0}, \tometa f c = \tometa f (\mathsf 0)$


%  We only need to show that $\pi_1 \circ f$ (the actual sequence) is constant as the proof of being a Cauchy sequence is propositional.\footnote{Even if $\iscauchy$ is not a propositional predicate (as in \ref{eq:usedbytxa}), it will still be true that $m$ is constant. This is simply because $\sim$ is defined only in terms of the actual sequence part.} Again, by slight abuse of notation, we write $\tometa f : \tometa{\R_0} \to \tometa {\R_0}$, omitting the proof part of $f$.
 
%  Given $c : \tometa {\R_0}$, we want to show $\tometa f (c) = \tometa f (\mathsf 0)$, where $\mathsf 0$ is the sequence that is constantly $0$. 
%  To do so, it is enough to show that, for a given $k : \tometa \N$, we have $\tometa{f}(c)(k) = \tometa{f}(\mathsf 0)(k)$. 
%  If this was not true, we would have a function $\tometa \R \to \tometa \bool$, defined by 
%  \begin{equation*}
%   \lambda c . \mathsf{isEquval }\left(\tometa f (c)(k)\right) \left(\tometa f (\mathsf 0)(k)\right)
%  \end{equation*}
% that is not constant, contradicting Proposition \ref{prop:main}.
\end{proof}


\begin{corollary}
 There is no definable normalisation function on $\R_0$ in the sense
 of \autoref{def:nor}, namely $\R_0 / \sim$ is not definable via normalisation.
\end{corollary}




\section{Definability in general}


Even though we have proved that $\qset{\R_0}$ is not definable via normalisation, it does not imply that we cannot define the set of real numbers in minimalistic type theory with $\Pi, \Sigma, \mathsf{W}, =,
\N$. 

The meaning of definability is not clear enough for real numbers. To make it more precise, we define
it as whether there is a type $Q$ in $\mathsf{TT}$ (minimalistic type
theory) such that its embedding $\tometa A$ in $\mathsf{TT} + \mathsf{Q}$ (type theory
extended with quotient types) is isomorphic to $\qset{A}$ (where it is a valid type). 



We can easily prove that a definable quotient $(Q, [\_], emb)$ is isomorphic to $\qset{A}$ whose term is written as $[ a ]_{~}$ and a lifted function is written as $\hat{f}$.

\begin{proof}
We can establish the isomorphism with

$\Phi ~q =  [ \emb ~q ]_{\sim}$ and 

$\Psi ~ = \widehat{[\_]}$

To verify it $\Psi \circ \Phi = \text{id}_{Q}$ is given by

$\widehat{[  [ \emb ~q ]_{\sim} ]} = [\emb ~ q] = q$

and $\Phi \circ \Psi = \text{id}_{\qset{A}}$ namely,

$[\emb~\widehat{[s]}]_{\sim} = s$

can be proved using quotient induction principle and $Q-\textbf{Ax}$,

$[\emb~\widehat{[ [a]_{~} ]}]_{\sim} = [\emb~[a]]_{\sim} = [a]_{\sim}$

\end{proof}


For $\tometa {\R_0}/ \tometa \sim$, we conjecture that it is still not
definable.

\begin{proof}
Assume the set of real numbers is definable, we have a type $A$ and
its embedding in $\mathsf{TT} + \mathsf{Q}$  is $\tometa A \simeq \tometa {\R_0}/ \tometa \sim$. The isomorphism gives us a "normalisation" function $f : $ and a representative function
between $\tometa {\R_0}$ and $\tometa A$.
\end{proof}







\begin{remark}[\textbf{$\R_0$ is not Cauchy complete}]

Is our definition $\R_0$ Cauchy complete? In other
words, is there a representative Cauchy sequence as a limit for every
equivalence class (i.e.\ real number)? The answer is no. 

Recall that if for every Cauchy sequence of \textbf{real} numbers there is a real number as its limit, then we say it is Cauchy complete.

In classic logic, the Cauchy reals are Cauchy complete because the
limit can be built via a kind of diagonalization
\cite{DBLP:journals/entcs/Lubarsky07}. Also classically Cauchy reals are equivalent to another definition called Dedekind Reals.
However, in Type Theory both of them fail.
We cannot find a canonical representative for each equivalence
class. Intuitively speaking it is easy to find a canonical choice for
any rational number but it is impossible to find one for any
irrational number like $\pi$. It has been proved by Robert S. Lubarsky in
\cite{DBLP:journals/entcs/Lubarsky07}. If we add the axiom of Countable Choice ($AC_{\omega}$) to Type Theory, Cauchy reals become Cauchy complete because it provides us a choice function for equivalence classes which helps us find a canonical choice. The $AC_{\omega}$ is an classical result
which is stronger than the premise "in classical logic''.

In the HoTT book \cite{hott}, there is a higher inductive definition of Cauchy reals $\R_{C}$ using \textbf{Cauchy approximation}. Briefly speaking, it first embeds rational numbers, and then for each $s : \Q^{+} \to \R_{C}$ we have $lim(s) : R_{C}$ as a limit of Cauchy sequence of real numbers, hence it is Cauchy complete. Higher inductive type is a stronger notion than quotient type which allows us to define \emph{equality} of terms as constructors in inductive definitions, see \autoref{HITs}.
\end{remark}


\section{Other undefinable quotients}

\subsection{Unordered pairs}

In Set Theory, all sets are unordered, so unordered pairs are just sets of the form ${a, b}$ where $a$ is not equal to $b$.

In Type Theory, given a set $A$, $(a, b) : A \times A$ is an ordered pair. Unordered pair can be generated from the setoid $(A \times A, \sim)$ where

$$(a,b)\sim(b,a)$$

and $\sim$ is reflexive.

Intuitively, there is no canonical choice function unless the set $A$ has a decidable total order, hence the quotient $\qset{A \times A}$ is also undefinable via normalisation function.

\subsection{Finite multisets}

%\todo{decidable order -> of course definable, A-> N definable, give a  explicit proof}

%\todo{definable -> split quotient because definable is too general}

A multiset (bag) is a generalisation of set where multiple occurrences is allowed.

In Type Theory, given a set $A$, the finite multisets of elements in $A$ can be encoded as the setoid $(\text{List}~ A , \sim)$ where two lists are bag equivalent \cite{DBLP:conf/itp/Danielsson12} if they are equal up to reordering. For example, $[1, 2 , 2, 5 ,1]$ is equivalent to
$[2,2,1,1,5]$ since we can find a bijective mapping between them. We can observe that two such lists are always have the same length so we use length-explicit lists (vectors) here.

Given two lists of length $n$, $p ~ q : \text{Vec} ~A~n$,

$$ p \sim q \defeq \exists ~\phi : \text{Fin}~n \to \text{Fin}~n, \text{Bijection}~ \phi~ \wedge \forall x : \text{Fin}~n, p_x = q_{\phi(x)}$$

Finite multisets can be seen as unordered n-tuples which is a generalisation of unordered pairs. Therefore,
the quotient $\qset{\text{List}~ A}$ (or more accurately $\text{Vec}~ A~n$) is also not definable via normalisation function if it has no decidable well-ordering.


\subsection{Finite sets}

Considering that the notion multiset is a generalisation of set, it is natural to define finite set by modifying the equivalence relation. Here the length of two equivalent lists is not necessarily equal.
Given a set $A$ and two lists $l,m : \text{List}~ A$, $l$ is contained inside $m$ iff there is an injection from $l$ to $n$:


$$l \subseteq m \defeq \exists ~\phi : \text{Fin}~(\text{length} ~ l) \to \text{Fin}~ (\text{length} ~ m), \forall n : \text{Fin}~(\text{length} ~ l), l_n = m_{\phi (n)}$$

and two lists $l,m : \text{List}~ A$ are equivalent iff they contained the same elements:

$$l \sim m \defeq l \subseteq m \wedge m \subseteq l$$




%In fact a multiset can be defined as a pair of a set $A$ and a occurences counting function $m : A \to \N$. However from a practical perspective, it is not useful because we cannot count the cardinality of the multiset because $A$ is not necessary to be enumerable. But the unoroder list represent is countable.


\subsection{Partiality monad}


Given a set $A$, the set of partial computations over $A$ is encoded by partiality monad $\AgdaDatatype{Delay} ~\AgdaBound{A}$ (or $A_{\bot}$) with a weak bisimilarity $\AgdaDatatype{\_≈\_}$ ignoring finite delays.

The partiality monad is coinductively defined to encode delayed computation:

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{Delay} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{now} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{later} \AgdaSymbol{:} \AgdaDatatype{∞} \AgdaSymbol{(}\AgdaDatatype{Delay} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A}\<%
\\
\end{code}

We can postpone computations forever by using the constructor $\AgdaInductiveConstructor{later}$:
\begin{code}
\\
\>\AgdaFunction{never} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A}\<%
\\
\>\AgdaFunction{never} \AgdaSymbol{=} \AgdaInductiveConstructor{later} \AgdaSymbol{(}\AgdaCoinductiveConstructor{♯} \AgdaFunction{never}\AgdaSymbol{)}\<%
\\
\end{code}

It is a non-terminating program.

Two computations are strongly bisimilar if they are the
same after the same number of steps delay (there can be infinite
steps):

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_∼\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{now} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{now} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{∼} \AgdaSymbol{(}\AgdaInductiveConstructor{now} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{later} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{x∼y} \AgdaSymbol{:} \AgdaDatatype{∞} \AgdaSymbol{((}\AgdaFunction{♭} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{∼} \AgdaSymbol{(}\AgdaFunction{♭} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{∼} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\end{code}

If we ignore the number of steps a computation is postponed, we can define a weaker bisimilarity. 
Two computation are weakly bisimilar if they terminates with the
same value:

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_≈\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{now} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{↓} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{y} \AgdaDatatype{↓} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≈} \AgdaBound{y}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{later} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{x∼y} \AgdaSymbol{:} \AgdaDatatype{∞} \AgdaSymbol{((}\AgdaFunction{♭} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaSymbol{(}\AgdaFunction{♭} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\end{code}


where  $\AgdaBound{x} \AgdaDatatype{↓} \AgdaBound{y}$ means "x terminates with y":

\begin{code}
\\
\>\AgdaKeyword{infix} \AgdaNumber{4} \_↓\_\<%
\\
%
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_↓\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{nowT} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{now} \AgdaBound{a}\AgdaSymbol{)} \AgdaDatatype{↓} \AgdaBound{a}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{laterT} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{d} \AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{d} \AgdaDatatype{↓} \AgdaBound{a} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaSymbol{(}\AgdaCoinductiveConstructor{♯} \AgdaBound{d}\AgdaSymbol{))} \AgdaDatatype{↓} \AgdaBound{a}\<%
\\
\end{code}

It is equivalent to another definition inductively on either left side
or right side.


Given the partial monad and the weak bisimilarity, we obtain a quotient set representing
the set of all computations which is also undefinable.

\begin{proof}
Because there can be infinitely many  $\AgdaInductiveConstructor{later}$, we can not decide whether an element $a : A_{\bot}$ is equal to $\AgdaFunction{never}$ or not.

We can treat an element of $a : A_{\bot}$ as a sequence, for instance, set $a = \mathsf{later} ~ (\mathsf{later} ~ (\mathsf{now}~a))$, $a(1) =  \mathsf{later}$, $a(2) =  \mathsf{later}$, and $a(3) =  \mathsf{now}~a$. Then A standard metric space for $A_{\bot}$ can be given by

\begin{equation}
g(a_1,a_2) = 2^{-\mathsf{inf}\{k \in \N \; | a_1(k) \not= a_2(k)\}}
\end{equation}

Similar to the proof in \autoref{realconnected}, we are going to prove $A_{\bot}/\approx$ is connected, i.e.\ any definable (continuous) function $f : A_{\bot} \to \bool$ which respects $\approx$ is constant.

Thus we $f$ is non-constant, there are $a_1 , a_2 : A_{\bot}$ with $f(a_1) \not= f(a_2)$.

Assume $f(\mathsf{never}) = 1$, since $f$ is continuous, there exists $n_0 : \N$ such that for all $a : A_{\bot}$, if there are at least $n_0$ $\mathsf{laters}$ in $a$ (the first $n_0$ elements of sequence of $a$ coincide with those of $\mathsf{never}$), then $f(a) = f(\mathsf{never}) = 1$.

Because $f(a_1) \not= f(a_2)$, one of them must have $k < n_0$ $\mathsf{laters}$, assume it is $a_1$ and thus $f(a_1) = 0$. By adding $n_0 - k$  $\mathsf{laters}$, we obtain $a_{1}'$ such that $f(a_{1}') = f(a_1) = 0$ because $f$ respects $\approx$. However, $a_{1}'$ has $n_0$ $\mathsf{laters}$ such that $f(a_{1}') = f(\mathsf{never}) = 1$, contradicts to the just established statement.
\end{proof}


\section{Summary}

To summarize, for a possibly infinite sequences like Cauchy sequence or $A_0$, we have a property called local continuity.

\begin{definition}
\textbf{Local continuity}. given type $A$, Local continuity for type $\N \to A$ is the property that 

Given a discrete metric space $(B, g)$,

a definable function $f : (\N \to A) \to B$,

a sequence $s : \N \to A$,

there exists $n_0 : \N$ such that

for all sequences $t : \N \to A$ satisfying that $\forall i < n_0, s_i = t_i$,

we have that $f~s = f~t$

\end{definition}

And from the property that $f$ respects some equivalence relation, we can obtain a contradiction if $f$ is non-constant, which implies that there is no normalisation function for the setoid consisting of these kinds of sequences with given equivalence relations.




%conjecture: every quotient definable in pure type theory without quotient is split

%one way to prove it is any connected type is contractible.

%the question is still open.


%This will implies that reals are not only non-split but also undefianble in general.






