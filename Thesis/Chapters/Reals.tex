\chapter{Real numbers}
\label{rl}



In this chapter, we will discuss some other quotients which are not definable via normalisation, for example the set of real numbers as Cauchy sequences of rational numbers \cite{bis:85}, finite multisets represented by lists, and partiality computation which are represented by partiality monad.
Intuitively speaking there is no definable normalisation function which returns a canonical choice for each equivalence class. 
For the Cauchy sequences of rational numbers, Nicolai Kraus \cite{non-normal} has shown that all definable endofunctions respect the equivalence relation have to be constant, hence it is impossible to define a normalisation function. We reproduce the proof here and extend it to other cases especially the partiality monad. It has to be noticed that the proof is conducted in basic \mltt and can be generalised to any extension as long as it admits the Brouwer's continuity principle i.e.\ definable functions are continuous \cite{DBLP:journals/bsl/AttenD02}.


%\begin{theorem}\label{defcon}Brouwer's continuity principleAll definable functions are continuous.\end{theorem}


\section{Definability via normalisation}

Although we have provided the definition of \emph{definable quotients} (see \autoref{defquo}), it is not always the case that the quotient set can be inductively defined so that we can talk about normalisation function as $[\_] : A \to Q$. Therefore, we provide a different characterisation of the property which only talks about a setoid $(A,\sim)$.

\begin{definition}[\textbf{Definable via normalisation}]\label{def:nor}
Given a setoid $(A,\sim)$, the quotient $\qset{A}$ is definable via normalisation if there is an endofunction $[\_]_0$ which is a \emph{normalisation function}:

\begin{itemize}

\item $[\_]_0 : A \to A$

\item $\sound : \forall (a,b : A) \to a \sim b \to [ a ]_0 = [ b ]_0$

\item $\complete : \forall (a : A) \to [ a ]_0 \sim a$

\end{itemize}
\end{definition}

It is actually equivalent to say there is a definable quotient:
First, given $[\_]_0 : A \to A$ specified as above,

\begin{itemize}
\item The quotient set can be defined as
  $$Q \defeq \Sigma (a : A), [ a ]_0 = a$$

\item The "normalisation function" is
  $$[a] \defeq ([a]_0, \trefl ) $$
which is also sound because $[\_]_0$ is sound.

\item The embedding function is just first projection
  $$\emb \defeq \pi_1 $$

\item Stability: given $(a, p) : \Sigma (a : A), [ a ]_0 = a$

$$[\emb(a,p)] \equiv ([a]_0, \trefl )$$

Hence we need to prove $([a]_0, \trefl ) = (a, p)$.

We can prove it by $\J$

$$\J(t,[ a ]_0,a,p) : ([a]_0, \trefl ) = (a, p)$$

where $t(x) \defeq \trefl : (x,\trefl ) = (x,\trefl )$

\item Completeness: given $a : A$, we need to prove $\emb[a] \sim a$ which turns out to be

$$[a]_0 \sim a$$

This is exactly the completeness property in the specification of $[\_]_0$

\end{itemize}

In the other direction, given a definable quotient,

\begin{itemize}

\item $$[\_]_0 \defeq \emb \circ [\_]$$

\item Soundness: given $a,b : A$ such that $a \sim b$, because $[\_]$ is sound, we know

$$[ a ] = [ b ]$$

By congruence rule,

$$\emb[a] = \emb [ b]$$

hence $[\_]_0$ is sound as well.


\item Completeness: given $a : A$, $\emb[a] \sim a$ is just the completeness property of the definable quotient.

\end{itemize}



\section{Real numbers as Cauchy sequences}


The real numbers can be defined as $(\R_0,\sim)$, where $\R_0$ is the set of Cauchy sequences, and 
two Cauchy sequences are equivalent if and only if their point-wise difference converges to $0$.


\begin{definition}\label{R01}

A function $f : \N \to \Q$ is called a \textbf{Cauchy sequence} if 

 \begin{equation}
 \iscauchy(f) \defeq \forall(\varepsilon
  :\Q^{+}) \to \exists (m:\N) ~ \forall (i:\N) \to i>m\to \vert  f_i -
  f_m \vert  <\varepsilon
\end{equation}

Hence we can define $\R_0$ as

$$\R_0 \defeq \Sigma (f : \N \to \Q) ~\iscauchy(f)$$
\end{definition}

Two Cauchy sequences are equivalent if and only if their point-wise difference converges to $0$:

$$r \sim s \defeq \forall (\varepsilon :\Q^{+}) \to \exists (m:\N) ~
\forall (i:\N) \to i>m\to \vert  r_i - s_i \vert <\varepsilon$$


%$$\R_{0} = \set{f : \N\to\Q \mid \forall\varepsilon :\Q^{+}, \exists m:\N, \forall i:\N, i>m\to \vert  f_i - f_m \vert  <\varepsilon}$$

To implement this definition, the existential quantifier is usually encoded by $\Sigma$-types so that we can guess the real number from the explicit witness $m$.
However, usually we would like to keep the proof propositional so that the Cauchy sequences are proof-irrelevant. 

To avoid this problem, we can use an alternative equivalent definition of the property, but the type of $f$ has to be $\PN \to \Q$:

\begin{equation}\label{R02}
\iscauchy(f) \defeq \forall (k :\PN),\forall (m , n > k) \to \vert  f_m -
  f_n \vert  < \frac{1}{k}
\end{equation}

The rate of convergence is fixed so that we can guess the number while the condition is also propositional. Note that we use some shorthand notations in these definitions.


We can slightly modify the definition which is still equivalent, 

\begin{equation}\label{R03}
\iscauchy(f) \defeq \forall (n,m :\PN), n > m \to \vert f_n -
  f_m \vert  < \frac{1}{n}
\end{equation}

%$$\R_0'' = \set{f: \PN\to\Q \mid \forall n ~m  :\PN, n > m \to \vert f_n -  f_m \vert  < \frac{1}{n}}$$ \label{R03}


\subsection{$\R$ is undefinable via normalisation}

We can define a setoid $(\R_0,\sim)$, but there is no definable normalisation function $[\_]_0: \R_0 \to \R_0$ in the sense of \ref{def:nor}.


We have made an attempt to prove that the set of reals is undefinable in the presence of local continuity (see Section. 5 in \cite{aan}). 
We claim that two $a,b : A$ are \emph{separable}, if there exists a definable test $P : A \to \bool$ such that $P(a) \neq P(b)$. Then we claim a definable set $A$ is \emph{discrete} if $a \neg b$ always imply $a$ and $b$ are separable. However it has some problems as  Martín Escardó pointed out.
He provides a counterexample that for two distinguishable terms i.e.\ $a \neg b$ there can be no definable test \cite{martinsproof}. We sketch the proof here:

\begin{proof}
In the proof, he uses $\N_\infty \defeq \N \to \bool$ which is a decreasing sequence of $\bool$ called \emph{generic convergent sequence}. Intuitively speaking, $11000\ldots$ represents $2$ and the sequence of $1$, namely $1111\ldots$ represents $\infty$, therefore, it can be seen as the disjoint union of natural numbers and infinity i.e.\ $\N + \infty$. 
For simplicity, we write $s_k$ for the sequence whose first $k$ digits are $1$ and the rest digits are $0$.

From continuity, we know that:

given any definable function $f : \N_\infty \to \bool$, there exists $n : \N$ such that for all $s_k : \N_\infty$ ($k \geq n$) whose first $n$ digits coincide with $\infty$,  $f(s_k) = f(\infty)$.

Set 
$X \defeq \Sigma u : \N_\infty, u = \infty \to \bool$,

$s^0_k \defeq (s_k, \lambda r \to 0)$ and 

$s^1_k \defeq (s_k, \lambda r \to 1)$,

there are two definitional unequal terms of $X$, $\infty_0 = s^0_\infty$ and $\infty_1 = s^1_\infty$,

such that for all definable function $f : X \to \bool$, $f(\infty_0) = f(\infty_1)$.

To prove it, assume $f(\infty_0) \not= f(\infty_1)$.
We can prove that for all $k : N$ such that ($s_k \not= \infty$), 

$$f(s^0_k) = f(s^1_k)$$ 

because the second part is always the same due to the fact that $s_k \not= \infty$. From continuity, we can deduce that 

$$f(\infty_0) =f(s^0_k) = f(s^1_k) = f(\infty_1)$$

which contradicts our premise.
\end{proof}


Here we show a meta-level proof to show that all definable endofunctions are constant, hence no normalisation function is definable. The proof is not original.

%\begin{definition}
%\textbf{Discrete type}.

%A type $A$ is discrete if there exists a definable test $P : A \to \textbf{2}$ such that $\forall a~ b ∶ A, a \neq b \to P ~a \neq P~ b$.
%\end{definition}



%We have made an attempt in the original version of our \cite{aan} draft, but there is something important problem pointed out by Martin Escardo. Laterly, Nicolai Kraus suggests to fix the proof by proving it as a meta-theoretical property. We will show an adaption of his proof here.

\subsection{Preliminaries}

We use some topological notions. Recall that a metric space is a set where a notion of distance (called a metric) between elements of the set is defined. It is an ordered pair $(M , d)$ where $M$ is a set and d is a metric on $M$:
\begin{enumerate}
\item $M$ is a set,
\item and $d : M \times M \rightarrow \R$ s.t.
\item $d (x , y) = 0 \iff x = y$
\item $d(x,y)=d(y,x)$
\item $d(x,y)+d(y,z) \ge d(x,z)$ 
\end{enumerate}

We can usually give a standard topological structure for sequences over a discrete type. In the case of the sequences over $\R_0$, the distance between two functions $f_1,f_2 : \PN \to \R_0$ can be defined as

\begin{equation}
d(f_1,f_2) = 2^{-\mathsf{inf}\{k \in \PN \; | \; f_1(k) \not= f_2(k)\}}
\end{equation}

and then $\PN \to \R_0$ is a metric space. 
%If the type of $\iscauchy(f)$ is not propositional, then it is possible that the distance between two non-equal

%Technically, if we define $\R_0$ as \ref{R01}, there would be different proof terms for the same sequence which means the distance between two non-equal elements may be $0$, hence not metric space.

Given two metric spaces $(X, d)$ and $(Y, e)$, a function $f : X \to Y$ is \emph{continuous} if for every $x : X$ and $\epsilon > 0$ there exists a $\delta > 0$ such that

$$\forall y : X, d(x,y) < \delta \Rightarrow e(f(x),f(y)) < \epsilon$$

With the standard topological structures, we say that definable functions are \emph{continuous}.
Intuitively speaking, for a function $f : (\PN \to \Q) \to \bool$, it only inspects finite many terms of the input sequences to compute the result.


We also need an auxiliary definition:

\begin{definition}
 For a sequence $f : \PN \to \Q$, we say that $f$ is \emph{Cauchy with
   factor $k$}, written as $\iscauchy_k$, for some $k \in \Q^+$, if
 \begin{equation}
  \iscauchy_k ~ f \; \defeq \; \forall n ~m : \PN, n < m \to |f_n - f_m| < \frac 1 {k \cdot n}. \label{eq:cauchy-aux}
 \end{equation}
\end{definition}

The usual Cauchy condition $\iscauchy$ is therefore ``Cauchy with factor $1$''.

Now we have enough tools to prove the following proposition.

\begin{proposition} \label{prop:main}
 \textbf{$\R_0 / \sim$ is connected}. In Type Theory, it means that any continuous function
$$f : \R_0 \to \bool$$
 which respects $\sim$ (is compatible with $\sim$) is \emph{constant}.
\end{proposition}


\begin{proof}\label{realconnected}

The general idea is to interpret our definition in classical \maths,
assume we have a non-constant function and deduce a contradiction.
Consider the ``naive'' set model (with ``classical standard \maths'' as meta-theory). This clearly works if we are in a minimalistic type theory with $\Pi$, $\Sigma$, $\mathsf{W}$, $=$, $\mathbb N$; however, if we restrict ourselves to the types in the lowest universe of homotopy type theory (which is enough), it also works for HoTT.
 We use $\tometa \cdot$ as an interpretation function; 
 for example, we write $\R$ for the field of real numbers which can be defined as $\tometa {\R_0} / \tometa{\sim}$. 
 By abuse of notation, we write $\tometa {\R_0}$ for the set of Cauchy sequences in the model that fulfil the Cauchy condition, without the actual proof thereof. This is justified as this property is propositional. 
 
 For readability, we use the symbol $=$ for equality in the theory as well in the model, and we do not use the semantic brackets for natural numbers such as $2$ or $4$.
 In the model, we use $\clim \cdot : \tometa {\R_0} \to \R$ as the
 function that gives us the limit of a Cauchy sequence (Not all
 functions in the ``naive'' set model have to be continuous).
 Thus, for $r : \R_0$, we write $\climeta r \in \R$ for the real number it represents.

Assume $f, p$ are given. We prove that $\tometa f : \tometa {\R_0} \to \tometa \bool$ is constant in the model, which implies the statement of \autoref{prop:main}.

Thus, assume $\tometa f$ is non-constant,  there are $c_1, c_2 : \tometa {\R_0}$ with $\tometa f(c_1) \not= \tometa f(c_2)$. 

 Define
 \begin{align}
  m_1 & \defeq \mathsf{sup} \{\clim d \in \R \; | \; d \in \tometa {\R_0}, \clim d \leq \mathsf{max}(\clim{c_1}, \clim{c_2}), \tometa f(d) = \tometa \btrue \}\\
  m_2 & \defeq \mathsf{sup} \{\clim d \in \R \; | \; d \in \tometa {\R_0}, \clim d \leq \mathsf{max}(\clim{c_1}, \clim{c_2}), \tometa f(d) = \tometa \bfalse \}
 \end{align}
 (note that one of these two necessarily has to be $\clim{c_1}$ or $\clim{c_2}$, whichever is bigger).
 Set $m \defeq \mathsf{min}(m_1,m_2)$, because $m$ is a supremum, we can observe that in
 \emph{every} neighbourhood $U$ of $m$, given any $t$,
we can always find another point $x \in U$ such that $x = \clim e$
(for some $e$) with $\tometa f(e) \not= \tometa f(t)$. 


 Let $c \in \tometa {\R_0}$ be a Cauchy sequence such that $\clim c = m$. 
 We may assume that $c$ satisfies the condition
 $\tometa{\iscauchy_5}$.
%  The slight difference ($\frac 1 n$ is replaced by $\frac 1 {4n}$) will be important.
%  Without loss of generality, assume $\tometa{f}(c) = \tometa \btrue$. % not needed.
 
 As $f$ is definable (and thereby $\tometa f$ is continuous, for an arbitrary $\epsilon < 1$, there exists $n_0 \in \tometa {\N}$ such that for any Cauchy
 sequence $c' \in \tometa {\R_0}$, if the first $n_0$ sequence
 elements of $c'$ coincide with those of $c$ (namely the distance
 $g(c, c') = 2^{-\mathsf{inf}\{k \in \N \; | \; c(k) \not= c'(k)\}}
 \leq 2^{-{n_0}}$ ), then $h (\tometa f(c), \tometa f(c'))< \epsilon < 1$, hence $\tometa f(c') = \tometa f(c)$. 

 Write $U \subset \tometa {\R_0}$ for the set of Cauchy sequences which fulfil this property, and $\clim U \defeq \{\clim d \; | \; d \in U\}$ for the set of reals that $U$ corresponds to.
 We claim that $\clim U$ is a neighbourhood of $m$ by proving an open interval $I \defeq (m - \frac 1 {2n_0} , m+ \frac 1 {2n_0})$ is contained in $\clim U$, i.e.\ $m \in I \subset \clim U$.

 Let $x \in I$, there is a Cauchy sequence $t : \tometa {\R_0}$ such that $\clim t = x$ and we may assume that $t$ satisfies the condition $\tometa {\iscauchy_{5n_0}}$.

 Let us now ``concatenate'' the first $n_0$ elements of the sequence $c$ with $t$, that is, define
 \begin{align}
  &g : \tometa{\PN \to \Q} \\
  &g (n) = \begin{cases}
            c(n) & \text{if $n \leq n_0$} \\
            t(n-n_0) & \text{else}.
           \end{cases}
 \end{align}

 Observe that $g$ is also a Cauchy sequence, i.e. $\tometa \iscauchy(g)$: The only thing that needs to be checked is whether the two ``parts'' of $g$ work well together. Let $0 < n \leq n_0$ and $m > n_0$ be two natural numbers. We need to show that
 \begin{equation}
  |g(n) - g(m)| < \frac 1 n.
 \end{equation}
 Calculate
 \begin{align}
  & \quad |g(n) - g(m)| \\
  = & \quad|c(n) - t(m - n_0)| \\
  = & \quad |c(n) - \clim c + \clim c - \clim t + \clim t - t(m - n_0)| \\
  \leq & \quad | c(n) - \clim c | + |\clim c - \clim t| + |\clim t - t(m - n_0)| \\
  \leq &  \quad  \frac{1}{5n}  + \frac{1}{2n_0} + \frac{1}{5n_0 \cdot (m-n_0)} \\
  \leq &  \quad  \frac{1}{5n}  + \frac{1}{2n} + \frac{1}{5n_0} \\
  <  & \quad \frac 1 n
 \end{align}

From the continuity property of $f$ and the definition of
$g$ we know that $\tometa f (g) = \tometa f(c)$. Clearly, $\clim g =
\clim t = x \in I$. 

Therefore \emph{all} $s \in \tometa {\R_0}$ with $\clim
s \in I$, we can use the "concatenation'' approach to find a $g$
satisfies $s \, \tometa \sim \,  g$ (namely $\clim s = \clim g$), and by the condition that $f$ (and
thereby $\tometa f$) respects $\sim$, we can conclude that $\tometa f
(s) = \tometa f (g) = \tometa f(c)$, thus $\clim U$ is a neighbourhood of $m$.
However, as we have seen, in \emph{every} neighbourhood of $m$, and thus in particular in $(m - \frac 1 {2n_0} , m+ \frac 1 {2n_0})$, we can always find an $x$ such that $x = \clim e$ (for some $e$) with $\tometa f(e) \not= \tometa f(c)$ which contradicts to the just established statement.
\end{proof}


%  It is easy to see that $g$ is a Cauchy sequence, i.e. $\tometa \iscauchy(g)$,\footnote{Of course, this is why we needed $\iscauchy_5$ instead of $\iscauchy$ earlier. The $5$ is somewhat arbitrary (todo: think about what is actually needed).} with $\clim g = x$. Further, the first $n_0$ elements of $g$ coincide with those of $c$, and thus, $\tometa f(g) = \tometa f(c)$.

We can easily generate similar proofs by replacing $\bool$ by any discrete type, hence the proposition "$\R_0 / \sim$ is connected'' implies that:

\begin{corollary}\label{dis:con}
Any continuous function from $\R_0$ to any discrete type that respects $\sim$ is constant.
\end{corollary}



\begin{theorem}
Any continuous endofunction $f$ on $\R_0$ that respects $\sim$ is constant
\end{theorem}

\begin{proof}

Assume we have $f,p$ as required. 

To prove $f$ is constant, it is enough to show that the sequence part is
constant because the proof part is propositional. Again, by slight abuse of notation, we write $\tometa f : \tometa{\R_0} \to \tometa {\R_0}$, omitting the proof part of $f$.
 

Given a positive natural number $n : \tometa \PN$, we have a projection
function $\pi_{n} : \tometa{ \R_0} \to \tometa \Q$. Define a function
$h_n : \tometa {\R_0} \to \tometa \Q$ as

 \begin{equation*}
 h_n \defeq \pi_{n} \circ f
 \end{equation*}

By \autoref{dis:con} we know that $h_n$ is constant, hence $f$
is constant everywhere, it is enough to show that $f$ is constant.
% By Proposition \ref{prop:main} we know it is a constant function and
% we can observe that $h (\mathsf 0) = true$, can we infer that $\forall
% c : \tometa {\R_0}, \tometa f c = \tometa f (\mathsf 0)$


%  We only need to show that $\pi_1 \circ f$ (the actual sequence) is constant as the proof of being a Cauchy sequence is propositional.\footnote{Even if $\iscauchy$ is not a propositional predicate (as in \ref{eq:usedbytxa}), it will still be true that $m$ is constant. This is simply because $\sim$ is defined only in terms of the actual sequence part.} Again, by slight abuse of notation, we write $\tometa f : \tometa{\R_0} \to \tometa {\R_0}$, omitting the proof part of $f$.
 
%  Given $c : \tometa {\R_0}$, we want to show $\tometa f (c) = \tometa f (\mathsf 0)$, where $\mathsf 0$ is the sequence that is constantly $0$. 
%  To do so, it is enough to show that, for a given $k : \tometa \N$, we have $\tometa{f}(c)(k) = \tometa{f}(\mathsf 0)(k)$. 
%  If this was not true, we would have a function $\tometa \R \to \tometa \bool$, defined by 
%  \begin{equation*}
%   \lambda c . \mathsf{isEquval }\left(\tometa f (c)(k)\right) \left(\tometa f (\mathsf 0)(k)\right)
%  \end{equation*}
% that is not constant, contradicting Proposition \ref{prop:main}.
\end{proof}


\begin{corollary}
 There is no definable normalisation function on $\R_0$ in the sense
 of \autoref{def:nor}, namely $\qset{\R_0}$ is not definable via normalisation.
\end{corollary}


Even though there is no definable endofunctions, it does not imply that we cannot define the set of real numbers, although we believe it is the case. In fact, Kraus have made a conjecture that for a definable type $T$ in minimalistic type theory with $\Pi$, $\Sigma$, $\mathsf{W}$, $=$, $\mathbb N$, if $T$ does have two distinguishable elements, then it is not connected. Because $\qset{\R_0}$ is connected, this conjecture implies that the the set of real numbers are not definable.



\begin{remark}[\textbf{$\R_0$ is not Cauchy complete}]

Is our definition $\R_0$ Cauchy complete? In other
words, is there a representative Cauchy sequence as a limit for every
equivalence class (i.e.\ real number)? The answer is no. 

Recall that if for every Cauchy sequence of \textbf{real} numbers there is a real number as its limit, then we say it is Cauchy complete.

In classical logic, the Cauchy reals are Cauchy complete because the
limit can be built via a kind of diagonalization
\cite{DBLP:journals/entcs/Lubarsky07}. Also classically Cauchy reals are equivalent to another definition called Dedekind Reals.
However, in Type Theory both of them are not representable.
We cannot find a canonical representative for each equivalence
class. Intuitively speaking it is easy to find a canonical choice for
any rational number but it is impossible to find one for any
irrational number like $\pi$. It has been proved by Robert S. Lubarsky in
\cite{DBLP:journals/entcs/Lubarsky07}. If we add the axiom of Countable Choice ($AC_{\omega}$) to Type Theory, Cauchy reals become Cauchy complete because it provides us a choice function for equivalence classes which helps us find a canonical choice. The $AC_{\omega}$ is a classical result
which is stronger than the premise "in classical logic''.

In the HoTT book \cite{hott}, there is a higher inductive definition of Cauchy reals $\R_{C}$ using \textbf{Cauchy approximation}. Briefly speaking, it first embeds rational numbers, and then for each $s : \Q^{+} \to \R_{C}$ we have $lim(s) : R_{C}$ as a limit of Cauchy sequence of real numbers, hence it is Cauchy complete. Higher inductive type allows us to define \emph{equality} of terms as constructors in inductive definitions, see \autoref{HITs}.
\end{remark}


\section{Other undefinable quotients}

\subsection{Unordered pairs}

In Set Theory, all sets are unordered, so unordered pairs are just sets of the form ${a, b}$ where $a$ is not equal to $b$.

In Type Theory, given a set $A$, $(a, b) : A \times A$ is an ordered pair. Unordered pair can be generated from the setoid $(A \times A, \sim)$ where

$$(a,b)\sim(b,a)$$

and $\sim$ is reflexive.

Intuitively, there is no canonical choice function unless the set $A$ has a decidable total order, hence the quotient $\qset{A \times A}$ is also undefinable via normalisation function.

\subsection{Finite multisets}

%\todo{decidable order -> of course definable, A-> N definable, give a  explicit proof}

%\todo{definable -> split quotient because definable is too general}

A multiset (bag) is a generalisation of set where multiple occurrences are allowed.

In Type Theory, given a set $A$, the finite multisets of elements in $A$ can be encoded as the setoid $(\text{List}~ A , \sim)$ where two lists are bag equivalent \cite{DBLP:conf/itp/Danielsson12} if they are equal up to reordering. For example, $[1, 2 , 2, 5 ,1]$ is equivalent to
$[2,2,1,1,5]$ since they are permutation of each other. We can observe that two such lists always have the same length so we use length-explicit lists (vectors) here.

Given two lists of length $n$, $p ~ q : \text{Vec} ~A~n$,

$$ p \sim q \defeq \exists ~\phi : \text{Fin}~n \to \text{Fin}~n, \text{Bijection}~ \phi~ \wedge \forall x : \text{Fin}~n, p_x = q_{\phi(x)}$$

Finite multisets can be seen as unordered n-tuples which is a generalisation of unordered pairs. Therefore,
the quotient $\qset{\text{List}~ A}$ (or more accurately $\text{Vec}~ A~n$) is also not definable via normalisation function if it has no decidable well-ordering.

\subsection{Partiality monad}


Given a set $A$, the set of partial computations over $A$ is encoded by the partiality monad $\AgdaDatatype{Delay} ~\AgdaBound{A}$ (or $A_{\bot}$) with a weak bisimilarity $\AgdaDatatype{\_≈\_}$ ignoring finite delays.

The partiality monad is coinductively defined to encode delayed computation:

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{Delay} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{now} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{later} \AgdaSymbol{:} \AgdaDatatype{∞} \AgdaSymbol{(}\AgdaDatatype{Delay} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A}\<%
\\
\end{code}

We can postpone computations forever by using the constructor $\AgdaInductiveConstructor{later}$:
\begin{code}
\\
\>\AgdaFunction{never} \AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A}\<%
\\
\>\AgdaFunction{never} \AgdaSymbol{=} \AgdaInductiveConstructor{later} \AgdaSymbol{(}\AgdaCoinductiveConstructor{♯} \AgdaFunction{never}\AgdaSymbol{)}\<%
\\
\end{code}

It is a non-terminating program.

Two computations are strongly bisimilar if they are the
same after the same number of steps delay (there can be infinite
steps):

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_∼\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{now} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{now} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{∼} \AgdaSymbol{(}\AgdaInductiveConstructor{now} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{later} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{x∼y} \AgdaSymbol{:} \AgdaDatatype{∞} \AgdaSymbol{((}\AgdaFunction{♭} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{∼} \AgdaSymbol{(}\AgdaFunction{♭} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{∼} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\end{code}

If we ignore the number of steps a computation is postponed, we can define a weaker bisimilarity. 
Two computation are weakly bisimilar if they terminate with the
same value:

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_≈\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{now} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y} \AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{↓} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{y} \AgdaDatatype{↓} \AgdaBound{a} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≈} \AgdaBound{y}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaInductiveConstructor{later} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{x} \AgdaBound{y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaBound{x∼y} \AgdaSymbol{:} \AgdaDatatype{∞} \AgdaSymbol{((}\AgdaFunction{♭} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaSymbol{(}\AgdaFunction{♭} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{x}\AgdaSymbol{)} \AgdaDatatype{≈} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\end{code}


where  $\AgdaBound{x} \AgdaDatatype{↓} \AgdaBound{y}$ means "x terminates with y":

\begin{code}
\\
\>\AgdaKeyword{infix} \AgdaNumber{4} \_↓\_\<%
\\
%
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_↓\_} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{\}} \AgdaSymbol{:} \AgdaDatatype{Delay} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{nowT} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{now} \AgdaBound{a}\AgdaSymbol{)} \AgdaDatatype{↓} \AgdaBound{a}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{laterT} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{d} \AgdaBound{a}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{d} \AgdaDatatype{↓} \AgdaBound{a} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaInductiveConstructor{later} \AgdaSymbol{(}\AgdaCoinductiveConstructor{♯} \AgdaBound{d}\AgdaSymbol{))} \AgdaDatatype{↓} \AgdaBound{a}\<%
\\
\end{code}

It is equivalent to another definition inductively on either left side
or right side.


Given the partial monad and the weak bisimilarity, we obtain a quotient set representing
the set of all computations which is also undefinable.

\begin{proof}
Because there can be infinitely many  $\AgdaInductiveConstructor{later}$, we can not decide whether an element $a : A_{\bot}$ is equal to $\AgdaFunction{never}$ or not.

We can treat an element of $a : A_{\bot}$ as a sequence, for instance, set $a = \mathsf{later} ~ (\mathsf{later} ~ (\mathsf{now}~a))$, $a(1) =  \mathsf{later}$, $a(2) =  \mathsf{later}$, and $a(3) =  \mathsf{now}~a$. Then A standard metric space for $A_{\bot}$ can be given by

\begin{equation}
g(a_1,a_2) = 2^{-\mathsf{inf}\{k \in \N \; | a_1(k) \not= a_2(k)\}}
\end{equation}

Similar to the proof in \autoref{realconnected}, we are going to prove $A_{\bot}/\approx$ is connected, i.e.\ any definable (continuous) function $f : A_{\bot} \to \bool$ which respects $\approx$ is constant.

Thus if $f$ is non-constant, there are $a_1 , a_2 : A_{\bot}$ with $f(a_1) \not= f(a_2)$.

Assume $f(\mathsf{never}) = 1$, since $f$ is continuous, there exists $n_0 : \N$ such that for all $a : A_{\bot}$, if there are at least $n_0$ $\mathsf{laters}$ in $a$ (the first $n_0$ elements of sequence of $a$ coincide with those of $\mathsf{never}$), then $f(a) = f(\mathsf{never}) = 1$.

Because $f(a_1) \not= f(a_2)$, one of them must have $k < n_0$ $\mathsf{laters}$, assume it is $a_1$ and thus $f(a_1) = 0$. By adding $n_0 - k$  $\mathsf{laters}$, we obtain $a_{1}'$ such that $f(a_{1}') = f(a_1) = 0$ because $f$ respects $\approx$. However, $a_{1}'$ has $n_0$ $\mathsf{laters}$ such that $f(a_{1}') = f(\mathsf{never}) = 1$, contradicts to the just established statement.
\end{proof}


\section{Summary}

To summarize, we have shown some quotients which are not definable via normalisation, e.g.\ real numbers as Cauchy sequences of rational numbers, paritial computation as partial monad and finite multisets as lists. 

In particular, we show that the set of real numbers as $\qset{\R_0}$ is connected which means that any definable (continuous) function on $\R_0 \to \bool$ which respects $\sim$ is constant. It implies that any definable endofunction on $\R_0$ is constant, hence there is no definable normalisation function for the setoid $(\R_0,\sim)$ that can be lifted. 
We similarly proved that the partiality computations which are represented by partiality monad quotiented by weak bisimilarity is also not defiable via normalisation. We also discussed that unorderd pairs and finite multisets which are pairs or lists quotiented by permutation are only definable via normalisation in general, if we have a decidable total order. 

We also believe that these quotients are not definable in general, but we have not yet prove it formally.





%conjecture: every quotient definable in pure type theory without quotient is split

%one way to prove it is any connected type is contractible.

%the question is still open.


%This will implies that reals are not only non-split but also undefianble in general.






