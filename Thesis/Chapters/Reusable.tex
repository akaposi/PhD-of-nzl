
The type construction is not complete because it also includes lambda abstraction and function application which correspond to introduction and elimination rules respectively. The verification of $\beta$ and $\eta$ laws are also essential, but we have not implemented them in Agda due to technical difficulties. The problem is that type-checking of them results in stack overflow. Hopefully the problems will be fixed by later patches.







Due to the record type mechanism in Agda, given a type $A : \text{Ty} ~\Gamma$, one has to write $\text{substT} ~A$ to use the field. For readability, we adopt a better syntax using renaming of fields to highlight the precise types or terms in the style of $\text{[} ~A ~\text{]substT}$ , but the detailed code is also omitted here. Indeed, an example can be found in the above code where we already adopt the syntax style for internal equivalence of setoids.


substLast : {Γ : Con}{A Q : Ty Γ}
     → (f : Tm (A ⇒ Q)) → (Γ & A) ⇉ (Γ & Q)
substLast {Γ} {A} {Q} f = record 
        { fn = λ {(x , a) → x , f' x a}
        ; resp = λ {x} {y} → λ {(p , q) → p , [ [ Q ]fm _ ]trans ([ Q ]subst* _ {!!}) ([ f ]respt p (proj₂ y))}
        }

   where
     f' : (x : ∣ Γ ∣) → ∣ [ A ]fm x ∣ → ∣ [ Q ]fm x ∣ 
     f' x = prj₁ ([ f ]tm x)

     .f-resp2 : ∀ {x x' y z} → (p : [ Γ ] x' ≈ x) → [ [ Q ]fm x ] 
      f' x y ≈ f' x ([ A ]subst p z)
     f-resp2 p = {! [ A ⇒ Q ]subst* p!}






     


  lift-op1 : (f : A → A) → (f-sound : ∀ a b → a ~ b → f a ~ f b) → (Q → Q)
  lift-op1 f sound = [_] ∘ f ∘ emb


  lift-op1-resp : ∀ a → (f : A → A) → (f-sound : ∀ a b → a ~ b → f a ~ f b) 
                → lift-op1 f f-sound [ a ] ≡ [ f a ]
  lift-op1-resp a f f-sound = [ f-sound _ _ (complete _) ]⁼

  lift-prop : (P : (A : Set) → (f : A → A) → Set)
              (f : A → A) →
              (f-sound : ∀ a b → a ~ b → f a ~ f b) →
              (∀ a → f (f a) ~ a) → (∀ q → (lift-op1 f f-sound) (lift-op1 f f-sound q) ≡ q)
  lift-prop P f f-sound pa q = trans [ (~-trans (f-sound _ _ (complete _)) (pa (emb q))) ]⁼ (stable q)




\subsection{Finite sets}

Considering that the notion multiset is a generalisation of set, it is natural to define finite set by modifying the equivalence relation. Here the length of two equivalent lists is not necessarily equal.
Given a set $A$ and two lists $l,m : \text{List}~ A$, $l$ is contained inside $m$ iff there is an injection from $l$ to $n$:


$$l \subseteq m \defeq \exists ~\phi : \text{Fin}~(\text{length} ~ l) \to \text{Fin}~ (\text{length} ~ m), \forall n : \text{Fin}~(\text{length} ~ l), l_n = m_{\phi (n)}$$

and two lists $l,m : \text{List}~ A$ are equivalent iff they contained the same elements:

$$l \sim m \defeq l \subseteq m \wedge m \subseteq l$$




%In fact a multiset can be defined as a pair of a set $A$ and a occurences counting function $m : A \to \N$. However from a practical perspective, it is not useful because we cannot count the cardinality of the multiset because $A$ is not necessary to be enumerable. But the unoroder list represent is countable.




To summarize, for a possibly infinite sequences like Cauchy sequence or $A_0$, we have a property called local continuity.

\begin{definition}
\textbf{Local continuity}. given type $A$, Local continuity for type $\N \to A$ is the property that 

Given a discrete metric space $(B, g)$,

a definable function $f : (\N \to A) \to B$,

a sequence $s : \N \to A$,

there exists $n_0 : \N$ such that

for all sequences $t : \N \to A$ satisfying that $\forall i < n_0, s_i = t_i$,

we have that $f~s = f~t$

\end{definition}

And from the property that $f$ respects some equivalence relation, we can obtain a contradiction if $f$ is non-constant, which implies that there is no normalisation function for the setoid consisting of these kinds of sequences with given equivalence rela



\section{Definability in general}


Even though we have proved that $\qset{\R_0}$ is not definable via normalisation, it does not imply that we cannot define the set of real numbers in minimalistic type theory with $\Pi, \Sigma, \mathsf{W}, =,
\N$. 

The meaning of definability is not clear enough for real numbers. To make it more precise, we define
it as whether there is a type $Q$ in $\mathsf{TT}$ (minimalistic type
theory) such that its embedding $\tometa A$ in $\mathsf{TT} + \mathsf{Q}$ (type theory
extended with quotient types) is isomorphic to $\qset{A}$ (where it is a valid type). 



We can easily prove that a definable quotient $(Q, [\_], emb)$ is isomorphic to $\qset{A}$ whose term is written as $[ a ]_{~}$ and a lifted function is written as $\hat{f}$.

\begin{proof}
We can establish the isomorphism with

$\Phi ~q =  [ \emb ~q ]_{\sim}$ and 

$\Psi ~ = \widehat{[\_]}$

To verify it $\Psi \circ \Phi = \text{id}_{Q}$ is given by

$\widehat{[  [ \emb ~q ]_{\sim} ]} = [\emb ~ q] = q$

and $\Phi \circ \Psi = \text{id}_{\qset{A}}$ namely,

$[\emb~\widehat{[s]}]_{\sim} = s$

can be proved using quotient induction principle and $Q-\textbf{Ax}$,

$[\emb~\widehat{[ [a]_{~} ]}]_{\sim} = [\emb~[a]]_{\sim} = [a]_{\sim}$

\end{proof}


For $\tometa {\R_0}/ \tometa \sim$, we conjecture that it is still not
definable.

\begin{proof}
Assume the set of real numbers is definable, we have a type $A$ and
its embedding in $\mathsf{TT} + \mathsf{Q}$  is $\tometa A \simeq \tometa {\R_0}/ \tometa \sim$. The isomorphism gives us a "normalisation" function $f : $ and a representative function
between $\tometa {\R_0}$ and $\tometa A$.
\end{proof}











 there is usually a standard topological structure, for example 

\begin{itemize}

\item $(\bool , h)$ where 
$h(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$

\item $(\N , d)$ where 
$d(m,n) =
\left\{
	\begin{array}{ll}
		0  & \mbox{if } m = n \\
		1 & \mbox{if } m \neq n
	\end{array}
\right.
$
\end{itemize}






\subsection{Groupoid model}

There are many other relevant models proposed to explain the essence of identity types in Type Theory and to extend Type Theory with different extensional concepts. 

Martin Hofmann and Thomas Streicher's \cite{MR1686862} groupoid model interprets types as groupoids where the identity types endow every type with a groupoid structure. Instead of basic equivalence properties in setoid model, there are five more groupoid laws where $p$ and $q$ are level-$1$ morphisms:

\begin{equation*}
\begin{array}[b]{l}
\lambda : id \circ p = p \\
\rho : p \circ id = p \\
\alpha : p \circ (q \circ r) = (p \circ q) \circ r \\
\kappa : p^{-1}\circ p = id \\
\kappa' : p \circ p^{-1} = id
 \end{array}
\end{equation*}

In a groupoid model UIP does not hold in general because there can be different inhabitants of the same identity types. In fact, propositional equality is a generalisation of isomorphism. For example to prove that $\bool = \bool$, there are two intensionally different inhabitants: one is given by identity function on $\bool$, the other is given by negation on $\bool$.



embc' : ∀ a a' → ⌜ a' ⌝ ∼ a → [ a ] ≡ a'
embc' (a1 , zero) (+ n) p = sym (cong +_ (ℕ.+r-cancel 0 p))
embc' (zero , nsuc a2) (+ n) p = {!!}
embc' (nsuc a1 , nsuc a2) (+ n) p = {!!}
embc' (a1 , a2) (-suc n) p = {!!}

sound[_] : ∀ a b → a ∼ b → [ a ] ≡ [ b ]
sound[_] a b p = embc' a [ b ] (zsym (p >∼< zsym (compl b)))

embc : ∀ a → Universal (λ p → ⌜ p ⌝ ∼ a) -- Σ ℤ (λ p → (⌜ p ⌝ ∼ a) × (∀ q →  ⌜ q ⌝ ∼ a → q ≡ p))
embc a  = [ a ] , ((compl a) , embc' a)



Universal : {A : Set}(P : A → Set) → Set
Universal {A} P = Σ A (λ a → P a × (∀ a' →  P a' → a ≡ a'))



It is equivalent to \autoref{def:nor} because:


\begin{definition}[\textbf{Definable via normalisation}]\label{def:nor}
Given a setoid $(A,\sim)$, $\qset{A}$ is definable via normalisation if there is a "real" normalisation function with two properties
\begin{align*}
[\_]_0 &: A \to A \\
\text{sound} &: \forall a ~ b : A \to a \sim b \to [ a ]_0 = [ b ]_0\\
\text{complete} &: \forall a : A \to [ a ]_0 \sim a\\
\end{align*}
\end{definition}

the normalisation function can be recovered as 

$[\_]_0 \defeq emb \circ [\_]$. 

In the other way around, $[\_]_0$ gives rise to a set 

$Q \defeq \Sigma c : \R_0, [ c ]_0 = c$ with a function 

$[ c ] \defeq [c]_0 , ~\sound ~ [[c]_0]_0 ~~ [c]_0~~ (\complete ~ c)$

 and then the embedding function is just the first projection. The properties can be verified easily. It has to be noticed that although we call $[\_]$ as a normalisation function, it is only true in a definable quotient structure.

Categorically speaking, a definable quotient is a \emph{split coequalizer}.

\[\xymatrix{
R\ar@<0.5ex>[r]^{\pi_0}\ar@<-0.5ex>[r]_{\pi_1}& A\ar[r]^{[\_]}
& Q
}\]







We first learn equality for numbers in \maths. Generally speaking, it
expresses the sameness of two mathematical objects such as numbers or sets.
$1+2=3$ tells us the mathematical object calculated from $1+2$ is the
same as $3$.

From ages before, mathematicians are arguing about the correct way to
characterise equality. The most common idea is that equality is just
identity. Leibniz's law can be seen as a "definition" of
equality:

Given any $x$ and $y$, $x = y$ if, given any predicate $P$, $P(x)$ if and only
if $P(y)$.




In Type Theory, the encoding of equality is also contentious. Considering a variety of issues, there are
several notions of equality in type theory.
We can compare whether two types are equal or two terms are equal. If two
expressions can be computed to the same object then we claim they are
 \emph{definitionally} equal.  
 We can also internalise definitional equality by defining \emph{identity types}. An inhabitant of identity type is an evidence of the \emph{propositional equality} between two terms or types are equal and is usually denoted as refl. 

In \ett, propositional equality is identified with definitional equality which makes definitional equality undecidable and then type checking undecidable. However in \itt, they are different. Propositional equality is only induced by identity types which captures the definitional equality of terms or types. The equality of functions are usually judged extensionally, and the point-wise equalities of functions are not captured by identity types. For example, $\lambda n \to n$ and $\lambda n \to n + 0$ are intensionally different considering $n+0$ does not reduce to $n$ in the the usual definition of addition.
The problem arises from the computational difficulties. A type checker can easily decide whether two
values of inductive types are the same, but not whether two functions
are extensionally equal. Even suppose we encode the method to compute
the definitional equality of the outputs for each given input, it can
only decide the equality for finite types.

\section{Programming in Agda}

In this thesis we use Agda to implement our constructions in \itt. 
Agda is a dependently typed, functional programming language, which is
based on the intensional version of \mltt. It is mainly developed by
Ulf Norell, Nils Anders Danielsson, and Andreas Abel.
It is a functional language like Haskell, but has dependent types. It has dependent pattern
matching, type checker, coverage checker and termination checker. It
supports a bundle of schema of defining data types such as inductive, inductive-recursive, mutually inductive,
coinductive types. Its syntax is close to Haskell, in addition, it has
unicode support and mixfix operators. All these features including
type checker, unicode typing and interactive programming present in
its Emacs interface. It is quite popular in the field of mathematical reasoning and programs
verifications. Many researchers implement their work of type theory in
Agda. It is also one of the popular languages in the community of the recently
developed field \hott and the library of \hott is under construction.
The adequate reasoning library code also helps in writing certified programs.

In \autoref{bg} we present a brief introduction to it for someone
who meet this language for the first time. In \autoref{dq} we use Agda to implement our definable quotient algebraic structures. In \autoref{models} we build a category with families of setoids in Agda. In \autoref{wog}, we implement a syntactic construction of \wog.

Agda wiki\cite{agdawiki:main} is a good reference to it and there are
several good tutorials to Agda for example Ulf Norell's
\cite{tutorial}, Ana Bove, Peter Dybjer, and Ulf Norell's \cite{bove2009brief}.















% Reusable code

In set theory quotient set is
a set of the equivalence classes of some equivalence relation on
another set. The word \emph{Quotient} is usually used to capture
similar notions in other abstract branches, such as quotient group,
quotient space, quotient category etc. Move to type theory, it is
expected to have \emph{Quotient types} to construct similar objects in
mathematics. However in current setting of \itt, it is not
available. Motivated by this fact, I start to extend type theory with
quotient types. This thesis first
introduce background knowledges about type theory , Agda and specially
quotient types, then discuss about definable quotients which are
quotients definable without using quotient types, other models of type
theory to implement quotient types and homotopy type theory which has
a stronger notion called higher inductive types. The author further
extend the setoid models and study an approach to implement \wog model
in \itt for \hott where quotient types are available.





\section{Basic category theoretical notions}

A category has a collection of objects and one collection of arrows
for each pair of objects. 
A simple finite category can be visualised as a directed diagram
 but there are also a set of conditions which are called categorical laws to obey. 
The most accessible example is the category of sets. Objects are sets,
arrows are functions and all categorical conditions fulfilled. It is
also very helpful to formulate type theoretical concepts in a
categorical way. 

Category theory abstracts a lot of similar concepts in different
fields and provides a concise language for mathematics for
mathematicians.
Type theory and category theory are closely related,
especially Homotopy type theory
\footnote{\url{http://ncatlab.org/nlab/show/relation+between+type+theory+and+category+theory}}.
Category theory is very useful in giving the type theoretical
notions, particularly the ones involving functions, relations and some
properties.




\section{Related work}

\todo{fill this part}





\subsection{Category Theory}

Category theory is a very useful tools to formalise mathematical notions, particularly focussing on morphisms which can be functions, relations and transformations.
A category has a collection of objects and one collection of arrows for each pair of objects. A simple finite category can be visualised as a directed diagram but there are also a set of conditions which are called categorical laws to obey. 

The most accessible example is the category of sets. Objects are sets, arrows are functions and all categorical conditions fulfilled. It is also very helpful to formulate type theoretical concepts in a categorical way. Type theory and category theory are closely related, especially Homotopy type theory \footnote{\url{http://ncatlab.org/nlab/show/relation+between+type+theory+and+category+theory}}.

Category theory abstracts a lot of similar concepts in different
fields and provides a concise language for mathematics for
mathematicians.
\todo{to complete this part}











\begin{corollary}
We generalise the theorem \ref{PUEF}, assume we quotient a set with a groupoid relation, $\infixeqv: A \to A \to
\Set$, and we have univalence, the quotient is also effective in the sense that the soundness $[\_]^{=}$ is an equivalence (or isomorphism).
\end{corollary}

To quotient a set with a groupoid relation $\sim$, the result $\qset{A}$ is also a groupoid whose structure is given by 

$[\_]^{=} : a \sim b \to [a] = [b]$

on the next level, we need

$[\_]^{id}: [ \text{refl} ]^{=} = \text{refl}$ and

$[\_]^{comp}: [ p ; q ]^{=} =  [ p ]^{=} ; [ q ]^{=} $


\begin{proof}

The predicate becomes $P_a : A \to \Set$

By univalence we can also prove it is compatible with $\sim$


Assume $p : x \sim y$, on the next level we have an equivalence on the arrows
$P_a ~ p : P_a ~x  \to P_a ~ y$ which is given by $\lambda r \to r ; p$

\begin{displaymath}
    \xymatrix{x \ar[r]^p & y \\
      a \ar[u]^r \ar@{.>}[ur]_{r;p} & \\ }
\end{displaymath}


$P_a$ is functorial because

$P_a ~ \text{refl} \equiv \lambda r \to r ; \text{refl} = \lambda q \to q \equiv \text{id} $

$P_a ~ (p ; q) \equiv \lambda r \to r ; (p ; q) = \lambda r \to (r ; p) ; q \equiv (\lambda r \to (r ; p)) ; (\lambda r \to (r ; q)) \equiv P_a ~ p ; P_a ~ q$



Hence we can also lift $P_a$ such that $a \sim b \equiv P_a ~ b \equiv \hat{P_a} ~ [ b ]$
The inverse of soundness is then of type $[a]=[b] \to \hat{P_a} ~ [ b ]$ which can be defined as

$[ p ]^{=-1} \defeq \transport ~p ~ \text{refl}$


which is equivalent because

$[ [p]^{=} ]^{=-1} = p$ can be proved by

$\equiv \transport ~ [p]^{=} ~ \text{refl}$

Since $\transport ~ [refl]^{=} ~ \text{refl} = \transport ~ refl ~ \text{refl} = refl$

%First, let's prove that $\infixeqv$ is well-defined (functorial).

%Given $p : a \sim a'$ and $q : b \sim b'$,  we can constuct an
%equivalence $p \sim_1 q : a \sim b \to a' \sim b'$ which is defined as
%$(p \sim_1 q)(r) \defeq p^{-1} ; r ; q$ (and vice versa)

%\begin{displaymath}
%    \xymatrix{a \ar[r]^r  \ar[d]_p & b \ar[d]^q \\
%      a' \ar@{.>}[r] & b'\\ }
%\end{displaymath}

%From univalence axiom we can deduce that $a \sim b = a' \sim b'$.

%On the next level, 

%$(\trefl^{\sim} \sim_1 \trefl^{\sim})(r) \equiv \trefl^{\sim-1} ; r ; \trefl^{\sim} = r$ and

%$((p;p') \sim_1 (q;q'))(r) \equiv (p;p')^{-1} ; r ; (q;q') =
%p'^{-1};p^{-1};r;q;q' = p'^{-1}(p^{-1};r;q);q' \equiv (p' \sim_1
%q')((p~q)(r))$

%hence the equivalence relation is functorial and we can lift it as
%well. Following condition must be satisfied,

%$[a]~\hat{\sim}~[b] \equiv a \sim b$

%By definition, $\trefl : a \sim a$ is also of type $[a]~\hat{\sim}~[a]$,
%but to make it more clear we call it $\trefl_{\hat{\sim}}$.

%The inverse of soundness, $[a]=[b] \to
%[a]~\hat{\sim}~[b]$ can be defined as

%$[\_]^{=-1} \defeq \lambda p \to \transport(p)(\trefl_{\hat{\sim}})$

%To prove it is indeed an inverse of soundness,

%$ [[p]^{=}]^{=-1} \equiv \transport ([p]^{=})(\trefl_{\hat{\sim}}) $

\end{proof}







 the set
of integers and the set of rational numbers. We will also study the
application of definable quotients to illustrate some advantages of
using them.


 can be related with setoids via a
normalisation function. This paper mainly investigates these cases with an emphasis
on the application of quotients.















\subsection{Related Work}
\label{sec:related-work}

Quotient types were introduced by Mendler in
\cite{men:90} and subsequently investigated in Hofmann's
PhD dissertation~\cite{hof:phd}. An extensive investigation of setoids
can be found in~\cite{bar:03}. Maietti considers extensions
of both intensional and extensional type theory by quotient types
\cite{maietti1999effective}. Courtieu considers an extension of CIC
(an intensional type theory) by \emph{normalized types} corresponding
to our definable quotients~\cite{cou:01}. Nogin describes a
modular implementation of quotient types in NuPRL (an extensional type
theory)~\cite{nog:02}.



















\subsection{The application of definable quotients}

Usually the definable quotient structure is useful when the base type (or carrier) is easier to handle, in other
words, it is more convenient to use the setoid interpretation in
defining operations and proving properties.
In the case of integers, Since there is one case for he setoid
representation, it generates less cases. Although for simple
operations it does not simply too much, it makes a big different in
proving complicated theorems like distributivity.

We will introduce the way we apply definable quotient in practical use.

{\textbf{\large{Operations}}}

With two functions converting the two encodings, it is enough to lift
all functions. It is possible to lift operations uniformly by mixing the
normalisation and embedding functions. For example, given an unary
operator 

\begin{code}
\\
\>\AgdaFunction{lift₁} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{op} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{lift₁} \AgdaBound{op} \AgdaSymbol{=} \AgdaFunction{[\_]} \AgdaFunction{∘} \AgdaBound{op} \AgdaFunction{∘} \AgdaFunction{⌜\_⌝}\<%
\\
\end{code}

This can be generalised to n-ary operators.

As long as we implement an operation of integers, it is safe to lift
the setoid version. However it is clear that not all operations on the
base types should be lifted and they do not make sense. Hence it is
better to verify if the operation is well-defined on the setoid:

$$a \sim b → op~a \sim op~b$$



Most of the operations for setoid integers can be concluded from
expression rewriting equations. For example to define addition, 
we only need to transform the expression  
$(a_1 - b_1) + (a_2 - b_2) = (a_1 + a_2) - (b_1) - (b_2)$
so that we only do valid
operations on natural numbers ($+$ or $*$) and minus is going to be
replaced by pairing operation.

The addition of integers can be defined in one line

\begin{code}
\\
\>\AgdaFunction{\_+\_} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{x+} \AgdaInductiveConstructor{,} \AgdaBound{x-}\AgdaSymbol{)} \AgdaFunction{+} \AgdaSymbol{(}\AgdaBound{y+} \AgdaInductiveConstructor{,} \AgdaBound{y-}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{x+} \AgdaFunction{ℕ+} \AgdaBound{y+}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{x-} \AgdaFunction{ℕ+} \AgdaBound{y-}\AgdaSymbol{)}\<%
\\
\end{code}

We can easily verify it well-defined but it is not necessary because
it has been implied in the mathematical reasoning before implementing it.



\textbf{\large{Properties}}

Following axioms and theorems we learnt about integers, we can prove
the plus, multiplication is commutative and associative, minus is
inverse of plus etc. All these properties about plus, minus and
multiplication forms a commutative ring of integers \footnote{can cite
somewhere else http://www.millersville.edu/~bikenaga/number-theory/ring-of-integers/ring-of-integers.html}.
Like for natural numbers, axioms in classic mathematics are theorems
to prove in constructive mathematics. The only axioms for integers are
contained in the definition.

One of the important motivations of using setoid integers is that
the setoid definition reduces the complexity as we have shown in the
previous part, but it
will be much more evident when proving properties of the ring of integers.

In practice, for the set definition of integers, most of basic operations and simple theorems are not unbearably
complicated to deal with. However, as we mentioned before, the number of
cases grows exponentially when case splitting is unavoidable.
Although it is
possible to prove lemmas which covers several cases and reduce number
of cases, it often does not reduce complexity in total.
 An important case which is extremely difficult to conduct in practice is the proving of distributivity.

\paragraph{An efficient utilization of quotient structure: the
  proving of distributivity}

At first when we attempted to define the ring of integers, we were
stuck in proving the the distributivity of $*$ over $+$. As an example
we will show the attempt of left
distributivity $ x \times (y + z) = x \times y + x \times z$.

To simplify it, we define the multiplication in an arithmetic way
instead of pattern matching.

\begin{code}
\\
\>\AgdaFunction{\_ℤ*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaBound{i} \AgdaFunction{ℤ*} \AgdaBound{j} \AgdaSymbol{=}
\AgdaFunction{sign} \AgdaBound{i} \AgdaFunction{S*}
\AgdaFunction{sign} \AgdaBound{j} \AgdaFunction{◃} \AgdaFunction{∣}
\AgdaBound{i} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣}
\AgdaBound{j} \AgdaFunction{∣}\<%
\\
\end{code}

Of course it is not rational to split cases into $2 * 2 * 2$. 
The first idea is to apply the left distributivity law of natural
numbers when they are non-negative. To utilize the it more, 
it can be generalised to the cases when all three variables have the same
signs. Moreover when only $y$ and $z$ have the
same symbol, it is still plausible. 
The following is a partial definition (Note: $\AgdaFunction{DistributesOverˡ}$ means
that the distributivity of the first operators over the second one)  and three lemmas are given after it

\begin{code}
\\
\>\AgdaFunction{distˡ} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaFunction{\_ℤ*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_ℤ+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaKeyword{with} \AgdaFunction{sign} \AgdaBound{y} \AgdaFunction{S≟} \AgdaFunction{sign} \AgdaBound{z}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \<[15]%
\>[15]\AgdaSymbol{|} \AgdaInductiveConstructor{yes} \AgdaBound{p} \<[23]%
\>[23]\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaKeyword{rewrite} \AgdaBound{p} \<[16]%
\>[16]\<%
\\
\>[6]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{|} \AgdaFunction{lem1} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \<[25]%
\>[25]\<%
\\
\>[6]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{|} \AgdaFunction{lem2} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \AgdaSymbol{=} \<[27]%
\>[27]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaFunction{S*} \AgdaFunction{sign} \AgdaBound{z} \AgdaFunction{◃} \AgdaBound{n}\AgdaSymbol{)} \<[47]%
\>[47]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)))} \<[36]%
\>[36]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{|} \AgdaInductiveConstructor{no} \AgdaBound{¬p} \AgdaSymbol{=} \AgdaBound{...}\<%
\\
\end{code}
 
To prove these simpler cases we need three lemmas,

\begin{code}
\\
\>\AgdaFunction{lem1} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y} \AgdaFunction{∣} \AgdaDatatype{≡} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ+} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \<[61]%
\>[61]\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{m+1+n≡1+m+n} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(} \AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{0} \AgdaBound{s} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{ℤ-id-l} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{lem3} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-+-assoc} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaBound{n} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaBound{x}\AgdaSymbol{)))))}\<%
\\
\>[13]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{s} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaBound{y} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{))} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaBound{s} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-id-r} \AgdaSymbol{\_)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.-} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\end{code}

In the second category of cases, if $y$ and $z$ have different
signs, it is impossible to apply the left distributivity law for
natural numbers. Intuitively speaking, there is no rule to turn expressions like $x *
(y  - z)$ into expression which only contains natural numbers,
therefore we have to prove it from scratch.
Although it is possible to prove finally, it is not the best solution
we want. 

It is much simpler to prove the distributivity for setoid
representations. In fact with the help of ring solver, it can be
proved automatically.
All these definitions of operators only involves operators for natural
numbers which forms a commutative semiring for natural numbers.
This implies that these expressions of setoid integers which only
involves plus, minus and multiplication, can be turned into equation of natural numbers.
The theorems are also simply equations of natural numbers which are
automatically solvable.


\begin{remark}
A \emph{ring solver} is an automatic equation checker for rings e.g.\ the
ring of integers. It is implemented based on the theory described in
"Proving Equalities in a Commutative Ring Done Right in Coq" by
Grégoire and Mahboubi \cite{gregoire2005proving}.
\end{remark}


Therefore to prove the distributivity, the
simplest way is to use semiring
solver for natural numbers. 


\begin{code}
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \<[9]%
\>[9]\AgdaFunction{\_*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{solve} \AgdaNumber{6} \<[40]%
\>[40]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{f} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{:=}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{e} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)))} \AgdaInductiveConstructor{refl} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\<%
\\
\end{code}

It is not the simplest way to use ring solver since we have to feed
the type (i.e.\ the equation) to the solver which can be automatically
figured out by "reflection". It helps us quote the type of the goal so
that we can define a function that automatically do it without
explicitly providing the equations. There is already some work
done by van der Walt \cite{van2012reflection}. It can be seen as an
analogy of the "ring" tactic from Coq.


Use the ring solver for natural numbers we can prove all theorems
required for ring solver for integers. However the process of proof
terms generation and type checking take very long time in practice. It may heavily slow the type
checking although the optimization of Agda already shows a big
improvement in this technical efficiency issue. As
these theorems are going to be used quite often, it is reasonable to
manually construct the proof terms to improve efficiency of library
code, sacrificing some conveniences.

Luckily it is still much simpler than the ones for the set of integers $\Z$.
First there is only one case of integer and as we know the equations is
indeed equations of natural numbers which can be proved using only the
properties in the commutative semiring of natural numbers. There is no
need to prove some properties for $\Z$ from scratch like in the
proving of distributivity.

\begin{code}
\\
\>\AgdaFunction{dist-lemˡ} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \<[28]%
\>[28]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaSymbol{(}\AgdaBound{c} \AgdaPrimitive{ℕ+} \AgdaBound{e}\AgdaSymbol{)} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaSymbol{(}\AgdaBound{d} \AgdaPrimitive{ℕ+} \AgdaBound{f}\AgdaSymbol{)} \AgdaDatatype{≡}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{c} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)} \AgdaPrimitive{ℕ+} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{e} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{f}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{=} \AgdaFunction{trans}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaFunction{cong₂} \AgdaPrimitive{\_ℕ+\_} \AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaBound{a} \AgdaBound{c} \AgdaBound{e}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaBound{b} \AgdaBound{d} \AgdaBound{f}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaPostulate{swap23} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{c}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{e}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{f}\AgdaSymbol{))}\<%
\\
%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \AgdaFunction{\_ℤ₀*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_ℤ₀+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \<[32]%
\>[32]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{cong₂} \AgdaPrimitive{\_ℕ+\_} \AgdaSymbol{(}\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{d} \AgdaBound{c} \AgdaBound{f} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\end{code}

It only needs one special lemma which can be proved by applying distributivity
laws for natural numbers. The $\AgdaFunction{swap23}$ is a commonly
used equation rewriting lemma

$(m + n) + (p + q) = (m + p) + (n + q)$

After all, the application of quotient structure in the integer case
provides us a general approach to define functions and prove theorems
when the base types are simpler to deal with.
Adopting this approach, both the appearance -- the set representation of integers
and the underlying -- the convenience of manipulating setoid
representation of integers, are maintained.
In the case of rational numbers, the base type is also simpler to deal with.


\section{Rational numbers}

In the Agda standard library, the set of rational numbers is defined
as fractions whose numerator and denominator are coprime. It ensures
the canonicity of representations, but it complicates the manipulation
of rational numbers since the coprimarity has to be kept for each
intermediate step of calculations. From experience of calculating
fractions in arithmetic, we usually do not reduce fractions until we are going to
show a simplified answer, and all the calculation can be carried out correctly
without reducing. Actually from  a discussion on Agda mailing list
\footnote{http://comments.gmane.org/gmane.comp.lang.agda/6372}, a better way to manipulate the
rational numbers is required. A flexibility way to choose from unreduced fractions or reduced ones in
operations can be fulfilled by a definable quotient of
rational numbers. The unreduced fractions are mainly used for underlying calculations and
property proving because it ignores a lot of reducing steps and
coprimarity checking, and the reduced fractions are accessible when
displaying rational numbers. 
It simplifies defining functions and proving properties related to rational
numbers. Moreover, we believe the efficiency of programs involving rational
numbers calculation is improved due to the removal of reducing , even
though some people claim that the unreduced numbers are too
large to make it efficient.


\subsection{The setoid of rational numbers: unreduced fractions}

The setoid representation of rational numbers -- unreduced fractions
are more common in mathematics.
Usually a fraction denoted as $\frac{m}{n}$ consists of an integers
$m$ called \emph{numerator} and a non-zero integer $n$ called
\emph{denominator}.
In type theory, since the data types have different
complexity, we have a decision to make in the choice of best
definition like what we did for integers.
Alternatively keeping the numerator integer, the denominator can be a
positive natural number such that the sign of rational number is kept
in the numerator solely and there is no need to add a restriction to
exclude $0$ which is not so easy for the set of integer.

$$\Q_0 = \Z \times \N$$

Technically there is no need to define a new type for positive
natural numbers $\N^{+}$, so we use $\N$ which we can name it as
\emph{denominator-1} or implement it as follows

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℚ₀} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[-1]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_/suc\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{n} \AgdaSymbol{:} \AgdaDatatype{ℤ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{d} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\end{code}

such that $2 /suc 2$ stands for $\frac{2}{3}$.


\begin{remark}
It is also reasonable to define it with a pair of natural numbers with
a sign defined separately. However this also complicates calculation
in some way.
\end{remark}



The rational number represented by a fraction $\frac{m}{n}$ is indeed the result of
division $m \div n$. Therefore two different fractions can represent
the same rational numbers.
In mathematics, to judge the equality of two fractions, it is easier to conduct the following conversion,

$$ \frac{a}{b} = \frac{c}{d} \iff a \times d = c \times b $$


Hence the equivalence relation can be defined as,

\begin{code}
\\
\>\AgdaFunction{\_*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaNumber{0}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaInductiveConstructor{suc} \AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{\_∼\_} \<[35]%
\>[35]\AgdaSymbol{:} \AgdaFunction{Rel} \AgdaDatatype{ℚ₀} \AgdaSymbol{\_}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{n1} \AgdaInductiveConstructor{/suc} \AgdaBound{d1}\AgdaSymbol{)} \AgdaFunction{∼} \AgdaSymbol{(}\AgdaBound{n2} \AgdaInductiveConstructor{/suc} \AgdaBound{d2}\AgdaSymbol{)} \AgdaSymbol{=} \<[31]%
\>[31]\AgdaBound{n1} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d2} \AgdaDatatype{≡} \AgdaBound{n2} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d1}\<%
\\
\end{code}


\subsection{The set definition of rational numbers: reduced fractions}

The reduced fractions are canonical representations of rational
numbers. It is a subset of fractions, so we only need to add a
restriction that the numerator and denominator is coprime,

% The normal form of rational numbers, namely the quotient type in this quotient is the set of irreducible fractions. We only need to add a restriction that the numerator and denominator is coprime,

$$\Q = \Sigma ((n , d) : \Z \times \N)). \mathsf{coprime} ~n ~(d +1)$$

It is implemented as follows (also available in standard library),

\begin{code}
\\
\>\AgdaKeyword{record} \AgdaRecord{ℚ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{numerator} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{denominator-1} \AgdaSymbol{:} \AgdaDatatype{ℕ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{isCoprime} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{C.coprime?} \AgdaFunction{∣} \AgdaBound{numerator} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{denominator-1}\AgdaSymbol{))}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaFunction{denominator-1}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{:} \AgdaFunction{Coprime} \AgdaFunction{numerator} \AgdaFunction{denominator}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{=} \AgdaFunction{toWitness} \AgdaFunction{isCoprime}\<%
\\
\end{code}

\subsection{The definable quotient of rational numbers}

From the definition, we already have a setoid which contains unreduced
fractions $\Q_0$ as
base type and an equivalence relation on it. Compare with the set
definition, it is clear that normalisation from $\Q_0 \to \Q$ is just
reducing functions.

To implement reducing process, we can utilize the library code about
\emph{great common divisor (gcd)}. The function $\AgdaFunction{gcd}$
calculates the divisor and a data type $\AgdaDatatype{GCD}$ containing
information from calculating the
greatest common divisor which can be converted to another data type $\AgdaDatatype{GCD′}$
\footnote{http://www.cse.chalmers.se/~nad/repos/lib/src/Data/Nat/Coprimality.agda}
which contains the three essential results we need, i.e.\ the new numerator, new denominator and the
proof term that they are coprime. Combing the library functions and
types with a self-defined function
$\AgdaFunction{GCD′→ℚ}$\footnote{see \autoref{rational-gcd}} which
constructs the reduced fraction we need, the normalisation function is
implemented as follows,

\begin{code}
\\
\>\AgdaFunction{[\_]} \AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaRecord{ℚ}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{0}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{=} \AgdaInductiveConstructor{ℤ.+\_} \AgdaNumber{0} \AgdaFunction{÷} \AgdaNumber{1}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaSymbol{=} \AgdaFunction{GCD′→ℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaBound{di} \AgdaSymbol{(λ} \AgdaSymbol{())} \AgdaSymbol{(}\AgdaFunction{C.gcd-gcd′} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaSymbol{...} \AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaSymbol{=} \AgdaFunction{-} \AgdaFunction{GCD′→ℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaBound{di} \AgdaSymbol{(λ} \AgdaSymbol{())} \AgdaSymbol{(}\AgdaFunction{C.gcd-gcd′} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\end{code}


and the embedding function is trivial, because we only need to forget
the coprime proof in the normal form,

\begin{code}
\\
\>\AgdaFunction{⌜\_⌝} \AgdaSymbol{:} \AgdaRecord{ℚ} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\>\AgdaFunction{⌜} \AgdaBound{x} \AgdaFunction{⌝} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{ℤcon} \AgdaSymbol{(}\AgdaFunction{ℚ.numerator} \AgdaBound{x}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaSymbol{(}\AgdaFunction{ℚ.denominator-1} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\end{code}

Similar to the case of integers, complete the definable quotient, we
also need to prove the sound, complete, stable and exact
properties. There is no need to show the proof of them since the
normalisation function is implemented using an approach which has been
tested in mathematics.
Also we can apply the definable quotient structures in helping form
the field of rational numbers. After embedding the natural numbers
into integers, any theorems using only the operations in the field
$\Q$, are turned out to be propositions of integers which can be
solved using ring solver or theorems proven for integers.





The pullback functor.

\begin{displaymath}
    \xymatrix{X' \ar[r]^{p} \ar[d]_{f^{*}(a)} & Y' \ar[d]^a \\
      X \ar[r]^f& Y }
\end{displaymath}


Observe that $X \rightarrow 1 \cong X$, therefore the pullback of y which is
$X/1 \rightarrow X \times Y / Y$ can be seen as a pullback of X of type $X \rightarrow
X/Y$.

The left adjoint to the pullback functor $f*$ is just the post
composition of $f$ written as $f \circ\_$ or $\Sigma_f$.

\begin{displaymath}
    \xymatrix{X' \ar@{=}[r] \ar[d]_{a} & X' \ar[d]^{\Sigma_f a} \\
      X \ar[r]^f& Y }
\end{displaymath}





We first try to construct the predicates of defining an equivalence relation from a propositional relation, which is not as simple as we expected. We refer to Hofmann's approach in \cite{hof:95:sm}, namely by defing reflexive, symmetric and transitive closure of a propositional relation. The same concern also makes us choose the underlying set definition over the propositional construction.

\begin{code}
%
\\
\>\AgdaFunction{Closure} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)(}\AgdaBound{\_∼\_} \AgdaBound{R} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaRecord{HProp}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaRecord{HProp}\<%
\\
\>\AgdaFunction{Closure} \AgdaBound{A} \AgdaBound{\_∼\_} \AgdaBound{R} \AgdaBound{s} \AgdaBound{s'}\<%
\\
\>[9]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[10]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{\{} \AgdaField{prf} \AgdaSymbol{=} \AgdaSymbol{∀} \AgdaSymbol{(}\AgdaBound{R'} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaRecord{HProp}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>[12]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{→} \AgdaSymbol{(∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{x} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{y} \AgdaBound{x} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[12]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{→} \AgdaSymbol{(∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{x} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{y} \AgdaBound{z} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{x} \AgdaBound{z} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[12]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{→} \AgdaSymbol{(∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{x} \AgdaBound{∼} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{x} \AgdaBound{y} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[12]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{→} \AgdaSymbol{(∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R} \AgdaBound{x} \AgdaBound{y} \AgdaFunction{>} \AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{x} \AgdaBound{y} \AgdaFunction{>}\AgdaSymbol{)}\<%
\\
\>[12]\AgdaIndent{18}{}\<[18]%
\>[18]\AgdaSymbol{→} \AgdaFunction{<} \AgdaBound{R'} \AgdaBound{s} \AgdaBound{s'} \AgdaFunction{>}\<%
\\
\>[0]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{;} \AgdaField{Uni} \AgdaSymbol{=} \AgdaBound{ext} \AgdaSymbol{(λ} \AgdaBound{R'} \AgdaSymbol{→} \AgdaBound{ext} \AgdaSymbol{(λ} \AgdaBound{x₁} \AgdaSymbol{→} \AgdaBound{ext} \<[48]%
\>[48]\<%
\\
\>[0]\AgdaIndent{20}{}\<[20]%
\>[20]\AgdaSymbol{(λ} \AgdaBound{x₂} \AgdaSymbol{→} \AgdaBound{ext} \AgdaSymbol{(λ} \AgdaBound{x₃} \AgdaSymbol{→} \AgdaBound{ext} \AgdaSymbol{(λ} \AgdaBound{x₄} \AgdaSymbol{→} \AgdaFunction{Uni} \AgdaSymbol{(}\AgdaBound{R'} \AgdaBound{s} \AgdaBound{s'}\AgdaSymbol{))))))}\<%
\\
\>[0]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{\}}\<%
\\
\end{code}











It is all about adding more structures on types. 

A setoid is a set with
an equivalence relation. Categorically, terms are objects and in setoid models, there is at most one morphism
between terms which stands for the equivalence relation.
The reflexivity is the identity morphism, the symmetry provides an
inverse of each morphism and the transitivity is just the composition
of morphism. One important deduction is that for any $p : a \sim b, p
\dot p^{-1} = id$. However it is not true for groupoid models.

In groupoid models, Instead of the definitional equality $p : a \sim
b, p . p^{-1} = id$, we have a 2-dimensional isomorphism $G3 : p . p^{-1}
\sim id$ (It is one of the groupoid laws \cite{MR1686862}) which
stands for the propositional equality.
Setoids are just a special cases of groupoids. The morphism is not
unique in each homset, i.e. the identity types are
non-trivial.

The second level is non-trivial in a groupoid, what if the third level
and higher levels are non-trivial? It we turn the equalities, namely
groupoid laws of each level, into explicit morphisms (which are called
equivalence), we get \og.

By building the infinite tower of identity types, every type has a \wog \cite{van2011types}.
Similar to the interpretation of types as setoids, \wog is more
general choice. It has more expressive power than setoid models.










Similarly, an
n-groupoid is an n-category in which morphisms on all levels are
equivalence.

\begin{displaymath}
\xymatrix{ 
a
\ar@/_4pc/[ddd]^p="p" 
\\
\\
\\
b 
\ar@/_4pc/[uuu]^{p^{-1}}="p^{-1}"" 
\ar@2{->} @/^2pc/ "p";"p^{-1}" _{H}="H"
\ar@2{<-} @/_2pc/ "p";"p^{-1}" ^{H ^{-1}}="H^{-1}"
\ar@3{->} @/^1pc/ "H";"H^{-1}"_{...}="A"
\ar@3{<-}@/_1pc/  "H";"H^{-1}"^{...}="A"
}
\end{displaymath} 

 {\og} which are also called $\infty$-groupoids is an
infinite version of n-groupoids. To model Type Theory without UIP we
also require the equalities to be non-strict, in other words, they are
not definitionally equalities. Finally we should use {\wog} to interpret types and eliminate the univalence axiom.

There are several approaches to formalise {\wog} in Type Theory. For instance, Altenkirch and Ryp\'a\v{c}ek \cite{txa:csl}, and Brunerie's notes \cite{gb:wog}.
This paper mainly explains an implementation of {\wog} following Brunerie's approach in Agda which is a well-known theorem prover and also a variant of intensional {\mltt}. The approach is to specify when a globular set is a {\wog} by first defining a type theory called {\tig} to describe the internal language
of Grothendieck {\wog}, then interpret it with a globular set and a dependent function. All coherence laws of the {\wog} should be derivable from the syntax, we will present some basic ones, for example reflexivity. One of the main contribution of this paper is to use the heterogeneous equality for terms to overcome some very difficult problems when we used the normal homogeneous one. In this paper, we omit some complicated and less important programs, namely the proofs of some lemmas or the definitions of some auxiliary functions. it is still possible for the reader who is interested in the details to check the code online, in which there are only some minor differences.





%This can be removed, may be not very important here

\begin{proposition}
It is not true that given type $T$, if $T$ is connected then $T$ is contractible.
\end{proposition}
\begin{proof}
As we have seen $ \R_0 / \sim$ is connected. However, it is not
contractible.
Assume it is contractible then there exists $x : \R_0 / \sim$, for
all $y : \R_0 / \sim$, we know $x = y$. Given two uniform sequences
$\bar{0} , \bar{1} : \R_0 / \sim$, we have $\bar{0}  = x = \bar{1}$
which negates $\bar{0} \ne \bar{1}$.
\end{proof}
