% Reusable code


\begin{corollary}
We generalise the theorem \ref{PUEF}, assume we quotient a set with a groupoid relation, $\infixeqv: A \to A \to
\Set$, and we have univalence, the quotient is also effective in the sense that the soundness $[\_]^{=}$ is an equivalence (or isomorphism).
\end{corollary}

To quotient a set with a groupoid relation $\sim$, the result $\qset{A}$ is also a groupoid whose structure is given by 

$[\_]^{=} : a \sim b \to [a] = [b]$

on the next level, we need

$[\_]^{id}: [ \text{refl} ]^{=} = \text{refl}$ and

$[\_]^{comp}: [ p ; q ]^{=} =  [ p ]^{=} ; [ q ]^{=} $


\begin{proof}

The predicate becomes $P_a : A \to \Set$

By univalence we can also prove it is compatible with $\sim$


Assume $p : x \sim y$, on the next level we have an equivalence on the arrows
$P_a ~ p : P_a ~x  \to P_a ~ y$ which is given by $\lambda r \to r ; p$

\begin{displaymath}
    \xymatrix{x \ar[r]^p & y \\
      a \ar[u]^r \ar@{.>}[ur]_{r;p} & \\ }
\end{displaymath}


$P_a$ is functorial because

$P_a ~ \text{refl} \equiv \lambda r \to r ; \text{refl} = \lambda q \to q \equiv \text{id} $

$P_a ~ (p ; q) \equiv \lambda r \to r ; (p ; q) = \lambda r \to (r ; p) ; q \equiv (\lambda r \to (r ; p)) ; (\lambda r \to (r ; q)) \equiv P_a ~ p ; P_a ~ q$



Hence we can also lift $P_a$ such that $a \sim b \equiv P_a ~ b \equiv \hat{P_a} ~ [ b ]$
The inverse of soundness is then of type $[a]=[b] \to \hat{P_a} ~ [ b ]$ which can be defined as

$[ p ]^{=-1} \defeq \transport ~p ~ \text{refl}$


which is equivalent because

$[ [p]^{=} ]^{=-1} = p$ can be proved by

$\equiv \transport ~ [p]^{=} ~ \text{refl}$

Since $\transport ~ [refl]^{=} ~ \text{refl} = \transport ~ refl ~ \text{refl} = refl$

%First, let's prove that $\infixeqv$ is well-defined (functorial).

%Given $p : a \sim a'$ and $q : b \sim b'$,  we can constuct an
%equivalence $p \sim_1 q : a \sim b \to a' \sim b'$ which is defined as
%$(p \sim_1 q)(r) \defeq p^{-1} ; r ; q$ (and vice versa)

%\begin{displaymath}
%    \xymatrix{a \ar[r]^r  \ar[d]_p & b \ar[d]^q \\
%      a' \ar@{.>}[r] & b'\\ }
%\end{displaymath}

%From univalence axiom we can deduce that $a \sim b = a' \sim b'$.

%On the next level, 

%$(\trefl^{\sim} \sim_1 \trefl^{\sim})(r) \equiv \trefl^{\sim-1} ; r ; \trefl^{\sim} = r$ and

%$((p;p') \sim_1 (q;q'))(r) \equiv (p;p')^{-1} ; r ; (q;q') =
%p'^{-1};p^{-1};r;q;q' = p'^{-1}(p^{-1};r;q);q' \equiv (p' \sim_1
%q')((p~q)(r))$

%hence the equivalence relation is functorial and we can lift it as
%well. Following condition must be satisfied,

%$[a]~\hat{\sim}~[b] \equiv a \sim b$

%By definition, $\trefl : a \sim a$ is also of type $[a]~\hat{\sim}~[a]$,
%but to make it more clear we call it $\trefl_{\hat{\sim}}$.

%The inverse of soundness, $[a]=[b] \to
%[a]~\hat{\sim}~[b]$ can be defined as

%$[\_]^{=-1} \defeq \lambda p \to \transport(p)(\trefl_{\hat{\sim}})$

%To prove it is indeed an inverse of soundness,

%$ [[p]^{=}]^{=-1} \equiv \transport ([p]^{=})(\trefl_{\hat{\sim}}) $

\end{proof}







 the set
of integers and the set of rational numbers. We will also study the
application of definable quotients to illustrate some advantages of
using them.


 can be related with setoids via a
normalisation function. This paper mainly investigates these cases with an emphasis
on the application of quotients.















\subsection{Related Work}
\label{sec:related-work}

Quotient types were introduced by Mendler in
\cite{men:90} and subsequently investigated in Hofmann's
PhD dissertation~\cite{hof:phd}. An extensive investigation of setoids
can be found in~\cite{bar:03}. Maietti considers extensions
of both intensional and extensional type theory by quotient types
\cite{maietti1999effective}. Courtieu considers an extension of CIC
(an intensional type theory) by \emph{normalized types} corresponding
to our definable quotients~\cite{cou:01}. Nogin describes a
modular implementation of quotient types in NuPRL (an extensional type
theory)~\cite{nog:02}.



















\subsection{The application of definable quotients}

Usually the definable quotient structure is useful when the base type (or carrier) is easier to handle, in other
words, it is more convenient to use the setoid interpretation in
defining operations and proving properties.
In the case of integers, Since there is one case for he setoid
representation, it generates less cases. Although for simple
operations it does not simply too much, it makes a big different in
proving complicated theorems like distributivity.

We will introduce the way we apply definable quotient in practical use.

{\textbf{\large{Operations}}}

With two functions converting the two encodings, it is enough to lift
all functions. It is possible to lift operations uniformly by mixing the
normalisation and embedding functions. For example, given an unary
operator 

\begin{code}
\\
\>\AgdaFunction{lift₁} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{op} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{lift₁} \AgdaBound{op} \AgdaSymbol{=} \AgdaFunction{[\_]} \AgdaFunction{∘} \AgdaBound{op} \AgdaFunction{∘} \AgdaFunction{⌜\_⌝}\<%
\\
\end{code}

This can be generalised to n-ary operators.

As long as we implement an operation of integers, it is safe to lift
the setoid version. However it is clear that not all operations on the
base types should be lifted and they do not make sense. Hence it is
better to verify if the operation is well-defined on the setoid:

$$a \sim b → op~a \sim op~b$$



Most of the operations for setoid integers can be concluded from
expression rewriting equations. For example to define addition, 
we only need to transform the expression  
$(a_1 - b_1) + (a_2 - b_2) = (a_1 + a_2) - (b_1) - (b_2)$
so that we only do valid
operations on natural numbers ($+$ or $*$) and minus is going to be
replaced by pairing operation.

The addition of integers can be defined in one line

\begin{code}
\\
\>\AgdaFunction{\_+\_} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{x+} \AgdaInductiveConstructor{,} \AgdaBound{x-}\AgdaSymbol{)} \AgdaFunction{+} \AgdaSymbol{(}\AgdaBound{y+} \AgdaInductiveConstructor{,} \AgdaBound{y-}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{x+} \AgdaFunction{ℕ+} \AgdaBound{y+}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{x-} \AgdaFunction{ℕ+} \AgdaBound{y-}\AgdaSymbol{)}\<%
\\
\end{code}

We can easily verify it well-defined but it is not necessary because
it has been implied in the mathematical reasoning before implementing it.



\textbf{\large{Properties}}

Following axioms and theorems we learnt about integers, we can prove
the plus, multiplication is commutative and associative, minus is
inverse of plus etc. All these properties about plus, minus and
multiplication forms a commutative ring of integers \footnote{can cite
somewhere else http://www.millersville.edu/~bikenaga/number-theory/ring-of-integers/ring-of-integers.html}.
Like for natural numbers, axioms in classic mathematics are theorems
to prove in constructive mathematics. The only axioms for integers are
contained in the definition.

One of the important motivations of using setoid integers is that
the setoid definition reduces the complexity as we have shown in the
previous part, but it
will be much more evident when proving properties of the ring of integers.

In practice, for the set definition of integers, most of basic operations and simple theorems are not unbearably
complicated to deal with. However, as we mentioned before, the number of
cases grows exponentially when case splitting is unavoidable.
Although it is
possible to prove lemmas which covers several cases and reduce number
of cases, it often does not reduce complexity in total.
 An important case which is extremely difficult to conduct in practice is the proving of distributivity.

\paragraph{An efficient utilization of quotient structure: the
  proving of distributivity}

At first when we attempted to define the ring of integers, we were
stuck in proving the the distributivity of $*$ over $+$. As an example
we will show the attempt of left
distributivity $ x \times (y + z) = x \times y + x \times z$.

To simplify it, we define the multiplication in an arithmetic way
instead of pattern matching.

\begin{code}
\\
\>\AgdaFunction{\_ℤ*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaBound{i} \AgdaFunction{ℤ*} \AgdaBound{j} \AgdaSymbol{=}
\AgdaFunction{sign} \AgdaBound{i} \AgdaFunction{S*}
\AgdaFunction{sign} \AgdaBound{j} \AgdaFunction{◃} \AgdaFunction{∣}
\AgdaBound{i} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣}
\AgdaBound{j} \AgdaFunction{∣}\<%
\\
\end{code}

Of course it is not rational to split cases into $2 * 2 * 2$. 
The first idea is to apply the left distributivity law of natural
numbers when they are non-negative. To utilize the it more, 
it can be generalised to the cases when all three variables have the same
signs. Moreover when only $y$ and $z$ have the
same symbol, it is still plausible. 
The following is a partial definition (Note: $\AgdaFunction{DistributesOverˡ}$ means
that the distributivity of the first operators over the second one)  and three lemmas are given after it

\begin{code}
\\
\>\AgdaFunction{distˡ} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaFunction{\_ℤ*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_ℤ+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaKeyword{with} \AgdaFunction{sign} \AgdaBound{y} \AgdaFunction{S≟} \AgdaFunction{sign} \AgdaBound{z}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \<[15]%
\>[15]\AgdaSymbol{|} \AgdaInductiveConstructor{yes} \AgdaBound{p} \<[23]%
\>[23]\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaKeyword{rewrite} \AgdaBound{p} \<[16]%
\>[16]\<%
\\
\>[6]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{|} \AgdaFunction{lem1} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \<[25]%
\>[25]\<%
\\
\>[6]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{|} \AgdaFunction{lem2} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \AgdaSymbol{=} \<[27]%
\>[27]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaFunction{S*} \AgdaFunction{sign} \AgdaBound{z} \AgdaFunction{◃} \AgdaBound{n}\AgdaSymbol{)} \<[47]%
\>[47]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)))} \<[36]%
\>[36]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{|} \AgdaInductiveConstructor{no} \AgdaBound{¬p} \AgdaSymbol{=} \AgdaBound{...}\<%
\\
\end{code}
 
To prove these simpler cases we need three lemmas,

\begin{code}
\\
\>\AgdaFunction{lem1} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y} \AgdaFunction{∣} \AgdaDatatype{≡} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ+} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \<[61]%
\>[61]\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{m+1+n≡1+m+n} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(} \AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{0} \AgdaBound{s} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{ℤ-id-l} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{lem3} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-+-assoc} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaBound{n} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaBound{x}\AgdaSymbol{)))))}\<%
\\
\>[13]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{s} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaBound{y} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{))} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaBound{s} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-id-r} \AgdaSymbol{\_)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.-} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\end{code}

In the second category of cases, if $y$ and $z$ have different
signs, it is impossible to apply the left distributivity law for
natural numbers. Intuitively speaking, there is no rule to turn expressions like $x *
(y  - z)$ into expression which only contains natural numbers,
therefore we have to prove it from scratch.
Although it is possible to prove finally, it is not the best solution
we want. 

It is much simpler to prove the distributivity for setoid
representations. In fact with the help of ring solver, it can be
proved automatically.
All these definitions of operators only involves operators for natural
numbers which forms a commutative semiring for natural numbers.
This implies that these expressions of setoid integers which only
involves plus, minus and multiplication, can be turned into equation of natural numbers.
The theorems are also simply equations of natural numbers which are
automatically solvable.


\begin{remark}
A \emph{ring solver} is an automatic equation checker for rings e.g.\ the
ring of integers. It is implemented based on the theory described in
"Proving Equalities in a Commutative Ring Done Right in Coq" by
Grégoire and Mahboubi \cite{gregoire2005proving}.
\end{remark}


Therefore to prove the distributivity, the
simplest way is to use semiring
solver for natural numbers. 


\begin{code}
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \<[9]%
\>[9]\AgdaFunction{\_*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{solve} \AgdaNumber{6} \<[40]%
\>[40]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{f} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{:=}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{e} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)))} \AgdaInductiveConstructor{refl} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\<%
\\
\end{code}

It is not the simplest way to use ring solver since we have to feed
the type (i.e.\ the equation) to the solver which can be automatically
figured out by "reflection". It helps us quote the type of the goal so
that we can define a function that automatically do it without
explicitly providing the equations. There is already some work
done by van der Walt \cite{van2012reflection}. It can be seen as an
analogy of the "ring" tactic from Coq.


Use the ring solver for natural numbers we can prove all theorems
required for ring solver for integers. However the process of proof
terms generation and type checking take very long time in practice. It may heavily slow the type
checking although the optimization of Agda already shows a big
improvement in this technical efficiency issue. As
these theorems are going to be used quite often, it is reasonable to
manually construct the proof terms to improve efficiency of library
code, sacrificing some conveniences.

Luckily it is still much simpler than the ones for the set of integers $\Z$.
First there is only one case of integer and as we know the equations is
indeed equations of natural numbers which can be proved using only the
properties in the commutative semiring of natural numbers. There is no
need to prove some properties for $\Z$ from scratch like in the
proving of distributivity.

\begin{code}
\\
\>\AgdaFunction{dist-lemˡ} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \<[28]%
\>[28]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaSymbol{(}\AgdaBound{c} \AgdaPrimitive{ℕ+} \AgdaBound{e}\AgdaSymbol{)} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaSymbol{(}\AgdaBound{d} \AgdaPrimitive{ℕ+} \AgdaBound{f}\AgdaSymbol{)} \AgdaDatatype{≡}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{c} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)} \AgdaPrimitive{ℕ+} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{e} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{f}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{=} \AgdaFunction{trans}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaFunction{cong₂} \AgdaPrimitive{\_ℕ+\_} \AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaBound{a} \AgdaBound{c} \AgdaBound{e}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaBound{b} \AgdaBound{d} \AgdaBound{f}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaPostulate{swap23} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{c}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{e}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{f}\AgdaSymbol{))}\<%
\\
%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \AgdaFunction{\_ℤ₀*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_ℤ₀+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \<[32]%
\>[32]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{cong₂} \AgdaPrimitive{\_ℕ+\_} \AgdaSymbol{(}\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{d} \AgdaBound{c} \AgdaBound{f} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\end{code}

It only needs one special lemma which can be proved by applying distributivity
laws for natural numbers. The $\AgdaFunction{swap23}$ is a commonly
used equation rewriting lemma

$(m + n) + (p + q) = (m + p) + (n + q)$

After all, the application of quotient structure in the integer case
provides us a general approach to define functions and prove theorems
when the base types are simpler to deal with.
Adopting this approach, both the appearance -- the set representation of integers
and the underlying -- the convenience of manipulating setoid
representation of integers, are maintained.
In the case of rational numbers, the base type is also simpler to deal with.


\section{Rational numbers}

In the Agda standard library, the set of rational numbers is defined
as fractions whose numerator and denominator are coprime. It ensures
the canonicity of representations, but it complicates the manipulation
of rational numbers since the coprimarity has to be kept for each
intermediate step of calculations. From experience of calculating
fractions in arithmetic, we usually do not reduce fractions until we are going to
show a simplified answer, and all the calculation can be carried out correctly
without reducing. Actually from  a discussion on Agda mailing list
\footnote{http://comments.gmane.org/gmane.comp.lang.agda/6372}, a better way to manipulate the
rational numbers is required. A flexibility way to choose from unreduced fractions or reduced ones in
operations can be fulfilled by a definable quotient of
rational numbers. The unreduced fractions are mainly used for underlying calculations and
property proving because it ignores a lot of reducing steps and
coprimarity checking, and the reduced fractions are accessible when
displaying rational numbers. 
It simplifies defining functions and proving properties related to rational
numbers. Moreover, we believe the efficiency of programs involving rational
numbers calculation is improved due to the removal of reducing , even
though some people claim that the unreduced numbers are too
large to make it efficient.


\subsection{The setoid of rational numbers: unreduced fractions}

The setoid representation of rational numbers -- unreduced fractions
are more common in mathematics.
Usually a fraction denoted as $\frac{m}{n}$ consists of an integers
$m$ called \emph{numerator} and a non-zero integer $n$ called
\emph{denominator}.
In type theory, since the data types have different
complexity, we have a decision to make in the choice of best
definition like what we did for integers.
Alternatively keeping the numerator integer, the denominator can be a
positive natural number such that the sign of rational number is kept
in the numerator solely and there is no need to add a restriction to
exclude $0$ which is not so easy for the set of integer.

$$\Q_0 = \Z \times \N$$

Technically there is no need to define a new type for positive
natural numbers $\N^{+}$, so we use $\N$ which we can name it as
\emph{denominator-1} or implement it as follows

\begin{code}
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℚ₀} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[-1]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_/suc\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{n} \AgdaSymbol{:} \AgdaDatatype{ℤ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{d} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\end{code}

such that $2 /suc 2$ stands for $\frac{2}{3}$.


\begin{remark}
It is also reasonable to define it with a pair of natural numbers with
a sign defined separately. However this also complicates calculation
in some way.
\end{remark}



The rational number represented by a fraction $\frac{m}{n}$ is indeed the result of
division $m \div n$. Therefore two different fractions can represent
the same rational numbers.
In mathematics, to judge the equality of two fractions, it is easier to conduct the following conversion,

$$ \frac{a}{b} = \frac{c}{d} \iff a \times d = c \times b $$


Hence the equivalence relation can be defined as,

\begin{code}
\\
\>\AgdaFunction{\_*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaNumber{0}\<%
\\
\>\AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d} \AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaInductiveConstructor{suc} \AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{\_∼\_} \<[35]%
\>[35]\AgdaSymbol{:} \AgdaFunction{Rel} \AgdaDatatype{ℚ₀} \AgdaSymbol{\_}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{n1} \AgdaInductiveConstructor{/suc} \AgdaBound{d1}\AgdaSymbol{)} \AgdaFunction{∼} \AgdaSymbol{(}\AgdaBound{n2} \AgdaInductiveConstructor{/suc} \AgdaBound{d2}\AgdaSymbol{)} \AgdaSymbol{=} \<[31]%
\>[31]\AgdaBound{n1} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d2} \AgdaDatatype{≡} \AgdaBound{n2} \AgdaFunction{*} \AgdaInductiveConstructor{suc} \AgdaBound{d1}\<%
\\
\end{code}


\subsection{The set definition of rational numbers: reduced fractions}

The reduced fractions are canonical representations of rational
numbers. It is a subset of fractions, so we only need to add a
restriction that the numerator and denominator is coprime,

% The normal form of rational numbers, namely the quotient type in this quotient is the set of irreducible fractions. We only need to add a restriction that the numerator and denominator is coprime,

$$\Q = \Sigma ((n , d) : \Z \times \N)). \mathsf{coprime} ~n ~(d +1)$$

It is implemented as follows (also available in standard library),

\begin{code}
\\
\>\AgdaKeyword{record} \AgdaRecord{ℚ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{numerator} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{denominator-1} \AgdaSymbol{:} \AgdaDatatype{ℕ}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{isCoprime} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{C.coprime?} \AgdaFunction{∣} \AgdaBound{numerator} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{denominator-1}\AgdaSymbol{))}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{:} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{denominator} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaFunction{denominator-1}\<%
\\
%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{:} \AgdaFunction{Coprime} \AgdaFunction{numerator} \AgdaFunction{denominator}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{coprime} \AgdaSymbol{=} \AgdaFunction{toWitness} \AgdaFunction{isCoprime}\<%
\\
\end{code}

\subsection{The definable quotient of rational numbers}

From the definition, we already have a setoid which contains unreduced
fractions $\Q_0$ as
base type and an equivalence relation on it. Compare with the set
definition, it is clear that normalisation from $\Q_0 \to \Q$ is just
reducing functions.

To implement reducing process, we can utilize the library code about
\emph{great common divisor (gcd)}. The function $\AgdaFunction{gcd}$
calculates the divisor and a data type $\AgdaDatatype{GCD}$ containing
information from calculating the
greatest common divisor which can be converted to another data type $\AgdaDatatype{GCD′}$
\footnote{http://www.cse.chalmers.se/~nad/repos/lib/src/Data/Nat/Coprimality.agda}
which contains the three essential results we need, i.e.\ the new numerator, new denominator and the
proof term that they are coprime. Combing the library functions and
types with a self-defined function
$\AgdaFunction{GCD′→ℚ}$\footnote{see \autoref{rational-gcd}} which
constructs the reduced fraction we need, the normalisation function is
implemented as follows,

\begin{code}
\\
\>\AgdaFunction{[\_]} \AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaRecord{ℚ}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{0}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{=} \AgdaInductiveConstructor{ℤ.+\_} \AgdaNumber{0} \AgdaFunction{÷} \AgdaNumber{1}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaSymbol{=} \AgdaFunction{GCD′→ℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaBound{di} \AgdaSymbol{(λ} \AgdaSymbol{())} \AgdaSymbol{(}\AgdaFunction{C.gcd-gcd′} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)}\<%
\\
\>\AgdaSymbol{...} \AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaBound{g} \AgdaSymbol{=} \AgdaFunction{-} \AgdaFunction{GCD′→ℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaBound{di} \AgdaSymbol{(λ} \AgdaSymbol{())} \AgdaSymbol{(}\AgdaFunction{C.gcd-gcd′} \AgdaBound{g}\AgdaSymbol{)}\<%
\\
\end{code}


and the embedding function is trivial, because we only need to forget
the coprime proof in the normal form,

\begin{code}
\\
\>\AgdaFunction{⌜\_⌝} \AgdaSymbol{:} \AgdaRecord{ℚ} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\>\AgdaFunction{⌜} \AgdaBound{x} \AgdaFunction{⌝} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{ℤcon} \AgdaSymbol{(}\AgdaFunction{ℚ.numerator} \AgdaBound{x}\AgdaSymbol{))} \AgdaInductiveConstructor{/suc} \AgdaSymbol{(}\AgdaFunction{ℚ.denominator-1} \AgdaBound{x}\AgdaSymbol{)}\<%
\\
\end{code}

Similar to the case of integers, complete the definable quotient, we
also need to prove the sound, complete, stable and exact
properties. There is no need to show the proof of them since the
normalisation function is implemented using an approach which has been
tested in mathematics.
Also we can apply the definable quotient structures in helping form
the field of rational numbers. After embedding the natural numbers
into integers, any theorems using only the operations in the field
$\Q$, are turned out to be propositions of integers which can be
solved using ring solver or theorems proven for integers.





The pullback functor.

\begin{displaymath}
    \xymatrix{X' \ar[r]^{p} \ar[d]_{f^{*}(a)} & Y' \ar[d]^a \\
      X \ar[r]^f& Y }
\end{displaymath}


Observe that $X \rightarrow 1 \cong X$, therefore the pullback of y which is
$X/1 \rightarrow X \times Y / Y$ can be seen as a pullback of X of type $X \rightarrow
X/Y$.

The left adjoint to the pullback functor $f*$ is just the post
composition of $f$ written as $f \circ\_$ or $\Sigma_f$.

\begin{displaymath}
    \xymatrix{X' \ar@{=}[r] \ar[d]_{a} & X' \ar[d]^{\Sigma_f a} \\
      X \ar[r]^f& Y }
\end{displaymath}


